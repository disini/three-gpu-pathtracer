{"mappings":"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","sources":["node_modules/three/examples/jsm/loaders/LDrawLoader.js","node_modules/three/examples/jsm/utils/LDrawUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tFileLoader,\n\tGroup,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tMatrix4,\n\tMesh,\n\tMeshStandardMaterial,\n\tShaderMaterial,\n\tSRGBColorSpace,\n\tUniformsLib,\n\tUniformsUtils,\n\tVector3,\n\tRay\n} from 'three';\n\n// Special surface finish tag types.\n// Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\nconst FINISH_TYPE_DEFAULT = 0;\nconst FINISH_TYPE_CHROME = 1;\nconst FINISH_TYPE_PEARLESCENT = 2;\nconst FINISH_TYPE_RUBBER = 3;\nconst FINISH_TYPE_MATTE_METALLIC = 4;\nconst FINISH_TYPE_METAL = 5;\n\n// State machine to search a subobject path.\n// The LDraw standard establishes these various possible subfolders.\nconst FILE_LOCATION_TRY_PARTS = 0;\nconst FILE_LOCATION_TRY_P = 1;\nconst FILE_LOCATION_TRY_MODELS = 2;\nconst FILE_LOCATION_AS_IS = 3;\nconst FILE_LOCATION_TRY_RELATIVE = 4;\nconst FILE_LOCATION_TRY_ABSOLUTE = 5;\nconst FILE_LOCATION_NOT_FOUND = 6;\n\nconst MAIN_COLOUR_CODE = '16';\nconst MAIN_EDGE_COLOUR_CODE = '24';\n\nconst COLOR_SPACE_LDRAW = SRGBColorSpace;\n\nconst _tempVec0 = new Vector3();\nconst _tempVec1 = new Vector3();\n\nclass LDrawConditionalLineMaterial extends ShaderMaterial {\n\n\tconstructor( parameters ) {\n\n\t\tsuper( {\n\n\t\t\tuniforms: UniformsUtils.merge( [\n\t\t\t\tUniformsLib.fog,\n\t\t\t\t{\n\t\t\t\t\tdiffuse: {\n\t\t\t\t\t\tvalue: new Color()\n\t\t\t\t\t},\n\t\t\t\t\topacity: {\n\t\t\t\t\t\tvalue: 1.0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t] ),\n\n\t\t\tvertexShader: /* glsl */`\n\t\t\t\tattribute vec3 control0;\n\t\t\t\tattribute vec3 control1;\n\t\t\t\tattribute vec3 direction;\n\t\t\t\tvarying float discardFlag;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <color_pars_vertex>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\t\t\t\t#include <clipping_planes_pars_vertex>\n\t\t\t\tvoid main() {\n\t\t\t\t\t#include <color_vertex>\n\n\t\t\t\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t\t// Transform the line segment ends and control points into camera clip space\n\t\t\t\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\t\t\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\t\t\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\t\t\t\tc0.xy /= c0.w;\n\t\t\t\t\tc1.xy /= c1.w;\n\t\t\t\t\tp0.xy /= p0.w;\n\t\t\t\t\tp1.xy /= p1.w;\n\n\t\t\t\t\t// Get the direction of the segment and an orthogonal vector\n\t\t\t\t\tvec2 dir = p1.xy - p0.xy;\n\t\t\t\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t\t\t\t// Get control point directions from the line\n\t\t\t\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\t\t\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t\t\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t\t\t\t// from the line segment then the line should not be drawn.\n\t\t\t\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\t\t\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\t\t\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t\t#include <clipping_planes_vertex>\n\t\t\t\t\t#include <fog_vertex>\n\t\t\t\t}\n\t\t\t`,\n\n\t\t\tfragmentShader: /* glsl */`\n\t\t\tuniform vec3 diffuse;\n\t\t\tuniform float opacity;\n\t\t\tvarying float discardFlag;\n\n\t\t\t#include <common>\n\t\t\t#include <color_pars_fragment>\n\t\t\t#include <fog_pars_fragment>\n\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t#include <clipping_planes_pars_fragment>\n\t\t\tvoid main() {\n\n\t\t\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t\t\t#include <clipping_planes_fragment>\n\t\t\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t#include <color_fragment>\n\t\t\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\t\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t#include <colorspace_fragment>\n\t\t\t\t#include <fog_fragment>\n\t\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t}\n\t\t\t`,\n\n\t\t} );\n\n\t\tObject.defineProperties( this, {\n\n\t\t\topacity: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.opacity.value;\n\n\t\t\t\t},\n\n\t\t\t\tset: function ( value ) {\n\n\t\t\t\t\tthis.uniforms.opacity.value = value;\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcolor: {\n\t\t\t\tget: function () {\n\n\t\t\t\t\treturn this.uniforms.diffuse.value;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t} );\n\n\t\tthis.setValues( parameters );\n\t\tthis.isLDrawConditionalLineMaterial = true;\n\n\t}\n\n}\n\nclass ConditionalLineSegments extends LineSegments {\n\n\tconstructor( geometry, material ) {\n\n\t\tsuper( geometry, material );\n\t\tthis.isConditionalLine = true;\n\n\t}\n\n}\n\nfunction generateFaceNormals( faces ) {\n\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst face = faces[ i ];\n\t\tconst vertices = face.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\tconst v2 = vertices[ 2 ];\n\n\t\t_tempVec0.subVectors( v1, v0 );\n\t\t_tempVec1.subVectors( v2, v1 );\n\t\tface.faceNormal = new Vector3()\n\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t.normalize();\n\n\t}\n\n}\n\nconst _ray = new Ray();\nfunction smoothNormals( faces, lineSegments, checkSubSegments = false ) {\n\n\t// NOTE: 1e2 is pretty coarse but was chosen to quantize the resulting value because\n\t// it allows edges to be smoothed as expected (see minifig arms).\n\t// --\n\t// And the vector values are initialize multiplied by 1 + 1e-10 to account for floating\n\t// point errors on vertices along quantization boundaries. Ie after matrix multiplication\n\t// vertices that should be merged might be set to \"1.7\" and \"1.6999...\" meaning they won't\n\t// get merged. This added epsilon attempts to push these error values to the same quantized\n\t// value for the sake of hashing. See \"AT-ST mini\" dishes. See mrdoob/three#23169.\n\n\tconst hashMultiplier = ( 1 + 1e-10 ) * 1e2;\n\tfunction hashVertex( v ) {\n\n\t\tconst x = ~ ~ ( v.x * hashMultiplier );\n\t\tconst y = ~ ~ ( v.y * hashMultiplier );\n\t\tconst z = ~ ~ ( v.z * hashMultiplier );\n\n\t\treturn `${ x },${ y },${ z }`;\n\n\t}\n\n\tfunction hashEdge( v0, v1 ) {\n\n\t\treturn `${ hashVertex( v0 ) }_${ hashVertex( v1 ) }`;\n\n\t}\n\n\t// converts the two vertices to a ray with a normalized direction and origin of 0, 0, 0 projected\n\t// onto the original line.\n\tfunction toNormalizedRay( v0, v1, targetRay ) {\n\n\t\ttargetRay.direction.subVectors( v1, v0 ).normalize();\n\n\t\tconst scalar = v0.dot( targetRay.direction );\n\t\ttargetRay.origin.copy( v0 ).addScaledVector( targetRay.direction, - scalar );\n\n\t\treturn targetRay;\n\n\t}\n\n\tfunction hashRay( ray ) {\n\n\t\treturn hashEdge( ray.origin, ray.direction );\n\n\t}\n\n\tconst hardEdges = new Set();\n\tconst hardEdgeRays = new Map();\n\tconst halfEdgeList = {};\n\tconst normals = [];\n\n\t// Save the list of hard edges by hash\n\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\tconst ls = lineSegments[ i ];\n\t\tconst vertices = ls.vertices;\n\t\tconst v0 = vertices[ 0 ];\n\t\tconst v1 = vertices[ 1 ];\n\t\thardEdges.add( hashEdge( v0, v1 ) );\n\t\thardEdges.add( hashEdge( v1, v0 ) );\n\n\t\t// only generate the hard edge ray map if we're checking subsegments because it's more expensive to check\n\t\t// and requires more memory.\n\t\tif ( checkSubSegments ) {\n\n\t\t\t// add both ray directions to the map\n\t\t\tconst ray = toNormalizedRay( v0, v1, new Ray() );\n\t\t\tconst rh1 = hashRay( ray );\n\t\t\tif ( ! hardEdgeRays.has( rh1 ) ) {\n\n\t\t\t\ttoNormalizedRay( v1, v0, ray );\n\t\t\t\tconst rh2 = hashRay( ray );\n\n\t\t\t\tconst info = {\n\t\t\t\t\tray,\n\t\t\t\t\tdistances: [],\n\t\t\t\t};\n\n\t\t\t\thardEdgeRays.set( rh1, info );\n\t\t\t\thardEdgeRays.set( rh2, info );\n\n\t\t\t}\n\n\t\t\t// store both segments ends in min, max order in the distances array to check if a face edge is a\n\t\t\t// subsegment later.\n\t\t\tconst info = hardEdgeRays.get( rh1 );\n\t\t\tlet d0 = info.ray.direction.dot( v0 );\n\t\t\tlet d1 = info.ray.direction.dot( v1 );\n\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t}\n\n\t\t\tinfo.distances.push( d0, d1 );\n\n\t\t}\n\n\t}\n\n\t// track the half edges associated with each triangle\n\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\tconst tri = faces[ i ];\n\t\tconst vertices = tri.vertices;\n\t\tconst vertCount = vertices.length;\n\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\tconst index = i2;\n\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\tconst v0 = vertices[ index ];\n\t\t\tconst v1 = vertices[ next ];\n\t\t\tconst hash = hashEdge( v0, v1 );\n\n\t\t\t// don't add the triangle if the edge is supposed to be hard\n\t\t\tif ( hardEdges.has( hash ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// if checking subsegments then check to see if this edge lies on a hard edge ray and whether its within any ray bounds\n\t\t\tif ( checkSubSegments ) {\n\n\t\t\t\ttoNormalizedRay( v0, v1, _ray );\n\n\t\t\t\tconst rayHash = hashRay( _ray );\n\t\t\t\tif ( hardEdgeRays.has( rayHash ) ) {\n\n\t\t\t\t\tconst info = hardEdgeRays.get( rayHash );\n\t\t\t\t\tconst { ray, distances } = info;\n\t\t\t\t\tlet d0 = ray.direction.dot( v0 );\n\t\t\t\t\tlet d1 = ray.direction.dot( v1 );\n\n\t\t\t\t\tif ( d0 > d1 ) {\n\n\t\t\t\t\t\t[ d0, d1 ] = [ d1, d0 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// return early if the face edge is found to be a subsegment of a line edge meaning the edge will have \"hard\" normals\n\t\t\t\t\tlet found = false;\n\t\t\t\t\tfor ( let i = 0, l = distances.length; i < l; i += 2 ) {\n\n\t\t\t\t\t\tif ( d0 >= distances[ i ] && d1 <= distances[ i + 1 ] ) {\n\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( found ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst info = {\n\t\t\t\tindex: index,\n\t\t\t\ttri: tri\n\t\t\t};\n\t\t\thalfEdgeList[ hash ] = info;\n\n\t\t}\n\n\t}\n\n\t// Iterate until we've tried to connect all faces to share normals\n\twhile ( true ) {\n\n\t\t// Stop if there are no more faces left\n\t\tlet halfEdge = null;\n\t\tfor ( const key in halfEdgeList ) {\n\n\t\t\thalfEdge = halfEdgeList[ key ];\n\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( halfEdge === null ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t\t// Exhaustively find all connected faces\n\t\tconst queue = [ halfEdge ];\n\t\twhile ( queue.length > 0 ) {\n\n\t\t\t// initialize all vertex normals in this triangle\n\t\t\tconst tri = queue.pop().tri;\n\t\t\tconst vertices = tri.vertices;\n\t\t\tconst vertNormals = tri.normals;\n\t\t\tconst faceNormal = tri.faceNormal;\n\n\t\t\t// Check if any edge is connected to another triangle edge\n\t\t\tconst vertCount = vertices.length;\n\t\t\tfor ( let i2 = 0; i2 < vertCount; i2 ++ ) {\n\n\t\t\t\tconst index = i2;\n\t\t\t\tconst next = ( i2 + 1 ) % vertCount;\n\t\t\t\tconst v0 = vertices[ index ];\n\t\t\t\tconst v1 = vertices[ next ];\n\n\t\t\t\t// delete this triangle from the list so it won't be found again\n\t\t\t\tconst hash = hashEdge( v0, v1 );\n\t\t\t\tdelete halfEdgeList[ hash ];\n\n\t\t\t\tconst reverseHash = hashEdge( v1, v0 );\n\t\t\t\tconst otherInfo = halfEdgeList[ reverseHash ];\n\t\t\t\tif ( otherInfo ) {\n\n\t\t\t\t\tconst otherTri = otherInfo.tri;\n\t\t\t\t\tconst otherIndex = otherInfo.index;\n\t\t\t\t\tconst otherNormals = otherTri.normals;\n\t\t\t\t\tconst otherVertCount = otherNormals.length;\n\t\t\t\t\tconst otherFaceNormal = otherTri.faceNormal;\n\n\t\t\t\t\t// NOTE: If the angle between faces is > 67.5 degrees then assume it's\n\t\t\t\t\t// hard edge. There are some cases where the line segments do not line up exactly\n\t\t\t\t\t// with or span multiple triangle edges (see Lunar Vehicle wheels).\n\t\t\t\t\tif ( Math.abs( otherTri.faceNormal.dot( tri.faceNormal ) ) < 0.25 ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// if this triangle has already been traversed then it won't be in\n\t\t\t\t\t// the halfEdgeList. If it has not then add it to the queue and delete\n\t\t\t\t\t// it so it won't be found again.\n\t\t\t\t\tif ( reverseHash in halfEdgeList ) {\n\n\t\t\t\t\t\tqueue.push( otherInfo );\n\t\t\t\t\t\tdelete halfEdgeList[ reverseHash ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the first normal\n\t\t\t\t\tconst otherNext = ( otherIndex + 1 ) % otherVertCount;\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ index ] && otherNormals[ otherNext ] &&\n\t\t\t\t\t\tvertNormals[ index ] !== otherNormals[ otherNext ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherNext ].norm.add( vertNormals[ index ].norm );\n\t\t\t\t\t\tvertNormals[ index ].norm = otherNormals[ otherNext ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal1 = vertNormals[ index ] || otherNormals[ otherNext ];\n\t\t\t\t\tif ( sharedNormal1 === null ) {\n\n\t\t\t\t\t\t// it's possible to encounter an edge of a triangle that has already been traversed meaning\n\t\t\t\t\t\t// both edges already have different normals defined and shared. To work around this we create\n\t\t\t\t\t\t// a wrapper object so when those edges are merged the normals can be updated everywhere.\n\t\t\t\t\t\tsharedNormal1 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal1.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ index ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ index ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherNext ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherNext ] = sharedNormal1;\n\t\t\t\t\t\tsharedNormal1.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// share the second normal\n\t\t\t\t\tif (\n\t\t\t\t\t\tvertNormals[ next ] && otherNormals[ otherIndex ] &&\n\t\t\t\t\t\tvertNormals[ next ] !== otherNormals[ otherIndex ]\n\t\t\t\t\t) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ].norm.add( vertNormals[ next ].norm );\n\t\t\t\t\t\tvertNormals[ next ].norm = otherNormals[ otherIndex ].norm;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet sharedNormal2 = vertNormals[ next ] || otherNormals[ otherIndex ];\n\t\t\t\t\tif ( sharedNormal2 === null ) {\n\n\t\t\t\t\t\tsharedNormal2 = { norm: new Vector3() };\n\t\t\t\t\t\tnormals.push( sharedNormal2.norm );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( vertNormals[ next ] === null ) {\n\n\t\t\t\t\t\tvertNormals[ next ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( faceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( otherNormals[ otherIndex ] === null ) {\n\n\t\t\t\t\t\totherNormals[ otherIndex ] = sharedNormal2;\n\t\t\t\t\t\tsharedNormal2.norm.add( otherFaceNormal );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// The normals of each face have been added up so now we average them by normalizing the vector.\n\tfor ( let i = 0, l = normals.length; i < l; i ++ ) {\n\n\t\tnormals[ i ].normalize();\n\n\t}\n\n}\n\nfunction isPartType( type ) {\n\n\treturn type === 'Part' || type === 'Unofficial_Part';\n\n}\n\nfunction isPrimitiveType( type ) {\n\n\treturn /primitive/i.test( type ) || type === 'Subpart';\n\n}\n\nclass LineParser {\n\n\tconstructor( line, lineNumber ) {\n\n\t\tthis.line = line;\n\t\tthis.lineLength = line.length;\n\t\tthis.currentCharIndex = 0;\n\t\tthis.currentChar = ' ';\n\t\tthis.lineNumber = lineNumber;\n\n\t}\n\n\tseekNonSpace() {\n\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar !== ' ' && this.currentChar !== '\\t' ) {\n\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t}\n\n\tgetToken() {\n\n\t\tconst pos0 = this.currentCharIndex ++;\n\n\t\t// Seek space\n\t\twhile ( this.currentCharIndex < this.lineLength ) {\n\n\t\t\tthis.currentChar = this.line.charAt( this.currentCharIndex );\n\n\t\t\tif ( this.currentChar === ' ' || this.currentChar === '\\t' ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tthis.currentCharIndex ++;\n\n\t\t}\n\n\t\tconst pos1 = this.currentCharIndex;\n\n\t\tthis.seekNonSpace();\n\n\t\treturn this.line.substring( pos0, pos1 );\n\n\t}\n\n\tgetVector() {\n\n\t\treturn new Vector3( parseFloat( this.getToken() ), parseFloat( this.getToken() ), parseFloat( this.getToken() ) );\n\n\t}\n\n\tgetRemainingString() {\n\n\t\treturn this.line.substring( this.currentCharIndex, this.lineLength );\n\n\t}\n\n\tisAtTheEnd() {\n\n\t\treturn this.currentCharIndex >= this.lineLength;\n\n\t}\n\n\tsetToEnd() {\n\n\t\tthis.currentCharIndex = this.lineLength;\n\n\t}\n\n\tgetLineNumberString() {\n\n\t\treturn this.lineNumber >= 0 ? ' at line ' + this.lineNumber : '';\n\n\t}\n\n}\n\n// Fetches and parses an intermediate representation of LDraw parts files.\nclass LDrawParsedCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis._cache = {};\n\n\t}\n\n\tcloneResult( original ) {\n\n\t\tconst result = {};\n\n\t\t// vertices are transformed and normals computed before being converted to geometry\n\t\t// so these pieces must be cloned.\n\t\tresult.faces = original.faces.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tnormals: face.normals.map( () => null ),\n\t\t\t\tfaceNormal: null\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.conditionalSegments = original.conditionalSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() ),\n\t\t\t\tcontrolPoints: face.controlPoints.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\tresult.lineSegments = original.lineSegments.map( face => {\n\n\t\t\treturn {\n\t\t\t\tcolorCode: face.colorCode,\n\t\t\t\tmaterial: face.material,\n\t\t\t\tvertices: face.vertices.map( v => v.clone() )\n\t\t\t};\n\n\t\t} );\n\n\t\t// none if this is subsequently modified\n\t\tresult.type = original.type;\n\t\tresult.category = original.category;\n\t\tresult.keywords = original.keywords;\n\t\tresult.author = original.author;\n\t\tresult.subobjects = original.subobjects;\n\t\tresult.fileName = original.fileName;\n\t\tresult.totalFaces = original.totalFaces;\n\t\tresult.startingBuildingStep = original.startingBuildingStep;\n\t\tresult.materials = original.materials;\n\t\tresult.group = null;\n\t\treturn result;\n\n\t}\n\n\tasync fetchData( fileName ) {\n\n\t\tlet triedLowerCase = false;\n\t\tlet locationState = FILE_LOCATION_TRY_PARTS;\n\t\twhile ( locationState !== FILE_LOCATION_NOT_FOUND ) {\n\n\t\t\tlet subobjectURL = fileName;\n\t\t\tswitch ( locationState ) {\n\n\t\t\t\tcase FILE_LOCATION_AS_IS:\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_PARTS:\n\t\t\t\t\tsubobjectURL = 'parts/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_P:\n\t\t\t\t\tsubobjectURL = 'p/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_MODELS:\n\t\t\t\t\tsubobjectURL = 'models/' + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_RELATIVE:\n\t\t\t\t\tsubobjectURL = fileName.substring( 0, fileName.lastIndexOf( '/' ) + 1 ) + subobjectURL;\n\t\t\t\t\tlocationState = locationState + 1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase FILE_LOCATION_TRY_ABSOLUTE:\n\n\t\t\t\t\tif ( triedLowerCase ) {\n\n\t\t\t\t\t\t// Try absolute path\n\t\t\t\t\t\tlocationState = FILE_LOCATION_NOT_FOUND;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Next attempt is lower case\n\t\t\t\t\t\tfileName = fileName.toLowerCase();\n\t\t\t\t\t\tsubobjectURL = fileName;\n\t\t\t\t\t\ttriedLowerCase = true;\n\t\t\t\t\t\tlocationState = FILE_LOCATION_TRY_PARTS;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst loader = this.loader;\n\t\t\tconst fileLoader = new FileLoader( loader.manager );\n\t\t\tfileLoader.setPath( loader.partsLibraryPath );\n\t\t\tfileLoader.setRequestHeader( loader.requestHeader );\n\t\t\tfileLoader.setWithCredentials( loader.withCredentials );\n\n\t\t\ttry {\n\n\t\t\t\tconst text = await fileLoader.loadAsync( subobjectURL );\n\t\t\t\treturn text;\n\n\t\t\t} catch ( _ ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthrow new Error( 'LDrawLoader: Subobject \"' + fileName + '\" could not be loaded.' );\n\n\t}\n\n\tparse( text, fileName = null ) {\n\n\t\tconst loader = this.loader;\n\n\t\t// final results\n\t\tconst faces = [];\n\t\tconst lineSegments = [];\n\t\tconst conditionalSegments = [];\n\t\tconst subobjects = [];\n\t\tconst materials = {};\n\n\t\tconst getLocalMaterial = colorCode => {\n\n\t\t\treturn materials[ colorCode ] || null;\n\n\t\t};\n\n\t\tlet type = 'Model';\n\t\tlet category = null;\n\t\tlet keywords = null;\n\t\tlet author = null;\n\t\tlet totalFaces = 0;\n\n\t\t// split into lines\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tconst lines = text.split( '\\n' );\n\t\tconst numLines = lines.length;\n\n\t\tlet parsingEmbeddedFiles = false;\n\t\tlet currentEmbeddedFileName = null;\n\t\tlet currentEmbeddedText = null;\n\n\t\tlet bfcCertified = false;\n\t\tlet bfcCCW = true;\n\t\tlet bfcInverted = false;\n\t\tlet bfcCull = true;\n\n\t\tlet startingBuildingStep = false;\n\n\t\t// Parse all line commands\n\t\tfor ( let lineIndex = 0; lineIndex < numLines; lineIndex ++ ) {\n\n\t\t\tconst line = lines[ lineIndex ];\n\n\t\t\tif ( line.length === 0 ) continue;\n\n\t\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\t\tif ( line.startsWith( '0 FILE ' ) ) {\n\n\t\t\t\t\t// Save previous embedded file in the cache\n\t\t\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t\t\t\t// New embedded text file\n\t\t\t\t\tcurrentEmbeddedFileName = line.substring( 7 );\n\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentEmbeddedText += line + '\\n';\n\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst lp = new LineParser( line, lineIndex + 1 );\n\t\t\tlp.seekNonSpace();\n\n\t\t\tif ( lp.isAtTheEnd() ) {\n\n\t\t\t\t// Empty line\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Parse the line type\n\t\t\tconst lineType = lp.getToken();\n\n\t\t\tlet material;\n\t\t\tlet colorCode;\n\t\t\tlet segment;\n\t\t\tlet ccw;\n\t\t\tlet doubleSided;\n\t\t\tlet v0, v1, v2, v3, c0, c1;\n\n\t\t\tswitch ( lineType ) {\n\n\t\t\t\t// Line type 0: Comment or META\n\t\t\t\tcase '0':\n\n\t\t\t\t\t// Parse meta directive\n\t\t\t\t\tconst meta = lp.getToken();\n\n\t\t\t\t\tif ( meta ) {\n\n\t\t\t\t\t\tswitch ( meta ) {\n\n\t\t\t\t\t\t\tcase '!LDRAW_ORG':\n\n\t\t\t\t\t\t\t\ttype = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!COLOUR':\n\n\t\t\t\t\t\t\t\tmaterial = loader.parseColorMetaDirective( lp );\n\t\t\t\t\t\t\t\tif ( material ) {\n\n\t\t\t\t\t\t\t\t\tmaterials[ material.userData.code ] = material;\n\n\t\t\t\t\t\t\t\t}\telse {\n\n\t\t\t\t\t\t\t\t\tconsole.warn( 'LDrawLoader: Error parsing material' + lp.getLineNumberString() );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!CATEGORY':\n\n\t\t\t\t\t\t\t\tcategory = lp.getToken();\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase '!KEYWORDS':\n\n\t\t\t\t\t\t\t\tconst newKeywords = lp.getRemainingString().split( ',' );\n\t\t\t\t\t\t\t\tif ( newKeywords.length > 0 ) {\n\n\t\t\t\t\t\t\t\t\tif ( ! keywords ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords = [];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnewKeywords.forEach( function ( keyword ) {\n\n\t\t\t\t\t\t\t\t\t\tkeywords.push( keyword.trim() );\n\n\t\t\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'FILE':\n\n\t\t\t\t\t\t\t\tif ( lineIndex > 0 ) {\n\n\t\t\t\t\t\t\t\t\t// Start embedded text files parsing\n\t\t\t\t\t\t\t\t\tparsingEmbeddedFiles = true;\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedFileName = lp.getRemainingString();\n\t\t\t\t\t\t\t\t\tcurrentEmbeddedText = '';\n\n\t\t\t\t\t\t\t\t\tbfcCertified = false;\n\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'BFC':\n\n\t\t\t\t\t\t\t\t// Changes to the backface culling state\n\t\t\t\t\t\t\t\twhile ( ! lp.isAtTheEnd() ) {\n\n\t\t\t\t\t\t\t\t\tconst token = lp.getToken();\n\n\t\t\t\t\t\t\t\t\tswitch ( token ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'CERTIFY':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCERTIFY':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCertified = token === 'CERTIFY';\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CW':\n\t\t\t\t\t\t\t\t\t\tcase 'CCW':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCCW = token === 'CCW';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'INVERTNEXT':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcInverted = true;\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'CLIP':\n\t\t\t\t\t\t\t\t\t\tcase 'NOCLIP':\n\n\t\t\t\t\t\t\t\t\t\t\tbfcCull = token === 'CLIP';\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.' );\n\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'STEP':\n\n\t\t\t\t\t\t\t\tstartingBuildingStep = true;\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'Author:':\n\n\t\t\t\t\t\t\t\tauthor = lp.getToken();\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t// Other meta directives are not implemented\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 1: Sub-object file\n\t\t\t\tcase '1':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\n\t\t\t\t\tconst posX = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posY = parseFloat( lp.getToken() );\n\t\t\t\t\tconst posZ = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m0 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m1 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m2 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m3 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m4 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m5 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m6 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m7 = parseFloat( lp.getToken() );\n\t\t\t\t\tconst m8 = parseFloat( lp.getToken() );\n\n\t\t\t\t\tconst matrix = new Matrix4().set(\n\t\t\t\t\t\tm0, m1, m2, posX,\n\t\t\t\t\t\tm3, m4, m5, posY,\n\t\t\t\t\t\tm6, m7, m8, posZ,\n\t\t\t\t\t\t0, 0, 0, 1\n\t\t\t\t\t);\n\n\t\t\t\t\tlet fileName = lp.getRemainingString().trim().replace( /\\\\/g, '/' );\n\n\t\t\t\t\tif ( loader.fileMap[ fileName ] ) {\n\n\t\t\t\t\t\t// Found the subobject path in the preloaded file path map\n\t\t\t\t\t\tfileName = loader.fileMap[ fileName ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Standardized subfolders\n\t\t\t\t\t\tif ( fileName.startsWith( 's/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'parts/' + fileName;\n\n\t\t\t\t\t\t} else if ( fileName.startsWith( '48/' ) ) {\n\n\t\t\t\t\t\t\tfileName = 'p/' + fileName;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tsubobjects.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tmatrix: matrix,\n\t\t\t\t\t\tfileName: fileName,\n\t\t\t\t\t\tinverted: bfcInverted,\n\t\t\t\t\t\tstartingBuildingStep: startingBuildingStep\n\t\t\t\t\t} );\n\n\t\t\t\t\tstartingBuildingStep = false;\n\t\t\t\t\tbfcInverted = false;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 2: Line segment\n\t\t\t\tcase '2':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tlineSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 5: Conditional Line segment\n\t\t\t\tcase '5':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\tc0 = lp.getVector();\n\t\t\t\t\tc1 = lp.getVector();\n\n\t\t\t\t\tsegment = {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tvertices: [ v0, v1 ],\n\t\t\t\t\t\tcontrolPoints: [ c0, c1 ],\n\t\t\t\t\t};\n\n\t\t\t\t\tconditionalSegments.push( segment );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 3: Triangle\n\t\t\t\tcase '3':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2 ],\n\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t\t// Line type 4: Quadrilateral\n\t\t\t\tcase '4':\n\n\t\t\t\t\tcolorCode = lp.getToken();\n\t\t\t\t\tmaterial = getLocalMaterial( colorCode );\n\t\t\t\t\tccw = bfcCCW;\n\t\t\t\t\tdoubleSided = ! bfcCertified || ! bfcCull;\n\n\t\t\t\t\tif ( ccw === true ) {\n\n\t\t\t\t\t\tv0 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv3 = lp.getVector();\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tv3 = lp.getVector();\n\t\t\t\t\t\tv2 = lp.getVector();\n\t\t\t\t\t\tv1 = lp.getVector();\n\t\t\t\t\t\tv0 = lp.getVector();\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// specifically place the triangle diagonal in the v0 and v1 slots so we can\n\t\t\t\t\t// account for the doubling of vertices later when smoothing normals.\n\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\tvertices: [ v0, v1, v2, v3 ],\n\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t} );\n\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\tif ( doubleSided === true ) {\n\n\t\t\t\t\t\tfaces.push( {\n\t\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\t\tcolorCode: colorCode,\n\t\t\t\t\t\t\tfaceNormal: null,\n\t\t\t\t\t\t\tvertices: [ v3, v2, v1, v0 ],\n\t\t\t\t\t\t\tnormals: [ null, null, null, null ],\n\t\t\t\t\t\t} );\n\t\t\t\t\t\ttotalFaces += 2;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parsingEmbeddedFiles ) {\n\n\t\t\tthis.setData( currentEmbeddedFileName, currentEmbeddedText );\n\n\t\t}\n\n\t\treturn {\n\t\t\tfaces,\n\t\t\tconditionalSegments,\n\t\t\tlineSegments,\n\t\t\ttype,\n\t\t\tcategory,\n\t\t\tkeywords,\n\t\t\tauthor,\n\t\t\tsubobjects,\n\t\t\ttotalFaces,\n\t\t\tstartingBuildingStep,\n\t\t\tmaterials,\n\t\t\tfileName,\n\t\t\tgroup: null\n\t\t};\n\n\t}\n\n\t// returns an (optionally cloned) instance of the data\n\tgetData( fileName, clone = true ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tconst result = this._cache[ key ];\n\t\tif ( result === null || result instanceof Promise ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( clone ) {\n\n\t\t\treturn this.cloneResult( result );\n\n\t\t} else {\n\n\t\t\treturn result;\n\n\t\t}\n\n\t}\n\n\t// kicks off a fetch and parse of the requested data if it hasn't already been loaded. Returns when\n\t// the data is ready to use and can be retrieved synchronously with \"getData\".\n\tasync ensureDataLoaded( fileName ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( ! ( key in this._cache ) ) {\n\n\t\t\t// replace the promise with a copy of the parsed data for immediate processing\n\t\t\tthis._cache[ key ] = this.fetchData( fileName ).then( text => {\n\n\t\t\t\tconst info = this.parse( text, fileName );\n\t\t\t\tthis._cache[ key ] = info;\n\t\t\t\treturn info;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tawait this._cache[ key ];\n\n\t}\n\n\t// sets the data in the cache from parsed data\n\tsetData( fileName, text ) {\n\n\t\tconst key = fileName.toLowerCase();\n\t\tthis._cache[ key ] = this.parse( text, fileName );\n\n\t}\n\n}\n\n// returns the material for an associated color code. If the color code is 16 for a face or 24 for\n// an edge then the passthroughColorCode is used.\nfunction getMaterialFromCode( colorCode, parentColorCode, materialHierarchy, forEdge ) {\n\n\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\tif ( isPassthrough ) {\n\n\t\tcolorCode = parentColorCode;\n\n\t}\n\n\treturn materialHierarchy[ colorCode ] || null;\n\n}\n\n// Class used to parse and build LDraw parts as three.js objects and cache them if they're a \"Part\" type.\nclass LDrawPartsGeometryCache {\n\n\tconstructor( loader ) {\n\n\t\tthis.loader = loader;\n\t\tthis.parseCache = new LDrawParsedCache( loader );\n\t\tthis._cache = {};\n\n\t}\n\n\t// Convert the given file information into a mesh by processing subobjects.\n\tasync processIntoMesh( info ) {\n\n\t\tconst loader = this.loader;\n\t\tconst parseCache = this.parseCache;\n\t\tconst faceMaterials = new Set();\n\n\t\t// Processes the part subobject information to load child parts and merge geometry onto part\n\t\t// piece object.\n\t\tconst processInfoSubobjects = async ( info, subobject = null ) => {\n\n\t\t\tconst subobjects = info.subobjects;\n\t\t\tconst promises = [];\n\n\t\t\t// Trigger load of all subobjects. If a subobject isn't a primitive then load it as a separate\n\t\t\t// group which lets instruction steps apply correctly.\n\t\t\tfor ( let i = 0, l = subobjects.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = subobjects[ i ];\n\t\t\t\tconst promise = parseCache.ensureDataLoaded( subobject.fileName ).then( () => {\n\n\t\t\t\t\tconst subobjectInfo = parseCache.getData( subobject.fileName, false );\n\t\t\t\t\tif ( ! isPrimitiveType( subobjectInfo.type ) ) {\n\n\t\t\t\t\t\treturn this.loadModel( subobject.fileName ).catch( error => {\n\n\t\t\t\t\t\t\tconsole.warn( error );\n\t\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn processInfoSubobjects( parseCache.getData( subobject.fileName ), subobject );\n\n\t\t\t\t} );\n\n\t\t\t\tpromises.push( promise );\n\n\t\t\t}\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.userData.category = info.category;\n\t\t\tgroup.userData.keywords = info.keywords;\n\t\t\tgroup.userData.author = info.author;\n\t\t\tgroup.userData.type = info.type;\n\t\t\tgroup.userData.fileName = info.fileName;\n\t\t\tinfo.group = group;\n\n\t\t\tconst subobjectInfos = await Promise.all( promises );\n\t\t\tfor ( let i = 0, l = subobjectInfos.length; i < l; i ++ ) {\n\n\t\t\t\tconst subobject = info.subobjects[ i ];\n\t\t\t\tconst subobjectInfo = subobjectInfos[ i ];\n\n\t\t\t\tif ( subobjectInfo === null ) {\n\n\t\t\t\t\t// the subobject failed to load\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// if the subobject was loaded as a separate group then apply the parent scopes materials\n\t\t\t\tif ( subobjectInfo.isGroup ) {\n\n\t\t\t\t\tconst subobjectGroup = subobjectInfo;\n\t\t\t\t\tsubobject.matrix.decompose( subobjectGroup.position, subobjectGroup.quaternion, subobjectGroup.scale );\n\t\t\t\t\tsubobjectGroup.userData.startingBuildingStep = subobject.startingBuildingStep;\n\t\t\t\t\tsubobjectGroup.name = subobject.fileName;\n\n\t\t\t\t\tloader.applyMaterialsToMesh( subobjectGroup, subobject.colorCode, info.materials );\n\t\t\t\t\tsubobjectGroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t\t\tgroup.add( subobjectGroup );\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// add the subobject group if it has children in case it has both children and primitives\n\t\t\t\tif ( subobjectInfo.group.children.length ) {\n\n\t\t\t\t\tgroup.add( subobjectInfo.group );\n\n\t\t\t\t}\n\n\t\t\t\t// transform the primitives into the local space of the parent piece and append them to\n\t\t\t\t// to the parent primitives list.\n\t\t\t\tconst parentLineSegments = info.lineSegments;\n\t\t\t\tconst parentConditionalSegments = info.conditionalSegments;\n\t\t\t\tconst parentFaces = info.faces;\n\n\t\t\t\tconst lineSegments = subobjectInfo.lineSegments;\n\t\t\t\tconst conditionalSegments = subobjectInfo.conditionalSegments;\n\n\t\t\t\tconst faces = subobjectInfo.faces;\n\t\t\t\tconst matrix = subobject.matrix;\n\t\t\t\tconst inverted = subobject.inverted;\n\t\t\t\tconst matrixScaleInverted = matrix.determinant() < 0;\n\t\t\t\tconst colorCode = subobject.colorCode;\n\n\t\t\t\tconst lineColorCode = colorCode === MAIN_COLOUR_CODE ? MAIN_EDGE_COLOUR_CODE : colorCode;\n\t\t\t\tfor ( let i = 0, l = lineSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst ls = lineSegments[ i ];\n\t\t\t\t\tconst vertices = ls.vertices;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tls.colorCode = ls.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : ls.colorCode;\n\t\t\t\t\tls.material = ls.material || getMaterialFromCode( ls.colorCode, ls.colorCode, info.materials, true );\n\n\t\t\t\t\tparentLineSegments.push( ls );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = conditionalSegments.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst os = conditionalSegments[ i ];\n\t\t\t\t\tconst vertices = os.vertices;\n\t\t\t\t\tconst controlPoints = os.controlPoints;\n\t\t\t\t\tvertices[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tvertices[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 0 ].applyMatrix4( matrix );\n\t\t\t\t\tcontrolPoints[ 1 ].applyMatrix4( matrix );\n\t\t\t\t\tos.colorCode = os.colorCode === MAIN_EDGE_COLOUR_CODE ? lineColorCode : os.colorCode;\n\t\t\t\t\tos.material = os.material || getMaterialFromCode( os.colorCode, os.colorCode, info.materials, true );\n\n\t\t\t\t\tparentConditionalSegments.push( os );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst tri = faces[ i ];\n\t\t\t\t\tconst vertices = tri.vertices;\n\t\t\t\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tvertices[ i ].applyMatrix4( matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttri.colorCode = tri.colorCode === MAIN_COLOUR_CODE ? colorCode : tri.colorCode;\n\t\t\t\t\ttri.material = tri.material || getMaterialFromCode( tri.colorCode, colorCode, info.materials, false );\n\t\t\t\t\tfaceMaterials.add( tri.colorCode );\n\n\t\t\t\t\t// If the scale of the object is negated then the triangle winding order\n\t\t\t\t\t// needs to be flipped.\n\t\t\t\t\tif ( matrixScaleInverted !== inverted ) {\n\n\t\t\t\t\t\tvertices.reverse();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tparentFaces.push( tri );\n\n\t\t\t\t}\n\n\t\t\t\tinfo.totalFaces += subobjectInfo.totalFaces;\n\n\t\t\t}\n\n\t\t\t// Apply the parent subobjects pass through material code to this object. This is done several times due\n\t\t\t// to material scoping.\n\t\t\tif ( subobject ) {\n\n\t\t\t\tloader.applyMaterialsToMesh( group, subobject.colorCode, info.materials );\n\t\t\t\tgroup.userData.colorCode = subobject.colorCode;\n\n\t\t\t}\n\n\t\t\treturn info;\n\n\t\t};\n\n\t\t// Track material use to see if we need to use the normal smooth slow path for hard edges.\n\t\tfor ( let i = 0, l = info.faces; i < l; i ++ ) {\n\n\t\t\tfaceMaterials.add( info.faces[ i ].colorCode );\n\n\t\t}\n\n\t\tawait processInfoSubobjects( info );\n\n\t\tif ( loader.smoothNormals ) {\n\n\t\t\tconst checkSubSegments = faceMaterials.size > 1;\n\t\t\tgenerateFaceNormals( info.faces );\n\t\t\tsmoothNormals( info.faces, info.lineSegments, checkSubSegments );\n\n\t\t}\n\n\t\t// Add the primitive objects and metadata.\n\t\tconst group = info.group;\n\t\tif ( info.faces.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.faces, 3, false, info.totalFaces ) );\n\n\t\t}\n\n\t\tif ( info.lineSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.lineSegments, 2 ) );\n\n\t\t}\n\n\t\tif ( info.conditionalSegments.length > 0 ) {\n\n\t\t\tgroup.add( createObject( this.loader, info.conditionalSegments, 2, true ) );\n\n\t\t}\n\n\t\treturn group;\n\n\t}\n\n\thasCachedModel( fileName ) {\n\n\t\treturn fileName !== null && fileName.toLowerCase() in this._cache;\n\n\t}\n\n\tasync getCachedModel( fileName ) {\n\n\t\tif ( fileName !== null && this.hasCachedModel( fileName ) ) {\n\n\t\t\tconst key = fileName.toLowerCase();\n\t\t\tconst group = await this._cache[ key ];\n\t\t\treturn group.clone();\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\t// Loads and parses the model with the given file name. Returns a cached copy if available.\n\tasync loadModel( fileName ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst key = fileName.toLowerCase();\n\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t// Return cached model if available.\n\t\t\treturn this.getCachedModel( fileName );\n\n\t\t} else {\n\n\t\t\t// Otherwise parse a new model.\n\t\t\t// Ensure the file data is loaded and pre parsed.\n\t\t\tawait parseCache.ensureDataLoaded( fileName );\n\n\t\t\tconst info = parseCache.getData( fileName );\n\t\t\tconst promise = this.processIntoMesh( info );\n\n\t\t\t// Now that the file has loaded it's possible that another part parse has been waiting in parallel\n\t\t\t// so check the cache again to see if it's been added since the last async operation so we don't\n\t\t\t// do unnecessary work.\n\t\t\tif ( this.hasCachedModel( fileName ) ) {\n\n\t\t\t\treturn this.getCachedModel( fileName );\n\n\t\t\t}\n\n\t\t\t// Cache object if it's a part so it can be reused later.\n\t\t\tif ( isPartType( info.type ) ) {\n\n\t\t\t\tthis._cache[ key ] = promise;\n\n\t\t\t}\n\n\t\t\t// return a copy\n\t\t\tconst group = await promise;\n\t\t\treturn group.clone();\n\n\t\t}\n\n\t}\n\n\t// parses the given model text into a renderable object. Returns cached copy if available.\n\tasync parseModel( text ) {\n\n\t\tconst parseCache = this.parseCache;\n\t\tconst info = parseCache.parse( text );\n\t\tif ( isPartType( info.type ) && this.hasCachedModel( info.fileName ) ) {\n\n\t\t\treturn this.getCachedModel( info.fileName );\n\n\t\t}\n\n\t\treturn this.processIntoMesh( info );\n\n\t}\n\n}\n\nfunction sortByMaterial( a, b ) {\n\n\tif ( a.colorCode === b.colorCode ) {\n\n\t\treturn 0;\n\n\t}\n\n\tif ( a.colorCode < b.colorCode ) {\n\n\t\treturn - 1;\n\n\t}\n\n\treturn 1;\n\n}\n\nfunction createObject( loader, elements, elementSize, isConditionalSegments = false, totalElements = null ) {\n\n\t// Creates a LineSegments (elementSize = 2) or a Mesh (elementSize = 3 )\n\t// With per face / segment material, implemented with mesh groups and materials array\n\n\t// Sort the faces or line segments by color code to make later the mesh groups\n\telements.sort( sortByMaterial );\n\n\tif ( totalElements === null ) {\n\n\t\ttotalElements = elements.length;\n\n\t}\n\n\tconst positions = new Float32Array( elementSize * totalElements * 3 );\n\tconst normals = elementSize === 3 ? new Float32Array( elementSize * totalElements * 3 ) : null;\n\tconst materials = [];\n\n\tconst quadArray = new Array( 6 );\n\tconst bufferGeometry = new BufferGeometry();\n\tlet prevMaterial = null;\n\tlet index0 = 0;\n\tlet numGroupVerts = 0;\n\tlet offset = 0;\n\n\tfor ( let iElem = 0, nElem = elements.length; iElem < nElem; iElem ++ ) {\n\n\t\tconst elem = elements[ iElem ];\n\t\tlet vertices = elem.vertices;\n\t\tif ( vertices.length === 4 ) {\n\n\t\t\tquadArray[ 0 ] = vertices[ 0 ];\n\t\t\tquadArray[ 1 ] = vertices[ 1 ];\n\t\t\tquadArray[ 2 ] = vertices[ 2 ];\n\t\t\tquadArray[ 3 ] = vertices[ 0 ];\n\t\t\tquadArray[ 4 ] = vertices[ 2 ];\n\t\t\tquadArray[ 5 ] = vertices[ 3 ];\n\t\t\tvertices = quadArray;\n\n\t\t}\n\n\t\tfor ( let j = 0, l = vertices.length; j < l; j ++ ) {\n\n\t\t\tconst v = vertices[ j ];\n\t\t\tconst index = offset + j * 3;\n\t\t\tpositions[ index + 0 ] = v.x;\n\t\t\tpositions[ index + 1 ] = v.y;\n\t\t\tpositions[ index + 2 ] = v.z;\n\n\t\t}\n\n\t\t// create the normals array if this is a set of faces\n\t\tif ( elementSize === 3 ) {\n\n\t\t\tif ( ! elem.faceNormal ) {\n\n\t\t\t\tconst v0 = vertices[ 0 ];\n\t\t\t\tconst v1 = vertices[ 1 ];\n\t\t\t\tconst v2 = vertices[ 2 ];\n\t\t\t\t_tempVec0.subVectors( v1, v0 );\n\t\t\t\t_tempVec1.subVectors( v2, v1 );\n\t\t\t\telem.faceNormal = new Vector3()\n\t\t\t\t\t.crossVectors( _tempVec0, _tempVec1 )\n\t\t\t\t\t.normalize();\n\n\t\t\t}\n\n\t\t\tlet elemNormals = elem.normals;\n\t\t\tif ( elemNormals.length === 4 ) {\n\n\t\t\t\tquadArray[ 0 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 1 ] = elemNormals[ 1 ];\n\t\t\t\tquadArray[ 2 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 3 ] = elemNormals[ 0 ];\n\t\t\t\tquadArray[ 4 ] = elemNormals[ 2 ];\n\t\t\t\tquadArray[ 5 ] = elemNormals[ 3 ];\n\t\t\t\telemNormals = quadArray;\n\n\t\t\t}\n\n\t\t\tfor ( let j = 0, l = elemNormals.length; j < l; j ++ ) {\n\n\t\t\t\t// use face normal if a vertex normal is not provided\n\t\t\t\tlet n = elem.faceNormal;\n\t\t\t\tif ( elemNormals[ j ] ) {\n\n\t\t\t\t\tn = elemNormals[ j ].norm;\n\n\t\t\t\t}\n\n\t\t\t\tconst index = offset + j * 3;\n\t\t\t\tnormals[ index + 0 ] = n.x;\n\t\t\t\tnormals[ index + 1 ] = n.y;\n\t\t\t\tnormals[ index + 2 ] = n.z;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( prevMaterial !== elem.colorCode ) {\n\n\t\t\tif ( prevMaterial !== null ) {\n\n\t\t\t\tbufferGeometry.addGroup( index0, numGroupVerts, materials.length - 1 );\n\n\t\t\t}\n\n\t\t\tconst material = elem.material;\n\n\t\t\tif ( material !== null ) {\n\n\t\t\t\tif ( elementSize === 3 ) {\n\n\t\t\t\t\tmaterials.push( material );\n\n\t\t\t\t} else if ( elementSize === 2 ) {\n\n\t\t\t\t\tif ( isConditionalSegments ) {\n\n\t\t\t\t\t\tconst edgeMaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\t\t\tmaterials.push( loader.conditionalEdgeMaterialCache.get( edgeMaterial ) );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( loader.edgeMaterialCache.get( material ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// If a material has not been made available yet then keep the color code string in the material array\n\t\t\t\t// to save the spot for the material once a parent scopes materials are being applied to the object.\n\t\t\t\tmaterials.push( elem.colorCode );\n\n\t\t\t}\n\n\t\t\tprevMaterial = elem.colorCode;\n\t\t\tindex0 = offset / 3;\n\t\t\tnumGroupVerts = vertices.length;\n\n\t\t} else {\n\n\t\t\tnumGroupVerts += vertices.length;\n\n\t\t}\n\n\t\toffset += 3 * vertices.length;\n\n\t}\n\n\tif ( numGroupVerts > 0 ) {\n\n\t\tbufferGeometry.addGroup( index0, Infinity, materials.length - 1 );\n\n\t}\n\n\tbufferGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\n\tif ( normals !== null ) {\n\n\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tlet object3d = null;\n\n\tif ( elementSize === 2 ) {\n\n\t\tif ( isConditionalSegments ) {\n\n\t\t\tobject3d = new ConditionalLineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t} else {\n\n\t\t\tobject3d = new LineSegments( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t\t}\n\n\t} else if ( elementSize === 3 ) {\n\n\t\tobject3d = new Mesh( bufferGeometry, materials.length === 1 ? materials[ 0 ] : materials );\n\n\t}\n\n\tif ( isConditionalSegments ) {\n\n\t\tobject3d.isConditionalLine = true;\n\n\t\tconst controlArray0 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst controlArray1 = new Float32Array( elements.length * 3 * 2 );\n\t\tconst directionArray = new Float32Array( elements.length * 3 * 2 );\n\t\tfor ( let i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\tconst os = elements[ i ];\n\t\t\tconst vertices = os.vertices;\n\t\t\tconst controlPoints = os.controlPoints;\n\t\t\tconst c0 = controlPoints[ 0 ];\n\t\t\tconst c1 = controlPoints[ 1 ];\n\t\t\tconst v0 = vertices[ 0 ];\n\t\t\tconst v1 = vertices[ 1 ];\n\t\t\tconst index = i * 3 * 2;\n\t\t\tcontrolArray0[ index + 0 ] = c0.x;\n\t\t\tcontrolArray0[ index + 1 ] = c0.y;\n\t\t\tcontrolArray0[ index + 2 ] = c0.z;\n\t\t\tcontrolArray0[ index + 3 ] = c0.x;\n\t\t\tcontrolArray0[ index + 4 ] = c0.y;\n\t\t\tcontrolArray0[ index + 5 ] = c0.z;\n\n\t\t\tcontrolArray1[ index + 0 ] = c1.x;\n\t\t\tcontrolArray1[ index + 1 ] = c1.y;\n\t\t\tcontrolArray1[ index + 2 ] = c1.z;\n\t\t\tcontrolArray1[ index + 3 ] = c1.x;\n\t\t\tcontrolArray1[ index + 4 ] = c1.y;\n\t\t\tcontrolArray1[ index + 5 ] = c1.z;\n\n\t\t\tdirectionArray[ index + 0 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 1 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 2 ] = v1.z - v0.z;\n\t\t\tdirectionArray[ index + 3 ] = v1.x - v0.x;\n\t\t\tdirectionArray[ index + 4 ] = v1.y - v0.y;\n\t\t\tdirectionArray[ index + 5 ] = v1.z - v0.z;\n\n\t\t}\n\n\t\tbufferGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\tbufferGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t}\n\n\treturn object3d;\n\n}\n\n//\n\nclass LDrawLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Array of THREE.Material\n\t\tthis.materials = [];\n\t\tthis.materialLibrary = {};\n\t\tthis.edgeMaterialCache = new WeakMap();\n\t\tthis.conditionalEdgeMaterialCache = new WeakMap();\n\n\t\t// This also allows to handle the embedded text files (\"0 FILE\" lines)\n\t\tthis.partsCache = new LDrawPartsGeometryCache( this );\n\n\t\t// This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\t\tthis.fileMap = {};\n\n\t\t// Initializes the materials library with default materials\n\t\tthis.setMaterials( [] );\n\n\t\t// If this flag is set to true the vertex normals will be smoothed.\n\t\tthis.smoothNormals = true;\n\n\t\t// The path to load parts from the LDraw parts library from.\n\t\tthis.partsLibraryPath = '';\n\n\t\t// Material assigned to not available colors for meshes and edges\n\t\tthis.missingColorMaterial = new MeshStandardMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF, roughness: 0.3, metalness: 0 } );\n\t\tthis.missingEdgeColorMaterial = new LineBasicMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, color: 0xFF00FF } );\n\t\tthis.missingConditionalEdgeColorMaterial = new LDrawConditionalLineMaterial( { name: Loader.DEFAULT_MATERIAL_NAME, fog: true, color: 0xFF00FF } );\n\t\tthis.edgeMaterialCache.set( this.missingColorMaterial, this.missingEdgeColorMaterial );\n\t\tthis.conditionalEdgeMaterialCache.set( this.missingEdgeColorMaterial, this.missingConditionalEdgeColorMaterial );\n\n\t}\n\n\tsetPartsLibraryPath( path ) {\n\n\t\tthis.partsLibraryPath = path;\n\t\treturn this;\n\n\t}\n\n\tasync preloadMaterials( url ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\n\t\tconst text = await fileLoader.loadAsync( url );\n\t\tconst colorLineRegex = /^0 !COLOUR/;\n\t\tconst lines = text.split( /[\\n\\r]/g );\n\t\tconst materials = [];\n\t\tfor ( let i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tconst line = lines[ i ];\n\t\t\tif ( colorLineRegex.test( line ) ) {\n\n\t\t\t\tconst directive = line.replace( colorLineRegex, '' );\n\t\t\t\tconst material = this.parseColorMetaDirective( new LineParser( directive ) );\n\t\t\t\tmaterials.push( material );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.setMaterials( materials );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path );\n\t\tfileLoader.setRequestHeader( this.requestHeader );\n\t\tfileLoader.setWithCredentials( this.withCredentials );\n\t\tfileLoader.load( url, text => {\n\n\t\t\tthis.partsCache\n\t\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t\t.then( group => {\n\n\t\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\t\tgroup.userData.fileName = url;\n\t\t\t\t\tonLoad( group );\n\n\t\t\t\t} )\n\t\t\t\t.catch( onError );\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, onLoad ) {\n\n\t\tthis.partsCache\n\t\t\t.parseModel( text, this.materialLibrary )\n\t\t\t.then( group => {\n\n\t\t\t\tthis.applyMaterialsToMesh( group, MAIN_COLOUR_CODE, this.materialLibrary, true );\n\t\t\t\tthis.computeBuildingSteps( group );\n\t\t\t\tgroup.userData.fileName = '';\n\t\t\t\tonLoad( group );\n\n\t\t\t} );\n\n\t}\n\n\tsetMaterials( materials ) {\n\n\t\tthis.materialLibrary = {};\n\t\tthis.materials = [];\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\tthis.addMaterial( materials[ i ] );\n\n\t\t}\n\n\t\t// Add default main triangle and line edge materials (used in pieces that can be colored with a main color)\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Main_Colour CODE 16 VALUE #FF8080 EDGE #333333' ) ) );\n\t\tthis.addMaterial( this.parseColorMetaDirective( new LineParser( 'Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333' ) ) );\n\n\t\treturn this;\n\n\t}\n\n\tsetFileMap( fileMap ) {\n\n\t\tthis.fileMap = fileMap;\n\n\t\treturn this;\n\n\t}\n\n\taddMaterial( material ) {\n\n\t\t// Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n\n\t\tconst matLib = this.materialLibrary;\n\t\tif ( ! matLib[ material.userData.code ] ) {\n\n\t\t\tthis.materials.push( material );\n\t\t\tmatLib[ material.userData.code ] = material;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetMaterial( colorCode ) {\n\n\t\tif ( colorCode.startsWith( '0x2' ) ) {\n\n\t\t\t// Special 'direct' material value (RGB color)\n\t\t\tconst color = colorCode.substring( 3 );\n\n\t\t\treturn this.parseColorMetaDirective( new LineParser( 'Direct_Color_' + color + ' CODE -1 VALUE #' + color + ' EDGE #' + color + '' ) );\n\n\t\t}\n\n\t\treturn this.materialLibrary[ colorCode ] || null;\n\n\t}\n\n\t// Applies the appropriate materials to a prebuilt hierarchy of geometry. Assumes that color codes are present\n\t// in the material array if they need to be filled in.\n\tapplyMaterialsToMesh( group, parentColorCode, materialHierarchy, finalMaterialPass = false ) {\n\n\t\t// find any missing materials as indicated by a color code string and replace it with a material from the current material lib\n\t\tconst loader = this;\n\t\tconst parentIsPassthrough = parentColorCode === MAIN_COLOUR_CODE;\n\t\tgroup.traverse( c => {\n\n\t\t\tif ( c.isMesh || c.isLineSegments ) {\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( let i = 0, l = c.material.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tif ( ! c.material[ i ].isMaterial ) {\n\n\t\t\t\t\t\t\tc.material[ i ] = getMaterial( c, c.material[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( ! c.material.isMaterial ) {\n\n\t\t\t\t\tc.material = getMaterial( c, c.material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\n\t\t// Returns the appropriate material for the object (line or face) given color code. If the code is \"pass through\"\n\t\t// (24 for lines, 16 for edges) then the pass through color code is used. If that is also pass through then it's\n\t\t// simply returned for the subsequent material application.\n\t\tfunction getMaterial( c, colorCode ) {\n\n\t\t\t// if our parent is a passthrough color code and we don't have the current material color available then\n\t\t\t// return early.\n\t\t\tif ( parentIsPassthrough && ! ( colorCode in materialHierarchy ) && ! finalMaterialPass ) {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tconst forEdge = c.isLineSegments || c.isConditionalLine;\n\t\t\tconst isPassthrough = ! forEdge && colorCode === MAIN_COLOUR_CODE || forEdge && colorCode === MAIN_EDGE_COLOUR_CODE;\n\t\t\tif ( isPassthrough ) {\n\n\t\t\t\tcolorCode = parentColorCode;\n\n\t\t\t}\n\n\t\t\tlet material = null;\n\t\t\tif ( colorCode in materialHierarchy ) {\n\n\t\t\t\tmaterial = materialHierarchy[ colorCode ];\n\n\t\t\t} else if ( finalMaterialPass ) {\n\n\t\t\t\t// see if we can get the final material from from the \"getMaterial\" function which will attempt to\n\t\t\t\t// parse the \"direct\" colors\n\t\t\t\tmaterial = loader.getMaterial( colorCode );\n\t\t\t\tif ( material === null ) {\n\n\t\t\t\t\t// otherwise throw a warning if this is final opportunity to set the material\n\t\t\t\t\tconsole.warn( `LDrawLoader: Material properties for code ${ colorCode } not available.` );\n\n\t\t\t\t\t// And return the 'missing color' material\n\t\t\t\t\tmaterial = loader.missingColorMaterial;\n\n\t\t\t\t}\n\n\n\t\t\t} else {\n\n\t\t\t\treturn colorCode;\n\n\t\t\t}\n\n\t\t\tif ( c.isLineSegments ) {\n\n\t\t\t\tmaterial = loader.edgeMaterialCache.get( material );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tmaterial = loader.conditionalEdgeMaterialCache.get( material );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t}\n\n\tgetMainMaterial() {\n\n\t\treturn this.getMaterial( MAIN_COLOUR_CODE );\n\n\t}\n\n\tgetMainEdgeMaterial() {\n\n\t\tconst mat = this.getMaterial( MAIN_EDGE_COLOUR_CODE );\n\t\treturn mat ? this.edgeMaterialCache.get( mat ) : null;\n\n\t}\n\n\tparseColorMetaDirective( lineParser ) {\n\n\t\t// Parses a color definition and returns a THREE.Material\n\n\t\tlet code = null;\n\n\t\t// Triangle and line colors\n\t\tlet fillColor = '#FF00FF';\n\t\tlet edgeColor = '#FF00FF';\n\n\t\t// Transparency\n\t\tlet alpha = 1;\n\t\tlet isTransparent = false;\n\t\t// Self-illumination:\n\t\tlet luminance = 0;\n\n\t\tlet finishType = FINISH_TYPE_DEFAULT;\n\n\t\tlet edgeMaterial = null;\n\n\t\tconst name = lineParser.getToken();\n\t\tif ( ! name ) {\n\n\t\t\tthrow new Error( 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + '.' );\n\n\t\t}\n\n\t\t// Parse tag tokens and their parameters\n\t\tlet token = null;\n\t\twhile ( true ) {\n\n\t\t\ttoken = lineParser.getToken();\n\n\t\t\tif ( ! token ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( ! parseLuminance( token ) ) {\n\n\t\t\t\tswitch ( token.toUpperCase() ) {\n\n\t\t\t\t\tcase 'CODE':\n\n\t\t\t\t\t\tcode = lineParser.getToken();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'VALUE':\n\n\t\t\t\t\t\tfillColor = lineParser.getToken();\n\t\t\t\t\t\tif ( fillColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tfillColor = '#' + fillColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! fillColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'EDGE':\n\n\t\t\t\t\t\tedgeColor = lineParser.getToken();\n\t\t\t\t\t\tif ( edgeColor.startsWith( '0x' ) ) {\n\n\t\t\t\t\t\t\tedgeColor = '#' + edgeColor.substring( 2 );\n\n\t\t\t\t\t\t} else if ( ! edgeColor.startsWith( '#' ) ) {\n\n\t\t\t\t\t\t\t// Try to see if edge color is a color code\n\t\t\t\t\t\t\tedgeMaterial = this.getMaterial( edgeColor );\n\t\t\t\t\t\t\tif ( ! edgeMaterial ) {\n\n\t\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid edge color while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get the edge material for this triangle material\n\t\t\t\t\t\t\tedgeMaterial = this.edgeMaterialCache.get( edgeMaterial );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ALPHA':\n\n\t\t\t\t\t\talpha = parseInt( lineParser.getToken() );\n\n\t\t\t\t\t\tif ( isNaN( alpha ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\talpha = Math.max( 0, Math.min( 1, alpha / 255 ) );\n\n\t\t\t\t\t\tif ( alpha < 1 ) {\n\n\t\t\t\t\t\t\tisTransparent = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'LUMINANCE':\n\n\t\t\t\t\t\tif ( ! parseLuminance( lineParser.getToken() ) ) {\n\n\t\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + '.' );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'CHROME':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_CHROME;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'PEARLESCENT':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_PEARLESCENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'RUBBER':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_RUBBER;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATTE_METALLIC':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_MATTE_METALLIC;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'METAL':\n\t\t\t\t\t\tfinishType = FINISH_TYPE_METAL;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'MATERIAL':\n\t\t\t\t\t\t// Not implemented\n\t\t\t\t\t\tlineParser.setToEnd();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error( 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + '.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet material = null;\n\n\t\tswitch ( finishType ) {\n\n\t\t\tcase FINISH_TYPE_DEFAULT:\n\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_PEARLESCENT:\n\n\t\t\t\t// Try to imitate pearlescency by making the surface glossy\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.3, metalness: 0.25 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_CHROME:\n\n\t\t\t\t// Mirror finish surface\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0, metalness: 1 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_RUBBER:\n\n\t\t\t\t// Rubber finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.9, metalness: 0 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_MATTE_METALLIC:\n\n\t\t\t\t// Brushed metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.8, metalness: 0.4 } );\n\t\t\t\tbreak;\n\n\t\t\tcase FINISH_TYPE_METAL:\n\n\t\t\t\t// Average metal finish\n\t\t\t\tmaterial = new MeshStandardMaterial( { roughness: 0.2, metalness: 0.85 } );\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// Should not happen\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tmaterial.color.setStyle( fillColor, COLOR_SPACE_LDRAW );\n\t\tmaterial.transparent = isTransparent;\n\t\tmaterial.premultipliedAlpha = true;\n\t\tmaterial.opacity = alpha;\n\t\tmaterial.depthWrite = ! isTransparent;\n\n\t\tmaterial.polygonOffset = true;\n\t\tmaterial.polygonOffsetFactor = 1;\n\n\t\tif ( luminance !== 0 ) {\n\n\t\t\tmaterial.emissive.setStyle( fillColor, COLOR_SPACE_LDRAW ).multiplyScalar( luminance );\n\n\t\t}\n\n\t\tif ( ! edgeMaterial ) {\n\n\t\t\t// This is the material used for edges\n\t\t\tedgeMaterial = new LineBasicMaterial( {\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\topacity: alpha,\n\t\t\t\tdepthWrite: ! isTransparent\n\t\t\t} );\n\t\t\tedgeMaterial.color;\n\t\t\tedgeMaterial.userData.code = code;\n\t\t\tedgeMaterial.name = name + ' - Edge';\n\n\t\t\t// This is the material used for conditional edges\n\t\t\tconst conditionalEdgeMaterial = new LDrawConditionalLineMaterial( {\n\n\t\t\t\tfog: true,\n\t\t\t\ttransparent: isTransparent,\n\t\t\t\tdepthWrite: ! isTransparent,\n\t\t\t\tcolor: new Color().setStyle( edgeColor, COLOR_SPACE_LDRAW ),\n\t\t\t\topacity: alpha,\n\n\t\t\t} );\n\t\t\tconditionalEdgeMaterial.userData.code = code;\n\t\t\tconditionalEdgeMaterial.name = name + ' - Conditional Edge';\n\n\t\t\tthis.conditionalEdgeMaterialCache.set( edgeMaterial, conditionalEdgeMaterial );\n\n\t\t}\n\n\t\tmaterial.userData.code = code;\n\t\tmaterial.name = name;\n\n\t\tthis.edgeMaterialCache.set( material, edgeMaterial );\n\n\t\tthis.addMaterial( material );\n\n\t\treturn material;\n\n\t\tfunction parseLuminance( token ) {\n\n\t\t\t// Returns success\n\n\t\t\tlet lum;\n\n\t\t\tif ( token.startsWith( 'LUMINANCE' ) ) {\n\n\t\t\t\tlum = parseInt( token.substring( 9 ) );\n\n\t\t\t} else {\n\n\t\t\t\tlum = parseInt( token );\n\n\t\t\t}\n\n\t\t\tif ( isNaN( lum ) ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tluminance = Math.max( 0, Math.min( 1, lum / 255 ) );\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\tcomputeBuildingSteps( model ) {\n\n\t\t// Sets userdata.buildingStep number in Group objects and userData.numBuildingSteps number in the root Group object.\n\n\t\tlet stepNumber = 0;\n\n\t\tmodel.traverse( c => {\n\n\t\t\tif ( c.isGroup ) {\n\n\t\t\t\tif ( c.userData.startingBuildingStep ) {\n\n\t\t\t\t\tstepNumber ++;\n\n\t\t\t\t}\n\n\t\t\t\tc.userData.buildingStep = stepNumber;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tmodel.userData.numBuildingSteps = stepNumber + 1;\n\n\t}\n\n}\n\nexport { LDrawLoader };\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tGroup,\n\tLineSegments,\n\tMatrix3,\n\tMesh\n} from 'three';\n\nimport { mergeGeometries } from './BufferGeometryUtils.js';\n\nclass LDrawUtils {\n\n\tstatic mergeObject( object ) {\n\n\t\t// Merges geometries in object by materials and returns new object. Use on not indexed geometries.\n\t\t// The object buffers reference the old object ones.\n\t\t// Special treatment is done to the conditional lines generated by LDrawLoader.\n\n\t\tfunction extractGroup( geometry, group, elementSize, isConditionalLine ) {\n\n\t\t\t// Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)\n\n\t\t\tconst newGeometry = new BufferGeometry();\n\n\t\t\tconst originalPositions = geometry.getAttribute( 'position' ).array;\n\t\t\tconst originalNormals = elementSize === 3 ? geometry.getAttribute( 'normal' ).array : null;\n\n\t\t\tconst numVertsGroup = Math.min( group.count, Math.floor( originalPositions.length / 3 ) - group.start );\n\t\t\tconst vertStart = group.start * 3;\n\t\t\tconst vertEnd = ( group.start + numVertsGroup ) * 3;\n\n\t\t\tconst positions = originalPositions.subarray( vertStart, vertEnd );\n\t\t\tconst normals = originalNormals !== null ? originalNormals.subarray( vertStart, vertEnd ) : null;\n\n\t\t\tnewGeometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );\n\t\t\tif ( normals !== null ) newGeometry.setAttribute( 'normal', new BufferAttribute( normals, 3 ) );\n\n\t\t\tif ( isConditionalLine ) {\n\n\t\t\t\tconst controlArray0 = geometry.getAttribute( 'control0' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst controlArray1 = geometry.getAttribute( 'control1' ).array.subarray( vertStart, vertEnd );\n\t\t\t\tconst directionArray = geometry.getAttribute( 'direction' ).array.subarray( vertStart, vertEnd );\n\n\t\t\t\tnewGeometry.setAttribute( 'control0', new BufferAttribute( controlArray0, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'control1', new BufferAttribute( controlArray1, 3, false ) );\n\t\t\t\tnewGeometry.setAttribute( 'direction', new BufferAttribute( directionArray, 3, false ) );\n\n\t\t\t}\n\n\t\t\treturn newGeometry;\n\n\t\t}\n\n\t\tfunction addGeometry( mat, geometry, geometries ) {\n\n\t\t\tconst geoms = geometries[ mat.uuid ];\n\t\t\tif ( ! geoms ) {\n\n\t\t\t\tgeometries[ mat.uuid ] = {\n\t\t\t\t\tmat: mat,\n\t\t\t\t\tarr: [ geometry ]\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tgeoms.arr.push( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction permuteAttribute( attribute, elemSize ) {\n\n\t\t\t// Permutes first two vertices of each attribute element\n\n\t\t\tif ( ! attribute ) return;\n\n\t\t\tconst verts = attribute.array;\n\t\t\tconst numVerts = Math.floor( verts.length / 3 );\n\t\t\tlet offset = 0;\n\t\t\tfor ( let i = 0; i < numVerts; i ++ ) {\n\n\t\t\t\tconst x = verts[ offset ];\n\t\t\t\tconst y = verts[ offset + 1 ];\n\t\t\t\tconst z = verts[ offset + 2 ];\n\n\t\t\t\tverts[ offset ] = verts[ offset + 3 ];\n\t\t\t\tverts[ offset + 1 ] = verts[ offset + 4 ];\n\t\t\t\tverts[ offset + 2 ] = verts[ offset + 5 ];\n\n\t\t\t\tverts[ offset + 3 ] = x;\n\t\t\t\tverts[ offset + 4 ] = y;\n\t\t\t\tverts[ offset + 5 ] = z;\n\n\t\t\t\toffset += elemSize * 3;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Traverse the object hierarchy collecting geometries and transforming them to world space\n\n\t\tconst meshGeometries = {};\n\t\tconst linesGeometries = {};\n\t\tconst condLinesGeometries = {};\n\n\t\tobject.updateMatrixWorld( true );\n\t\tconst normalMatrix = new Matrix3();\n\n\t\tobject.traverse( c => {\n\n\t\t\tif ( c.isMesh | c.isLineSegments ) {\n\n\t\t\t\tconst elemSize = c.isMesh ? 3 : 2;\n\n\t\t\t\tconst geometry = c.geometry.clone();\n\t\t\t\tconst matrixIsInverted = c.matrixWorld.determinant() < 0;\n\t\t\t\tif ( matrixIsInverted ) {\n\n\t\t\t\t\tpermuteAttribute( geometry.attributes.position, elemSize );\n\t\t\t\t\tpermuteAttribute( geometry.attributes.normal, elemSize );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.applyMatrix4( c.matrixWorld );\n\n\t\t\t\tif ( c.isConditionalLine ) {\n\n\t\t\t\t\tgeometry.attributes.control0.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.control1.applyMatrix4( c.matrixWorld );\n\t\t\t\t\tnormalMatrix.getNormalMatrix( c.matrixWorld );\n\t\t\t\t\tgeometry.attributes.direction.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\tconst geometries = c.isMesh ? meshGeometries : ( c.isConditionalLine ? condLinesGeometries : linesGeometries );\n\n\t\t\t\tif ( Array.isArray( c.material ) ) {\n\n\t\t\t\t\tfor ( const groupIndex in geometry.groups ) {\n\n\t\t\t\t\t\tconst group = geometry.groups[ groupIndex ];\n\t\t\t\t\t\tconst mat = c.material[ group.materialIndex ];\n\t\t\t\t\t\tconst newGeometry = extractGroup( geometry, group, elemSize, c.isConditionalLine );\n\t\t\t\t\t\taddGeometry( mat, newGeometry, geometries );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddGeometry( c.material, geometry, geometries );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\t// Create object with merged geometries\n\n\t\tconst mergedObject = new Group();\n\n\t\tconst meshMaterialsIds = Object.keys( meshGeometries );\n\t\tfor ( const meshMaterialsId of meshMaterialsIds ) {\n\n\t\t\tconst meshGeometry = meshGeometries[ meshMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( meshGeometry.arr );\n\t\t\tmergedObject.add( new Mesh( mergedGeometry, meshGeometry.mat ) );\n\n\t\t}\n\n\t\tconst linesMaterialsIds = Object.keys( linesGeometries );\n\t\tfor ( const linesMaterialsId of linesMaterialsIds ) {\n\n\t\t\tconst lineGeometry = linesGeometries[ linesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( lineGeometry.arr );\n\t\t\tmergedObject.add( new LineSegments( mergedGeometry, lineGeometry.mat ) );\n\n\t\t}\n\n\t\tconst condLinesMaterialsIds = Object.keys( condLinesGeometries );\n\t\tfor ( const condLinesMaterialsId of condLinesMaterialsIds ) {\n\n\t\t\tconst condLineGeometry = condLinesGeometries[ condLinesMaterialsId ];\n\t\t\tconst mergedGeometry = mergeGeometries( condLineGeometry.arr );\n\t\t\tconst condLines = new LineSegments( mergedGeometry, condLineGeometry.mat );\n\t\t\tcondLines.isConditionalLine = true;\n\t\t\tmergedObject.add( condLines );\n\n\t\t}\n\n\t\tmergedObject.userData.constructionStep = 0;\n\t\tmergedObject.userData.numConstructionSteps = 1;\n\n\t\treturn mergedObject;\n\n\t}\n\n}\n\nexport { LDrawUtils };\n"],"names":[],"version":3,"file":"index.6881a7a6.js.map","sourceRoot":"/__parcel_source_root/"}