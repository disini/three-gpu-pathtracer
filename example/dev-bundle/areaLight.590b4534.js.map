{"mappings":"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","sources":["src/shader/common/index.js","src/shader/common/fresnel_functions.glsl.js","src/shader/common/math_functions.glsl.js","src/shader/common/shape_intersection_functions.glsl.js","src/shader/common/texture_sample_functions.glsl.js","src/shader/common/util_functions.glsl.js","src/shader/bsdf/index.js","src/shader/bsdf/bsdf_functions.glsl.js","src/shader/bsdf/fog_functions.glsl.js","src/shader/bsdf/ggx_functions.glsl.js","src/shader/bsdf/iridescence_functions.glsl.js","src/shader/bsdf/sheen_functions.glsl.js"],"sourcesContent":["export * from './fresnel_functions.glsl.js';\r\nexport * from './math_functions.glsl.js';\r\nexport * from './shape_intersection_functions.glsl.js';\r\nexport * from './texture_sample_functions.glsl.js';\r\nexport * from './util_functions.glsl.js';\r\n","export const fresnel_functions = /* glsl */`\r\n\r\n\tbool totalInternalReflection( float cosTheta, float eta ) {\r\n\r\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\t\treturn eta * sinTheta > 1.0;\r\n\r\n\t}\r\n\r\n\t// https://google.github.io/filament/Filament.md.html#materialsystem/diffusebrdf\r\n\tfloat schlickFresnel( float cosine, float f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tvec3 schlickFresnel( float cosine, vec3 f0 ) {\r\n\r\n\t\treturn f0 + ( 1.0 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tvec3 schlickFresnel( float cosine, vec3 f0, vec3 f90 ) {\r\n\r\n\t\treturn f0 + ( f90 - f0 ) * pow( 1.0 - cosine, 5.0 );\r\n\r\n\t}\r\n\r\n\tfloat dielectricFresnel( float cosThetaI, float eta ) {\r\n\r\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\t\tfloat ni = eta;\r\n\t\tfloat nt = 1.0;\r\n\r\n\t\t// Check for total internal reflection\r\n\t\tfloat sinThetaISq = 1.0f - cosThetaI * cosThetaI;\r\n\t\tfloat sinThetaTSq = eta * eta * sinThetaISq;\r\n\t\tif( sinThetaTSq >= 1.0 ) {\r\n\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tfloat sinThetaT = sqrt( sinThetaTSq );\r\n\r\n\t\tfloat cosThetaT = sqrt( max( 0.0, 1.0f - sinThetaT * sinThetaT ) );\r\n\t\tfloat rParallel = ( ( nt * cosThetaI ) - ( ni * cosThetaT ) ) / ( ( nt * cosThetaI ) + ( ni * cosThetaT ) );\r\n\t\tfloat rPerpendicular = ( ( ni * cosThetaI ) - ( nt * cosThetaT ) ) / ( ( ni * cosThetaI ) + ( nt * cosThetaT ) );\r\n\t\treturn ( rParallel * rParallel + rPerpendicular * rPerpendicular ) / 2.0;\r\n\r\n\t}\r\n\r\n\t// https://raytracing.github.io/books/RayTracingInOneWeekend.html#dielectrics/schlickapproximation\r\n\tfloat iorRatioToF0( float eta ) {\r\n\r\n\t\treturn pow( ( 1.0 - eta ) / ( 1.0 + eta ), 2.0 );\r\n\r\n\t}\r\n\r\n\tvec3 evaluateFresnel( float cosTheta, float eta, vec3 f0, vec3 f90 ) {\r\n\r\n\t\tif ( totalInternalReflection( cosTheta, eta ) ) {\r\n\r\n\t\t\treturn f90;\r\n\r\n\t\t}\r\n\r\n\t\treturn schlickFresnel( cosTheta, f0, f90 );\r\n\r\n\t}\r\n\r\n\t// TODO: disney fresnel was removed and replaced with this fresnel function to better align with\r\n\t// the glTF but is causing blown out pixels. Should be revisited\r\n\t// float evaluateFresnelWeight( float cosTheta, float eta, float f0 ) {\r\n\r\n\t// \tif ( totalInternalReflection( cosTheta, eta ) ) {\r\n\r\n\t// \t\treturn 1.0;\r\n\r\n\t// \t}\r\n\r\n\t// \treturn schlickFresnel( cosTheta, f0 );\r\n\r\n\t// }\r\n\r\n\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\tfloat disneyFresnel( vec3 wo, vec3 wi, vec3 wh, float f0, float eta, float metalness ) {\r\n\r\n\t\tfloat dotHV = dot( wo, wh );\r\n\t\tif ( totalInternalReflection( dotHV, eta ) ) {\r\n\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tfloat dotHL = dot( wi, wh );\r\n\t\tfloat dielectricFresnel = dielectricFresnel( abs( dotHV ), eta );\r\n\t\tfloat metallicFresnel = schlickFresnel( dotHL, f0 );\r\n\r\n\t\treturn mix( dielectricFresnel, metallicFresnel, metalness );\r\n\r\n\t}\r\n\r\n`;\r\n","export const math_functions = /* glsl */`\r\n\r\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\r\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\r\n\t// For more information see: https://github.com/disini/three-gpu-pathtracer/pull/171#issuecomment-1152275248\r\n\tfloat acosApprox( float x ) {\r\n\r\n\t\tx = clamp( x, -1.0, 1.0 );\r\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\r\n\r\n\t}\r\n\r\n\t// An acos with input values bound to the range [-1, 1].\r\n\tfloat acosSafe( float x ) {\r\n\r\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\r\n\r\n\t}\r\n\r\n\tfloat saturateCos( float val ) {\r\n\r\n\t\treturn clamp( val, 0.001, 1.0 );\r\n\r\n\t}\r\n\r\n\tfloat square( float t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 square( vec2 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec3 square( vec3 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec4 square( vec4 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 rotateVector( vec2 v, float t ) {\r\n\r\n\t\tfloat ac = cos( t );\r\n\t\tfloat as = sin( t );\r\n\t\treturn vec2(\r\n\t\t\tv.x * ac - v.y * as,\r\n\t\t\tv.x * as + v.y * ac\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t// forms a basis with the normal vector as Z\r\n\tmat3 getBasisFromNormal( vec3 normal ) {\r\n\r\n\t\tvec3 other;\r\n\t\tif ( abs( normal.x ) > 0.5 ) {\r\n\r\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 ortho = normalize( cross( normal, other ) );\r\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\r\n\t\treturn mat3( ortho2, ortho, normal );\r\n\r\n\t}\r\n\r\n`;\r\n","export const shape_intersection_functions = /* glsl */`\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the rectangle on that same plane.\r\n\t// Plane intersection: https://lousodrome.net/blog/light/2020/07/03/intersection-of-a-ray-and-a-plane/\r\n\tbool intersectsRectangle( vec3 center, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\r\n\r\n\t\tfloat t = dot( center - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = p - center;\r\n\r\n\t\t\t// check if p falls inside the rectangle\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tif ( abs( a1 ) <= 0.5 ) {\r\n\r\n\t\t\t\tfloat a2 = dot( v, vi );\r\n\t\t\t\tif ( abs( a2 ) <= 0.5 ) {\r\n\r\n\t\t\t\t\tdist = t;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\t// Finds the point where the ray intersects the plane defined by u and v and checks if this point\r\n\t// falls in the bounds of the circle on that same plane. See above URL for a description of the plane intersection algorithm.\r\n\tbool intersectsCircle( vec3 position, vec3 normal, vec3 u, vec3 v, vec3 rayOrigin, vec3 rayDirection, inout float dist ) {\r\n\r\n\t\tfloat t = dot( position - rayOrigin, normal ) / dot( rayDirection, normal );\r\n\r\n\t\tif ( t > EPSILON ) {\r\n\r\n\t\t\tvec3 hit = rayOrigin + rayDirection * t;\r\n\t\t\tvec3 vi = hit - position;\r\n\r\n\t\t\tfloat a1 = dot( u, vi );\r\n\t\t\tfloat a2 = dot( v, vi );\r\n\r\n\t\t\tif( length( vec2( a1, a2 ) ) <= 0.5 ) {\r\n\r\n\t\t\t\tdist = t;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n`;\r\n","\r\nexport const texture_sample_functions = /*glsl */`\r\n\r\n\t// add texel fetch functions for texture arrays\r\n\tvec4 texelFetch1D( sampler2DArray tex, int layer, uint index ) {\r\n\r\n\t\tuint width = uint( textureSize( tex, 0 ).x );\r\n\t\tuvec2 uv;\r\n\t\tuv.x = index % width;\r\n\t\tuv.y = index / width;\r\n\r\n\t\treturn texelFetch( tex, ivec3( uv, layer ), 0 );\r\n\r\n\t}\r\n\r\n\tvec4 textureSampleBarycoord( sampler2DArray tex, int layer, vec3 barycoord, uvec3 faceIndices ) {\r\n\r\n\t\treturn\r\n\t\t\tbarycoord.x * texelFetch1D( tex, layer, faceIndices.x ) +\r\n\t\t\tbarycoord.y * texelFetch1D( tex, layer, faceIndices.y ) +\r\n\t\t\tbarycoord.z * texelFetch1D( tex, layer, faceIndices.z );\r\n\r\n\t}\r\n\r\n`;\r\n","export const util_functions = /* glsl */`\r\n\r\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\r\n\r\n\t#ifndef RAY_OFFSET\r\n\t#define RAY_OFFSET 1e-4\r\n\t#endif\r\n\r\n\t// adjust the hit point by the surface normal by a factor of some offset and the\r\n\t// maximum component-wise value of the current point to accommodate floating point\r\n\t// error as values increase.\r\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\r\n\r\n\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\tvec3 absPoint = abs( point );\r\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\r\n\r\n\t}\r\n\r\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\r\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\r\n\r\n\t\tvec3 ot = - log( attColor ) / attDist;\r\n\t\treturn exp( - ot * dist );\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\r\n\r\n\t\t// get the half vector - assuming if the light incident vector is on the other side\r\n\t\t// of the that it's transmissive.\r\n\t\tvec3 h;\r\n\t\tif ( wi.z > 0.0 ) {\r\n\r\n\t\t\th = normalize( wi + wo );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\r\n\t\t\t// From Section 2.2 on computing the transmission half vector:\r\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\r\n\t\t\th = normalize( wi + wo * eta );\r\n\r\n\t\t}\r\n\r\n\t\th *= sign( h.z );\r\n\t\treturn h;\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\r\n\r\n\t\treturn normalize( a + b );\r\n\r\n\t}\r\n\r\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\r\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\r\n\t// we find a ray like that we ignore it to avoid artifacts.\r\n\t// This function returns if the direction is on the same side of both planes.\r\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\r\n\r\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\r\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\r\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\r\n\r\n\t}\r\n\r\n\t// ray sampling x and z are swapped to align with expected background view\r\n\tvec2 equirectDirectionToUv( vec3 direction ) {\r\n\r\n\t\t// from Spherical.setFromCartesianCoords\r\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\r\n\t\tuv /= vec2( 2.0 * PI, PI );\r\n\r\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\r\n\t\tuv.x += 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tvec3 equirectUvToDirection( vec2 uv ) {\r\n\r\n\t\t// undo above adjustments\r\n\t\tuv.x -= 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\r\n\t\t// from Vector3.setFromSphericalCoords\r\n\t\tfloat theta = uv.x * 2.0 * PI;\r\n\t\tfloat phi = uv.y * PI;\r\n\r\n\t\tfloat sinPhi = sin( phi );\r\n\r\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\r\n\r\n\t}\r\n\r\n\t// power heuristic for multiple importance sampling\r\n\tfloat misHeuristic( float a, float b ) {\r\n\r\n\t\tfloat aa = a * a;\r\n\t\tfloat bb = b * b;\r\n\t\treturn aa / ( aa + bb );\r\n\r\n\t}\r\n\r\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\r\n\t// erichlof/THREE.js-PathTracing-Renderer/\r\n\tfloat tentFilter( float x ) {\r\n\r\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\r\n\r\n\t}\r\n`;\r\n","export * from './bsdf_functions.glsl.js';\r\nexport * from './fog_functions.glsl.js';\r\nexport * from './ggx_functions.glsl.js';\r\nexport * from './iridescence_functions.glsl.js';\r\nexport * from './sheen_functions.glsl.js';\r\n","/*\r\nwi     : incident vector or light vector (pointing toward the light)\r\nwo     : outgoing vector or view vector (pointing towards the camera)\r\nwh     : computed half vector from wo and wi\r\nEval   : Get the color and pdf for a direction\r\nSample : Get the direction, color, and pdf for a sample\r\neta    : Greek character used to denote the \"ratio of ior\"\r\nf0     : Amount of light reflected when looking at a surface head on - \"fresnel 0\"\r\nf90    : Amount of light reflected at grazing angles\r\n*/\r\n\r\nexport const bsdf_functions = /* glsl */`\r\n\r\n\t// diffuse\r\n\tfloat diffuseEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// https://schuttejoe.github.io/post/disneybsdf/\r\n\t\tfloat fl = schlickFresnel( wi.z, 0.0 );\r\n\t\tfloat fv = schlickFresnel( wo.z, 0.0 );\r\n\r\n\t\tfloat metalFactor = ( 1.0 - surf.metalness );\r\n\t\tfloat transFactor = ( 1.0 - surf.transmission );\r\n\t\tfloat rr = 0.5 + 2.0 * surf.roughness * fl * fl;\r\n\t\tfloat retro = rr * ( fl + fv + fl * fv * ( rr - 1.0f ) );\r\n\t\tfloat lambert = ( 1.0f - 0.5f * fl ) * ( 1.0f - 0.5f * fv );\r\n\r\n\t\t// TODO: subsurface approx?\r\n\r\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\tfloat F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\t\tcolor = ( 1.0 - F ) * transFactor * metalFactor * wi.z * surf.color * ( retro + lambert ) / PI;\r\n\r\n\t\treturn wi.z / PI;\r\n\r\n\t}\r\n\r\n\tvec3 diffuseDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tvec3 lightDirection = sampleSphere( rand2( 11 ) );\r\n\t\tlightDirection.z += 1.0;\r\n\t\tlightDirection = normalize( lightDirection );\r\n\r\n\t\treturn lightDirection;\r\n\r\n\t}\r\n\r\n\t// specular\r\n\tfloat specularEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// if roughness is set to 0 then D === NaN which results in black pixels\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\r\n\t\tfloat eta = surf.eta;\r\n\t\tfloat f0 = surf.f0;\r\n\r\n\t\tvec3 f0Color = mix( f0 * surf.specularColor * surf.specularIntensity, surf.color, surf.metalness );\r\n\t\tvec3 f90Color = vec3( mix( surf.specularIntensity, 1.0, surf.metalness ) );\r\n\t\tvec3 F = evaluateFresnel( dot( wo, wh ), eta, f0Color, f90Color );\r\n\r\n\t\tvec3 iridescenceF = evalIridescence( 1.0, surf.iridescenceIor, dot( wi, wh ), surf.iridescenceThickness, f0Color );\r\n\t\tF = mix( F, iridescenceF,  surf.iridescence );\r\n\r\n\t\t// PDF\r\n\t\t// See 14.1.1 Microfacet BxDFs in https://www.pbr-book.org/\r\n\t\tfloat incidentTheta = acos( wo.z );\r\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\r\n\t\tfloat D = ggxDistribution( wh, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\t\tfloat ggxPdf = D * G1 * max( 0.0, abs( dot( wo, wh ) ) ) / abs ( wo.z );\r\n\r\n\t\tcolor = wi.z * F * G * D / ( 4.0 * abs( wi.z * wo.z ) );\r\n\t\treturn ggxPdf / ( 4.0 * dot( wo, wh ) );\r\n\r\n\t}\r\n\r\n\tvec3 specularDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( roughness ),\r\n\t\t\trand2( 12 )\r\n\t\t);\r\n\r\n\t\t// apply to new ray by reflecting off the new normal\r\n\t\treturn - reflect( wo, halfVector );\r\n\r\n\t}\r\n\r\n\r\n\t// transmission\r\n\t/*\r\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\t// See section 4.2 in https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\r\n\t\tfloat filteredRoughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tbool frontFace = surf.frontFace;\r\n\t\tbool thinFilm = surf.thinFilm;\r\n\r\n\t\tcolor = surf.transmission * surf.color;\r\n\r\n\t\tfloat denom = pow( eta * dot( wi, wh ) + dot( wo, wh ), 2.0 );\r\n\t\treturn ggxPDF( wo, wh, filteredRoughness ) / denom;\r\n\r\n\t}\r\n\r\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat filteredRoughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tbool frontFace = surf.frontFace;\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( filteredRoughness ),\r\n\t\t\trand2( 13 )\r\n\t\t);\r\n\r\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\r\n\t\tif ( surf.thinFilm ) {\r\n\r\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\r\n\r\n\t\t}\r\n\r\n\t\treturn normalize( lightDirection );\r\n\r\n\t}\r\n\t*/\r\n\r\n\t// TODO: This is just using a basic cosine-weighted specular distribution with an\r\n\t// incorrect PDF value at the moment. Update it to correctly use a GGX distribution\r\n\tfloat transmissionEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tcolor = surf.transmission * surf.color;\r\n\r\n\t\t// PDF\r\n\t\t// float F = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\t// float F = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\t\t// if ( F >= 1.0 ) {\r\n\r\n\t\t// \treturn 0.0;\r\n\r\n\t\t// }\r\n\r\n\t\t// return 1.0 / ( 1.0 - F );\r\n\r\n\t\t// reverted to previous to transmission. The above was causing black pixels\r\n\t\tfloat eta = surf.eta;\r\n\t\tfloat f0 = surf.f0;\r\n\t\tfloat cosTheta = min( wo.z, 1.0 );\r\n\t\tfloat sinTheta = sqrt( 1.0 - cosTheta * cosTheta );\r\n\t\tfloat reflectance = schlickFresnel( cosTheta, f0 );\r\n\t\tbool cannotRefract = eta * sinTheta > 1.0;\r\n\t\tif ( cannotRefract ) {\r\n\r\n\t\t\treturn 0.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0 / ( 1.0 - reflectance );\r\n\r\n\t}\r\n\r\n\tvec3 transmissionDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat roughness = surf.filteredRoughness;\r\n\t\tfloat eta = surf.eta;\r\n\t\tvec3 halfVector = normalize( vec3( 0.0, 0.0, 1.0 ) + sampleSphere( rand2( 13 ) ) * roughness );\r\n\t\tvec3 lightDirection = refract( normalize( - wo ), halfVector, eta );\r\n\r\n\t\tif ( surf.thinFilm ) {\r\n\r\n\t\t\tlightDirection = - refract( normalize( - lightDirection ), - vec3( 0.0, 0.0, 1.0 ), 1.0 / eta );\r\n\r\n\t\t}\r\n\t\treturn normalize( lightDirection );\r\n\r\n\t}\r\n\r\n\t// clearcoat\r\n\tfloat clearcoatEval( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tfloat ior = 1.5;\r\n\t\tfloat f0 = iorRatioToF0( ior );\r\n\t\tbool frontFace = surf.frontFace;\r\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\r\n\r\n\t\tfloat eta = frontFace ? 1.0 / ior : ior;\r\n\t\tfloat G = ggxShadowMaskG2( wi, wo, roughness );\r\n\t\tfloat D = ggxDistribution( wh, roughness );\r\n\t\tfloat F = schlickFresnel( dot( wi, wh ), f0 );\r\n\r\n\t\tfloat fClearcoat = F * D * G / ( 4.0 * abs( wi.z * wo.z ) );\r\n\t\tcolor = color * ( 1.0 - surf.clearcoat * F ) + fClearcoat * surf.clearcoat * wi.z;\r\n\r\n\t\t// PDF\r\n\t\t// See equation (27) in http://jcgt.org/published/0003/02/03/\r\n\t\treturn ggxPDF( wo, wh, roughness ) / ( 4.0 * dot( wi, wh ) );\r\n\r\n\t}\r\n\r\n\tvec3 clearcoatDirection( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\t// sample ggx vndf distribution which gives a new normal\r\n\t\tfloat roughness = surf.filteredClearcoatRoughness;\r\n\t\tvec3 halfVector = ggxDirection(\r\n\t\t\two,\r\n\t\t\tvec2( roughness ),\r\n\t\t\trand2( 14 )\r\n\t\t);\r\n\r\n\t\t// apply to new ray by reflecting off the new normal\r\n\t\treturn - reflect( wo, halfVector );\r\n\r\n\t}\r\n\r\n\t// sheen\r\n\tvec3 sheenColor( vec3 wo, vec3 wi, vec3 wh, SurfaceRecord surf ) {\r\n\r\n\t\tfloat cosThetaO = saturateCos( wo.z );\r\n\t\tfloat cosThetaI = saturateCos( wi.z );\r\n\t\tfloat cosThetaH = wh.z;\r\n\r\n\t\tfloat D = velvetD( cosThetaH, surf.sheenRoughness );\r\n\t\tfloat G = velvetG( cosThetaO, cosThetaI, surf.sheenRoughness );\r\n\r\n\t\t// See equation (1) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\t\tvec3 color = surf.sheenColor;\r\n\t\tcolor *= D * G / ( 4.0 * abs( cosThetaO * cosThetaI ) );\r\n\t\tcolor *= wi.z;\r\n\r\n\t\treturn color;\r\n\r\n\t}\r\n\r\n\t// bsdf\r\n\tvoid getLobeWeights(\r\n\t\tvec3 wo, vec3 wi, vec3 wh, vec3 clearcoatWo, SurfaceRecord surf,\r\n\t\tinout float diffuseWeight, inout float specularWeight, inout float transmissionWeight, inout float clearcoatWeight\r\n\t) {\r\n\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat transmission = surf.transmission;\r\n\t\t// float fEstimate = evaluateFresnelWeight( dot( wo, wh ), surf.eta, surf.f0 );\r\n\t\tfloat fEstimate = disneyFresnel( wo, wi, wh, surf.f0, surf.eta, surf.metalness );\r\n\r\n\t\tfloat transSpecularProb = mix( max( 0.25, fEstimate ), 1.0, metalness );\r\n\t\tfloat diffSpecularProb = 0.5 + 0.5 * metalness;\r\n\r\n\t\tdiffuseWeight = ( 1.0 - transmission ) * ( 1.0 - diffSpecularProb );\r\n\t\tspecularWeight = transmission * transSpecularProb + ( 1.0 - transmission ) * diffSpecularProb;\r\n\t\ttransmissionWeight = transmission * ( 1.0 - transSpecularProb );\r\n\t\tclearcoatWeight = surf.clearcoat * schlickFresnel( clearcoatWo.z, 0.04 );\r\n\r\n\t\tfloat totalWeight = diffuseWeight + specularWeight + transmissionWeight + clearcoatWeight;\r\n\t\tdiffuseWeight /= totalWeight;\r\n\t\tspecularWeight /= totalWeight;\r\n\t\ttransmissionWeight /= totalWeight;\r\n\t\tclearcoatWeight /= totalWeight;\r\n\t}\r\n\r\n\tfloat bsdfEval(\r\n\t\tvec3 wo, vec3 clearcoatWo, vec3 wi, vec3 clearcoatWi, SurfaceRecord surf,\r\n\t\tfloat diffuseWeight, float specularWeight, float transmissionWeight, float clearcoatWeight, inout float specularPdf, inout vec3 color\r\n\t) {\r\n\r\n\t\tfloat metalness = surf.metalness;\r\n\t\tfloat transmission = surf.transmission;\r\n\r\n\t\tfloat spdf = 0.0;\r\n\t\tfloat dpdf = 0.0;\r\n\t\tfloat tpdf = 0.0;\r\n\t\tfloat cpdf = 0.0;\r\n\t\tcolor = vec3( 0.0 );\r\n\r\n\t\tvec3 halfVector = getHalfVector( wi, wo, surf.eta );\r\n\r\n\t\t// diffuse\r\n\t\tif ( diffuseWeight > 0.0 && wi.z > 0.0 ) {\r\n\r\n\t\t\tdpdf = diffuseEval( wo, wi, halfVector, surf, color );\r\n\t\t\tcolor *= 1.0 - surf.transmission;\r\n\r\n\t\t}\r\n\r\n\t\t// ggx specular\r\n\t\tif ( specularWeight > 0.0 && wi.z > 0.0 ) {\r\n\r\n\t\t\tvec3 outColor;\r\n\t\t\tspdf = specularEval( wo, wi, getHalfVector( wi, wo ), surf, outColor );\r\n\t\t\tcolor += outColor;\r\n\r\n\t\t}\r\n\r\n\t\t// transmission\r\n\t\tif ( transmissionWeight > 0.0 && wi.z < 0.0 ) {\r\n\r\n\t\t\ttpdf = transmissionEval( wo, wi, halfVector, surf, color );\r\n\r\n\t\t}\r\n\r\n\t\t// sheen\r\n\t\tcolor *= mix( 1.0, sheenAlbedoScaling( wo, wi, surf ), surf.sheen );\r\n\t\tcolor += sheenColor( wo, wi, halfVector, surf ) * surf.sheen;\r\n\r\n\t\t// clearcoat\r\n\t\tif ( clearcoatWi.z >= 0.0 && clearcoatWeight > 0.0 ) {\r\n\r\n\t\t\tvec3 clearcoatHalfVector = getHalfVector( clearcoatWo, clearcoatWi );\r\n\t\t\tcpdf = clearcoatEval( clearcoatWo, clearcoatWi, clearcoatHalfVector, surf, color );\r\n\r\n\t\t}\r\n\r\n\t\tfloat pdf =\r\n\t\t\tdpdf * diffuseWeight\r\n\t\t\t+ spdf * specularWeight\r\n\t\t\t+ tpdf * transmissionWeight\r\n\t\t\t+ cpdf * clearcoatWeight;\r\n\r\n\t\t// retrieve specular rays for the shadows flag\r\n\t\tspecularPdf = spdf * specularWeight + cpdf * clearcoatWeight;\r\n\r\n\t\treturn pdf;\r\n\r\n\t}\r\n\r\n\tfloat bsdfResult( vec3 worldWo, vec3 worldWi, SurfaceRecord surf, inout vec3 color ) {\r\n\r\n\t\tif ( surf.volumeParticle ) {\r\n\r\n\t\t\tcolor = surf.color / ( 4.0 * PI );\r\n\t\t\treturn 1.0 / ( 4.0 * PI );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\r\n\t\tvec3 wi = normalize( surf.normalInvBasis * worldWi );\r\n\r\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\r\n\t\tvec3 clearcoatWi = normalize( surf.clearcoatInvBasis * worldWi );\r\n\r\n\t\tvec3 wh = getHalfVector( wo, wi, surf.eta );\r\n\t\tfloat diffuseWeight;\r\n\t\tfloat specularWeight;\r\n\t\tfloat transmissionWeight;\r\n\t\tfloat clearcoatWeight;\r\n\t\tgetLobeWeights( wo, wi, wh, clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\r\n\r\n\t\tfloat specularPdf;\r\n\t\treturn bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, specularPdf, color );\r\n\r\n\t}\r\n\r\n\tScatterRecord bsdfSample( vec3 worldWo, SurfaceRecord surf ) {\r\n\r\n\t\tif ( surf.volumeParticle ) {\r\n\r\n\t\t\tScatterRecord sampleRec;\r\n\t\t\tsampleRec.specularPdf = 0.0;\r\n\t\t\tsampleRec.pdf = 1.0 / ( 4.0 * PI );\r\n\t\t\tsampleRec.direction = sampleSphere( rand2( 16 ) );\r\n\t\t\tsampleRec.color = surf.color / ( 4.0 * PI );\r\n\t\t\treturn sampleRec;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wo = normalize( surf.normalInvBasis * worldWo );\r\n\t\tvec3 clearcoatWo = normalize( surf.clearcoatInvBasis * worldWo );\r\n\t\tmat3 normalBasis = surf.normalBasis;\r\n\t\tmat3 invBasis = surf.normalInvBasis;\r\n\t\tmat3 clearcoatNormalBasis = surf.clearcoatBasis;\r\n\t\tmat3 clearcoatInvBasis = surf.clearcoatInvBasis;\r\n\r\n\t\tfloat diffuseWeight;\r\n\t\tfloat specularWeight;\r\n\t\tfloat transmissionWeight;\r\n\t\tfloat clearcoatWeight;\r\n\t\t// using normal and basically-reflected ray since we don't have proper half vector here\r\n\t\tgetLobeWeights( wo, wo, vec3( 0, 0, 1 ), clearcoatWo, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight );\r\n\r\n\t\tfloat pdf[4];\r\n\t\tpdf[0] = diffuseWeight;\r\n\t\tpdf[1] = specularWeight;\r\n\t\tpdf[2] = transmissionWeight;\r\n\t\tpdf[3] = clearcoatWeight;\r\n\r\n\t\tfloat cdf[4];\r\n\t\tcdf[0] = pdf[0];\r\n\t\tcdf[1] = pdf[1] + cdf[0];\r\n\t\tcdf[2] = pdf[2] + cdf[1];\r\n\t\tcdf[3] = pdf[3] + cdf[2];\r\n\r\n\t\tif( cdf[3] != 0.0 ) {\r\n\r\n\t\t\tfloat invMaxCdf = 1.0 / cdf[3];\r\n\t\t\tcdf[0] *= invMaxCdf;\r\n\t\t\tcdf[1] *= invMaxCdf;\r\n\t\t\tcdf[2] *= invMaxCdf;\r\n\t\t\tcdf[3] *= invMaxCdf;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcdf[0] = 1.0;\r\n\t\t\tcdf[1] = 0.0;\r\n\t\t\tcdf[2] = 0.0;\r\n\t\t\tcdf[3] = 0.0;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 wi;\r\n\t\tvec3 clearcoatWi;\r\n\r\n\t\tfloat r = rand( 15 );\r\n\t\tif ( r <= cdf[0] ) { // diffuse\r\n\r\n\t\t\twi = diffuseDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[1] ) { // specular\r\n\r\n\t\t\twi = specularDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[2] ) { // transmission / refraction\r\n\r\n\t\t\twi = transmissionDirection( wo, surf );\r\n\t\t\tclearcoatWi = normalize( clearcoatInvBasis * normalize( normalBasis * wi ) );\r\n\r\n\t\t} else if ( r <= cdf[3] ) { // clearcoat\r\n\r\n\t\t\tclearcoatWi = clearcoatDirection( clearcoatWo, surf );\r\n\t\t\twi = normalize( invBasis * normalize( clearcoatNormalBasis * clearcoatWi ) );\r\n\r\n\t\t}\r\n\r\n\t\tScatterRecord result;\r\n\t\tresult.pdf = bsdfEval( wo, clearcoatWo, wi, clearcoatWi, surf, diffuseWeight, specularWeight, transmissionWeight, clearcoatWeight, result.specularPdf, result.color );\r\n\t\tresult.direction = normalize( surf.normalBasis * wi );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const fog_functions = /* glsl */`\r\n\r\n\t// returns the hit distance given the material density\r\n\tfloat intersectFogVolume( Material material, float u ) {\r\n\r\n\t\t// https://raytracing.github.io/books/RayTracingTheNextWeek.html#volumes/constantdensitymediums\r\n\t\treturn material.opacity == 0.0 ? INFINITY : ( - 1.0 / material.opacity ) * log( u );\r\n\r\n\t}\r\n\r\n\tScatterRecord sampleFogVolume( SurfaceRecord surf, vec2 uv ) {\r\n\r\n\t\tScatterRecord sampleRec;\r\n\t\tsampleRec.specularPdf = 0.0;\r\n\t\tsampleRec.pdf = 1.0 / ( 2.0 * PI );\r\n\t\tsampleRec.direction = sampleSphere( uv );\r\n\t\tsampleRec.color = surf.color;\r\n\t\treturn sampleRec;\r\n\r\n\t}\r\n\r\n`;\r\n","export const ggx_functions = /* glsl */`\r\n\r\n\t// The GGX functions provide sampling and distribution information for normals as output so\r\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\r\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\r\n\t// [2] http://jcgt.org/published/0007/04/01/\r\n\t// [4] http://jcgt.org/published/0003/02/03/\r\n\r\n\t// trowbridge-reitz === GGX === GTR\r\n\r\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\r\n\r\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\r\n\t\t// function below, as well\r\n\r\n\t\t// Implementation from reference [1]\r\n\t\t// stretch view\r\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\r\n\r\n\t\t// orthonormal basis\r\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\r\n\t\tvec3 T2 = cross( T1, V );\r\n\r\n\t\t// sample point with polar coordinates (r, phi)\r\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\r\n\t\tfloat P1 = r * cos( phi );\r\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\r\n\r\n\t\t// compute normal\r\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\r\n\r\n\t\t// unstretch\r\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\r\n\r\n\t\treturn N;\r\n\r\n\t}\r\n\r\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\r\n\t// as specified in Appendix B of the following paper\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxLamda( float theta, float roughness ) {\r\n\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\r\n\t\tfloat alpha2 = roughness * roughness;\r\n\r\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\r\n\t\treturn numerator / 2.0;\r\n\r\n\t}\r\n\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\r\n\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (125) from reference [4]\r\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat scatterTheta = acos( wo.z );\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (33) from reference [0]\r\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat a2 = roughness * roughness;\r\n\t\ta2 = max( EPSILON, a2 );\r\n\t\tfloat cosTheta = halfVector.z;\r\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\r\n\r\n\t\tif ( cosTheta == 0.0 ) return 0.0;\r\n\r\n\t\tfloat theta = acosSafe( halfVector.z );\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\r\n\r\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\r\n\t\treturn ( a2 / denom );\r\n\r\n\t}\r\n\r\n\t// See equation (3) from reference [2]\r\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat D = ggxDistribution( halfVector, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\r\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\r\n\r\n\t}\r\n\r\n`;\r\n","export const iridescence_functions = /* glsl */`\r\n\r\n\t// XYZ to sRGB color space\r\n\tconst mat3 XYZ_TO_REC709 = mat3(\r\n\t\t3.2404542, -0.9692660,  0.0556434,\r\n\t\t-1.5371385,  1.8760108, -0.2040259,\r\n\t\t-0.4985314,  0.0415560,  1.0572252\r\n\t);\r\n\r\n\tvec3 fresnel0ToIor( vec3 fresnel0 ) {\r\n\r\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\r\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\r\n\r\n\t}\r\n\r\n\t// Conversion FO/IOR\r\n\tvec3 iorToFresnel0( vec3 transmittedIor, float incidentIor ) {\r\n\r\n\t\treturn square( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\r\n\r\n\t}\r\n\r\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\r\n\tfloat iorToFresnel0( float transmittedIor, float incidentIor ) {\r\n\r\n\t\treturn square( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ) );\r\n\r\n\t}\r\n\r\n\t// Fresnel equations for dielectric/dielectric interfaces. See https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\r\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\r\n\r\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\r\n\r\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\r\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\r\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\r\n\r\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - square( phase ) * var );\r\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * square( phase ) );\r\n\t\txyz /= 1.0685e-7;\r\n\r\n\t\tvec3 srgb = XYZ_TO_REC709 * xyz;\r\n\t\treturn srgb;\r\n\r\n\t}\r\n\r\n\t// See Section 4. Analytic Spectral Integration, A Practical Extension to Microfacet Theory for the Modeling of Varying Iridescence, https://hal.archives-ouvertes.fr/hal-01518344/document\r\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\r\n\r\n\t\tvec3 I;\r\n\r\n\t\t// Force iridescenceIor -> outsideIOR when thinFilmThickness -> 0.0\r\n\t\tfloat iridescenceIor = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\r\n\r\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\r\n\t\tfloat sinTheta2Sq = square( outsideIOR / iridescenceIor ) * ( 1.0 - square( cosTheta1 ) );\r\n\r\n\t\t// Handle TIR:\r\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\r\n\t\tif ( cosTheta2Sq < 0.0 ) {\r\n\r\n\t\t\treturn vec3( 1.0 );\r\n\r\n\t\t}\r\n\r\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\r\n\r\n\t\t// First interface\r\n\t\tfloat R0 = iorToFresnel0( iridescenceIor, outsideIOR );\r\n\t\tfloat R12 = schlickFresnel( cosTheta1, R0 );\r\n\t\tfloat R21 = R12;\r\n\t\tfloat T121 = 1.0 - R12;\r\n\t\tfloat phi12 = 0.0;\r\n\t\tif ( iridescenceIor < outsideIOR ) {\r\n\r\n\t\t\tphi12 = PI;\r\n\r\n\t\t}\r\n\r\n\t\tfloat phi21 = PI - phi12;\r\n\r\n\t\t// Second interface\r\n\t\tvec3 baseIOR = fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\r\n\t\tvec3 R1 = iorToFresnel0( baseIOR, iridescenceIor );\r\n\t\tvec3 R23 = schlickFresnel( cosTheta2, R1 );\r\n\t\tvec3 phi23 = vec3( 0.0 );\r\n\t\tif ( baseIOR[0] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 0 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\tif ( baseIOR[1] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 1 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\tif ( baseIOR[2] < iridescenceIor ) {\r\n\r\n\t\t\tphi23[ 2 ] = PI;\r\n\r\n\t\t}\r\n\r\n\t\t// Phase shift\r\n\t\tfloat OPD = 2.0 * iridescenceIor * thinFilmThickness * cosTheta2;\r\n\t\tvec3 phi = vec3( phi21 ) + phi23;\r\n\r\n\t\t// Compound terms\r\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\r\n\t\tvec3 r123 = sqrt( R123 );\r\n\t\tvec3 Rs = square( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\r\n\r\n\t\t// Reflectance term for m = 0 (DC term amplitude)\r\n\t\tvec3 C0 = R12 + Rs;\r\n\t\tI = C0;\r\n\r\n\t\t// Reflectance term for m > 0 (pairs of diracs)\r\n\t\tvec3 Cm = Rs - T121;\r\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\r\n\r\n\t\t\tCm *= r123;\r\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\r\n\t\t\tI += Cm * Sm;\r\n\r\n\t\t}\r\n\r\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\r\n\t\treturn max( I, vec3( 0.0 ) );\r\n\r\n\t}\r\n\r\n`;\r\n","export const sheen_functions = /* glsl */`\r\n\r\n\t// See equation (2) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetD( float cosThetaH, float roughness ) {\r\n\r\n\t\tfloat alpha = max( roughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat invAlpha = 1.0 / alpha;\r\n\r\n\t\tfloat sqrCosThetaH = cosThetaH * cosThetaH;\r\n\t\tfloat sinThetaH = max( 1.0 - sqrCosThetaH, 0.001 );\r\n\r\n\t\treturn ( 2.0 + invAlpha ) * pow( sinThetaH, 0.5 * invAlpha ) / ( 2.0 * PI );\r\n\r\n\t}\r\n\r\n\tfloat velvetParamsInterpolate( int i, float oneMinusAlphaSquared ) {\r\n\r\n\t\tconst float p0[5] = float[5]( 25.3245, 3.32435, 0.16801, -1.27393, -4.85967 );\r\n\t\tconst float p1[5] = float[5]( 21.5473, 3.82987, 0.19823, -1.97760, -4.32054 );\r\n\r\n\t\treturn mix( p1[i], p0[i], oneMinusAlphaSquared );\r\n\r\n\t}\r\n\r\n\tfloat velvetL( float x, float alpha ) {\r\n\r\n\t\tfloat oneMinusAlpha = 1.0 - alpha;\r\n\t\tfloat oneMinusAlphaSquared = oneMinusAlpha * oneMinusAlpha;\r\n\r\n\t\tfloat a = velvetParamsInterpolate( 0, oneMinusAlphaSquared );\r\n\t\tfloat b = velvetParamsInterpolate( 1, oneMinusAlphaSquared );\r\n\t\tfloat c = velvetParamsInterpolate( 2, oneMinusAlphaSquared );\r\n\t\tfloat d = velvetParamsInterpolate( 3, oneMinusAlphaSquared );\r\n\t\tfloat e = velvetParamsInterpolate( 4, oneMinusAlphaSquared );\r\n\r\n\t\treturn a / ( 1.0 + b * pow( abs( x ), c ) ) + d * x + e;\r\n\r\n\t}\r\n\r\n\t// See equation (3) in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetLambda( float cosTheta, float alpha ) {\r\n\r\n\t\treturn abs( cosTheta ) < 0.5 ? exp( velvetL( cosTheta, alpha ) ) : exp( 2.0 * velvetL( 0.5, alpha ) - velvetL( 1.0 - cosTheta, alpha ) );\r\n\r\n\t}\r\n\r\n\t// See Section 3, Shadowing Term, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat velvetG( float cosThetaO, float cosThetaI, float roughness ) {\r\n\r\n\t\tfloat alpha = max( roughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\treturn 1.0 / ( 1.0 + velvetLambda( cosThetaO, alpha ) + velvetLambda( cosThetaI, alpha ) );\r\n\r\n\t}\r\n\r\n\tfloat directionalAlbedoSheen( float cosTheta, float alpha ) {\r\n\r\n\t\tcosTheta = saturate( cosTheta );\r\n\r\n\t\tfloat c = 1.0 - cosTheta;\r\n\t\tfloat c3 = c * c * c;\r\n\r\n\t\treturn 0.65584461 * c3 + 1.0 / ( 4.16526551 + exp( -7.97291361 * sqrt( alpha ) + 6.33516894 ) );\r\n\r\n\t}\r\n\r\n\tfloat sheenAlbedoScaling( vec3 wo, vec3 wi, SurfaceRecord surf ) {\r\n\r\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\r\n\r\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\r\n\t\tfloat eWi = directionalAlbedoSheen( saturateCos( wi.z ), alpha );\r\n\r\n\t\treturn min( 1.0 - maxSheenColor * eWo, 1.0 - maxSheenColor * eWi );\r\n\r\n\t}\r\n\r\n\t// See Section 5, Layering, in http://www.aconty.com/pdf/s2017_pbs_imageworks_sheen.pdf\r\n\tfloat sheenAlbedoScaling( vec3 wo, SurfaceRecord surf ) {\r\n\r\n\t\tfloat alpha = max( surf.sheenRoughness, 0.07 );\r\n\t\talpha = alpha * alpha;\r\n\r\n\t\tfloat maxSheenColor = max( max( surf.sheenColor.r, surf.sheenColor.g ), surf.sheenColor.b );\r\n\r\n\t\tfloat eWo = directionalAlbedoSheen( saturateCos( wo.z ), alpha );\r\n\r\n\t\treturn 1.0 - maxSheenColor * eWo;\r\n\r\n\t}\r\n\r\n`;\r\n"],"names":[],"version":3,"file":"areaLight.590b4534.js.map","sourceRoot":"/__parcel_source_root/"}