{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAIA;AAEA,YAAY,CAAE,EAAE,IAAI,EAAE;IAErB,IAAI,WAAW,YAAY,GAAG;IAC9B,SAAS,mBAAoB,QAAQ;QAEpC,oBAAoB;QACpB,WAAW,KAAK,GAAG,CAAE,UAAU;QAE/B,MAAM,WAAW,YAAY,GAAG;QAChC,IAAK,WAAW,YAAY,MAAM,aAAa,KAAM;YAEpD,YAAa;gBAEZ,OAAO;gBACP,YAAY;gBACZ,UAAU;gBACV;YAED;YACA,WAAW;QAEZ;IAED;IAEA,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG;IACrC,IAAI;QAEH,MAAM,WAAW,IAAI,CAAA,GAAA,qBAAc,AAAD;QAClC,SAAS,YAAY,CAAE,YAAY,IAAI,CAAA,GAAA,sBAAe,AAAD,EAAG,UAAU,GAAG;QACrE,IAAK,OAEJ,SAAS,QAAQ,CAAE,IAAI,CAAA,GAAA,sBAAe,AAAD,EAAG,OAAO,GAAG;QAInD,IAAK,QAAQ,wBAAwB,EAEpC,QAAQ,UAAU,GAAG;QAItB,IAAK,QAAQ,MAAM,EAAG;YAErB,MAAM,SAAS,QAAQ,MAAM;YAC7B,IAAM,MAAM,KAAK,OAAS;gBAEzB,MAAM,QAAQ,MAAM,CAAE,EAAG;gBACzB,SAAS,QAAQ,CAAE,MAAM,KAAK,EAAE,MAAM,KAAK,EAAE,MAAM,aAAa;YAEjE;QAED;QAEA,MAAM,MAAM,IAAI,CAAA,GAAA,kBAAO,AAAD,EAAG,UAAU;QACnC,MAAM,aAAa,CAAA,GAAA,kBAAO,AAAD,EAAE,SAAS,CAAE,KAAK;YAAE,iBAAiB;QAAM;QACpE,IAAI,aAAa;YAAE,SAAS,MAAM;eAAK,WAAW,KAAK;SAAE;QACzD,IAAK,WAAW,KAAK,EAEpB,WAAW,IAAI,CAAE,WAAW,KAAK,CAAC,MAAM;QAIzC,aAAa,WAAW,MAAM,CAAE,CAAA,IAAK,AAAE,OAAO,sBAAsB,eAAiB,CAAI,CAAA,aAAa,iBAAgB;QAEtH,IAAK,IAAI,eAAe,EAEvB,WAAW,IAAI,CAAE,WAAW,cAAc,CAAC,MAAM;QAIlD,YAAa;YAEZ,OAAO;YACP;YACA;YACA,UAAU;QAEX,GAAG;IAEJ,EAAE,OAAQ,OAAQ;QAEjB,YAAa;YAEZ;YACA,YAAY;YACZ,UAAU;YACV,UAAU;QAEX;IAED;AAED","sources":["node_modules/three-mesh-bvh/src/workers/generateMeshBVH.worker.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tBufferAttribute,\n} from 'three';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nonmessage = ( { data } ) => {\n\n\tlet prevTime = performance.now();\n\tfunction onProgressCallback( progress ) {\n\n\t\t// account for error\n\t\tprogress = Math.min( progress, 1 );\n\n\t\tconst currTime = performance.now();\n\t\tif ( currTime - prevTime >= 10 && progress !== 1.0 ) {\n\n\t\t\tpostMessage( {\n\n\t\t\t\terror: null,\n\t\t\t\tserialized: null,\n\t\t\t\tposition: null,\n\t\t\t\tprogress,\n\n\t\t\t} );\n\t\t\tprevTime = currTime;\n\n\t\t}\n\n\t}\n\n\tconst { index, position, options } = data;\n\ttry {\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new BufferAttribute( position, 3, false ) );\n\t\tif ( index ) {\n\n\t\t\tgeometry.setIndex( new BufferAttribute( index, 1, false ) );\n\n\t\t}\n\n\t\tif ( options.includedProgressCallback ) {\n\n\t\t\toptions.onProgress = onProgressCallback;\n\n\t\t}\n\n\t\tif ( options.groups ) {\n\n\t\t\tconst groups = options.groups;\n\t\t\tfor ( const i in groups ) {\n\n\t\t\t\tconst group = groups[ i ];\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bvh = new MeshBVH( geometry, options );\n\t\tconst serialized = MeshBVH.serialize( bvh, { copyIndexBuffer: false } );\n\t\tlet toTransfer = [ position.buffer, ...serialized.roots ];\n\t\tif ( serialized.index ) {\n\n\t\t\ttoTransfer.push( serialized.index.buffer );\n\n\t\t}\n\n\t\ttoTransfer = toTransfer.filter( v => ( typeof SharedArrayBuffer === 'undefined' ) || ! ( v instanceof SharedArrayBuffer ) );\n\n\t\tif ( bvh._indirectBuffer ) {\n\n\t\t\ttoTransfer.push( serialized.indirectBuffer.buffer );\n\n\t\t}\n\n\t\tpostMessage( {\n\n\t\t\terror: null,\n\t\t\tserialized,\n\t\t\tposition,\n\t\t\tprogress: 1,\n\n\t\t}, toTransfer );\n\n\t} catch ( error ) {\n\n\t\tpostMessage( {\n\n\t\t\terror,\n\t\t\tserialized: null,\n\t\t\tposition: null,\n\t\t\tprogress: 1,\n\n\t\t} );\n\n\t}\n\n};\n"],"names":[],"version":3,"file":"generateMeshBVH.worker.e1a14054.js.map","sourceRoot":"/__parcel_source_root/"}