{"mappings":"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","sources":["src/index.js","src/core/WebGLPathTracer.js","src/core/PathTracingRenderer.js","src/materials/fullscreen/BlendMaterial.js","src/utils/SobolNumberMapGenerator.js","src/materials/pathtracing/PhysicalPathTracingMaterial.js","src/uniforms/PhysicalCameraUniform.js","src/objects/PhysicalCamera.js","src/uniforms/EquirectHdrInfoUniform.js","src/utils/TextureUtils.js","src/uniforms/LightsInfoUniformStruct.js","src/uniforms/AttributesTextureArray.js","src/uniforms/FloatAttributeTextureArray.js","src/uniforms/MaterialsTexture.js","src/core/utils/sceneUpdateUtils.js","src/uniforms/RenderTarget2DArray.js","src/uniforms/StratifiedSamplesTexture.js","src/uniforms/stratified/StratifiedSamplerCombined.js","src/uniforms/stratified/StratifiedSampler.js","src/textures/BlueNoiseTexture.js","src/textures/blueNoise/BlueNoiseGenerator.js","src/textures/blueNoise/utils.js","src/textures/blueNoise/BlueNoiseSamples.js","src/shader/bvh/index.js","src/shader/bvh/inside_fog_volume_function.glsl.js","src/shader/bvh/ray_any_hit_function.glsl.js","src/materials/pathtracing/glsl/index.js","src/materials/pathtracing/glsl/attenuate_hit_function.glsl.js","src/materials/pathtracing/glsl/camera_util_functions.glsl.js","src/materials/pathtracing/glsl/direct_light_contribution_function.glsl.js","src/materials/pathtracing/glsl/get_surface_record_function.glsl.js","src/materials/pathtracing/glsl/render_structs.glsl.js","src/materials/pathtracing/glsl/trace_scene_function.glsl.js","src/textures/GradientEquirectTexture.js","src/textures/ProceduralEquirectTexture.js","src/materials/fullscreen/ClampedInterpolationMaterial.js","src/utils/CubeToEquirectGenerator.js","src/objects/EquirectCamera.js","src/objects/PhysicalSpotLight.js","src/objects/ShapedAreaLight.js","src/utils/BlurredEnvMapGenerator.js","src/materials/fullscreen/DenoiseMaterial.js","src/materials/surface/FogVolumeMaterial.js"],"sourcesContent":["// core\r\nexport * from './core/PathTracingSceneGenerator.js';\r\nexport * from './core/WebGLPathTracer.js';\r\n\r\n// objects\r\nexport * from './objects/PhysicalCamera.js';\r\nexport * from './objects/EquirectCamera.js';\r\nexport * from './objects/PhysicalSpotLight.js';\r\nexport * from './objects/ShapedAreaLight.js';\r\n\r\n// textures\r\nexport * from './textures/ProceduralEquirectTexture.js';\r\nexport * from './textures/GradientEquirectTexture.js';\r\n\r\n// utils\r\nexport * from './utils/BlurredEnvMapGenerator.js';\r\n\r\n// materials\r\nexport * from './materials/fullscreen/DenoiseMaterial.js';\r\nexport * from './materials/surface/FogVolumeMaterial.js';\r\n\r\n// deprecated\r\nexport * from './materials/pathtracing/PhysicalPathTracingMaterial.js';\r\nexport * from './core/PathTracingRenderer.js';\r\n","import { PerspectiveCamera, Scene, Vector2, Clock, NormalBlending, NoBlending, AdditiveBlending } from 'three';\r\nimport { PathTracingSceneGenerator } from './PathTracingSceneGenerator.js';\r\nimport { PathTracingRenderer } from './PathTracingRenderer.js';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { GradientEquirectTexture } from '../textures/GradientEquirectTexture.js';\r\nimport { getIesTextures, getLights, getTextures } from './utils/sceneUpdateUtils.js';\r\nimport { ClampedInterpolationMaterial } from '../materials/fullscreen/ClampedInterpolationMaterial.js';\r\nimport { CubeToEquirectGenerator } from '../utils/CubeToEquirectGenerator.js';\r\n\r\nfunction supportsFloatBlending( renderer ) {\r\n\r\n\treturn renderer.extensions.get( 'EXT_float_blend' );\r\n\r\n}\r\n\r\nconst _resolution = new Vector2();\r\nexport class WebGLPathTracer {\r\n\r\n\tget multipleImportanceSampling() {\r\n\r\n\t\treturn Boolean( this._pathTracer.material.defines.FEATURE_MIS );\r\n\r\n\t}\r\n\r\n\tset multipleImportanceSampling( v ) {\r\n\r\n\t\tthis._pathTracer.material.setDefine( 'FEATURE_MIS', v ? 1 : 0 );\r\n\r\n\t}\r\n\r\n\tget transmissiveBounces() {\r\n\r\n\t\treturn this._pathTracer.material.transmissiveBounces;\r\n\r\n\t}\r\n\r\n\tset transmissiveBounces( v ) {\r\n\r\n\t\tthis._pathTracer.material.transmissiveBounces = v;\r\n\r\n\t}\r\n\r\n\tget bounces() {\r\n\r\n\t\treturn this._pathTracer.material.bounces;\r\n\r\n\t}\r\n\r\n\tset bounces( v ) {\r\n\r\n\t\tthis._pathTracer.material.bounces = v;\r\n\r\n\t}\r\n\r\n\tget filterGlossyFactor() {\r\n\r\n\t\treturn this._pathTracer.material.filterGlossyFactor;\r\n\r\n\t}\r\n\r\n\tset filterGlossyFactor( v ) {\r\n\r\n\t\tthis._pathTracer.material.filterGlossyFactor = v;\r\n\r\n\t}\r\n\r\n\tget samples() {\r\n\r\n\t\treturn this._pathTracer.samples;\r\n\r\n\t}\r\n\r\n\tget target() {\r\n\r\n\t\treturn this._pathTracer.target;\r\n\r\n\t}\r\n\r\n\tget tiles() {\r\n\r\n\t\treturn this._pathTracer.tiles;\r\n\r\n\t}\r\n\r\n\tget stableNoise() {\r\n\r\n\t\treturn this._pathTracer.stableNoise;\r\n\r\n\t}\r\n\r\n\tset stableNoise( v ) {\r\n\r\n\t\tthis._pathTracer.stableNoise = v;\r\n\r\n\t}\r\n\r\n\tget isCompiling() {\r\n\r\n\t\treturn Boolean( this._pathTracer.isCompiling );\r\n\r\n\t}\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\t// members\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._generator = new PathTracingSceneGenerator();\r\n\t\tthis._pathTracer = new PathTracingRenderer( renderer );\r\n\t\tthis._queueReset = false;\r\n\t\tthis._clock = new Clock();\r\n\t\tthis._compilePromise = null;\r\n\r\n\t\tthis._lowResPathTracer = new PathTracingRenderer( renderer );\r\n\t\tthis._lowResPathTracer.tiles.set( 1, 1 );\r\n\t\tthis._quad = new FullScreenQuad( new ClampedInterpolationMaterial( {\r\n\t\t\tmap: null,\r\n\t\t\ttransparent: true,\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tpremultipliedAlpha: renderer.getContextAttributes().premultipliedAlpha,\r\n\t\t} ) );\r\n\t\tthis._materials = null;\r\n\r\n\t\tthis._previousEnvironment = null;\r\n\t\tthis._previousBackground = null;\r\n\t\tthis._internalBackground = null;\r\n\r\n\t\t// options\r\n\t\tthis.renderDelay = 100;\r\n\t\tthis.minSamples = 5;\r\n\t\tthis.fadeDuration = 500;\r\n\t\tthis.enablePathTracing = true;\r\n\t\tthis.pausePathTracing = false;\r\n\t\tthis.dynamicLowRes = false;\r\n\t\tthis.lowResScale = 0.25;\r\n\t\tthis.renderScale = 1;\r\n\t\tthis.synchronizeRenderSize = true;\r\n\t\tthis.rasterizeScene = true;\r\n\t\tthis.renderToCanvas = true;\r\n\t\tthis.textureSize = new Vector2( 1024, 1024 );\r\n\t\tthis.rasterizeSceneCallback = ( scene, camera ) => {\r\n\r\n\t\t\tthis._renderer.render( scene, camera );\r\n\r\n\t\t};\r\n\r\n\t\tthis.renderToCanvasCallback = ( target, renderer, quad ) => {\r\n\r\n\t\t\tconst currentAutoClear = renderer.autoClear;\r\n\t\t\trenderer.autoClear = false;\r\n\t\t\tquad.render( renderer );\r\n\t\t\trenderer.autoClear = currentAutoClear;\r\n\r\n\t\t};\r\n\r\n\t\t// initialize the scene so it doesn't fail\r\n\t\tthis.setScene( new Scene(), new PerspectiveCamera() );\r\n\r\n\t}\r\n\r\n\tsetBVHWorker( worker ) {\r\n\r\n\t\tthis._generator.setBVHWorker( worker );\r\n\r\n\t}\r\n\r\n\tsetScene( scene, camera, options = {} ) {\r\n\r\n\t\tscene.updateMatrixWorld( true );\r\n\t\tcamera.updateMatrixWorld();\r\n\r\n\t\tconst generator = this._generator;\r\n\t\tgenerator.setObjects( scene );\r\n\r\n\t\tif ( this._buildAsync ) {\r\n\r\n\t\t\treturn generator.generateAsync( options.onProgress ).then( result => {\r\n\r\n\t\t\t\treturn this._updateFromResults( scene, camera, result );\r\n\r\n\t\t\t} );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst result = generator.generate();\r\n\t\t\treturn this._updateFromResults( scene, camera, result );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetSceneAsync( ...args ) {\r\n\r\n\t\tthis._buildAsync = true;\r\n\t\tconst result = this.setScene( ...args );\r\n\t\tthis._buildAsync = false;\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tsetCamera( camera ) {\r\n\r\n\t\tthis.camera = camera;\r\n\t\tthis.updateCamera();\r\n\r\n\t}\r\n\r\n\tupdateCamera() {\r\n\r\n\t\tconst camera = this.camera;\r\n\t\tcamera.updateMatrixWorld();\r\n\r\n\t\tthis._pathTracer.setCamera( camera );\r\n\t\tthis._lowResPathTracer.setCamera( camera );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tupdateMaterials() {\r\n\r\n\t\tconst material = this._pathTracer.material;\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst materials = this._materials;\r\n\t\tconst textureSize = this.textureSize;\r\n\r\n\t\t// reduce texture sources here - we don't want to do this in the\r\n\t\t// textures array because we need to pass the textures array into the\r\n\t\t// material target\r\n\t\tconst textures = getTextures( materials );\r\n\t\tmaterial.textures.setTextures( renderer, textures, textureSize.x, textureSize.y );\r\n\t\tmaterial.materials.updateFrom( materials, textures );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tupdateLights() {\r\n\r\n\t\tconst scene = this.scene;\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst material = this._pathTracer.material;\r\n\r\n\t\tconst lights = getLights( scene );\r\n\t\tconst iesTextures = getIesTextures( lights );\r\n\t\tmaterial.lights.updateFrom( lights, iesTextures );\r\n\t\tmaterial.iesProfiles.setTextures( renderer, iesTextures );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tupdateEnvironment() {\r\n\r\n\t\tconst scene = this.scene;\r\n\t\tconst material = this._pathTracer.material;\r\n\r\n\t\tif ( this._internalBackground ) {\r\n\r\n\t\t\tthis._internalBackground.dispose();\r\n\t\t\tthis._internalBackground = null;\r\n\r\n\t\t}\r\n\r\n\t\t// update scene background\r\n\t\tmaterial.backgroundBlur = scene.backgroundBlurriness;\r\n\t\tmaterial.backgroundIntensity = scene.backgroundIntensity ?? 1;\r\n\t\tmaterial.backgroundRotation.makeRotationFromEuler( scene.backgroundRotation ).invert();\r\n\t\tif ( scene.background === null ) {\r\n\r\n\t\t\tmaterial.backgroundMap = null;\r\n\t\t\tmaterial.backgroundAlpha = 0;\r\n\r\n\t\t} else if ( scene.background.isColor ) {\r\n\r\n\t\t\tthis._colorBackground = this._colorBackground || new GradientEquirectTexture( 16 );\r\n\r\n\t\t\tconst colorBackground = this._colorBackground;\r\n\t\t\tif ( ! colorBackground.topColor.equals( scene.background ) ) {\r\n\r\n\t\t\t\t// set the texture color\r\n\t\t\t\tcolorBackground.topColor.set( scene.background );\r\n\t\t\t\tcolorBackground.bottomColor.set( scene.background );\r\n\t\t\t\tcolorBackground.update();\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// assign to material\r\n\t\t\tmaterial.backgroundMap = colorBackground;\r\n\t\t\tmaterial.backgroundAlpha = 1;\r\n\r\n\t\t} else if ( scene.background.isCubeTexture ) {\r\n\r\n\t\t\tif ( scene.background !== this._previousBackground ) {\r\n\r\n\t\t\t\tconst background = new CubeToEquirectGenerator( this._renderer ).generate( scene.background );\r\n\t\t\t\tthis._internalBackground = background;\r\n\t\t\t\tmaterial.backgroundMap = background;\r\n\t\t\t\tmaterial.backgroundAlpha = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.backgroundMap = scene.background;\r\n\t\t\tmaterial.backgroundAlpha = 1;\r\n\r\n\t\t}\r\n\r\n\t\t// update scene environment\r\n\t\tmaterial.environmentIntensity = scene.environment !== null ? ( scene.environmentIntensity ?? 1 ) : 0;\r\n\t\tmaterial.environmentRotation.makeRotationFromEuler( scene.environmentRotation ).invert();\r\n\t\tif ( this._previousEnvironment !== scene.environment ) {\r\n\r\n\t\t\tif ( scene.environment !== null ) {\r\n\r\n\t\t\t\tif ( scene.environment.isCubeTexture ) {\r\n\r\n\t\t\t\t\tconst environment = new CubeToEquirectGenerator( this._renderer ).generate( scene.environment );\r\n\t\t\t\t\tmaterial.envMapInfo.updateFrom( environment );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// TODO: Consider setting this to the highest supported bit depth by checking for\r\n\t\t\t\t\t// OES_texture_float_linear or OES_texture_half_float_linear. Requires changes to\r\n\t\t\t\t\t// the equirect uniform\r\n\t\t\t\t\tmaterial.envMapInfo.updateFrom( scene.environment );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._previousEnvironment = scene.environment;\r\n\t\tthis._previousBackground = scene.background;\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\t_updateFromResults( scene, camera, results ) {\r\n\r\n\t\tconst {\r\n\t\t\tmaterials,\r\n\t\t\tgeometry,\r\n\t\t\tbvh,\r\n\t\t\tbvhChanged,\r\n\t\t} = results;\r\n\r\n\t\tthis._materials = materials;\r\n\r\n\t\tconst pathTracer = this._pathTracer;\r\n\t\tconst material = pathTracer.material;\r\n\r\n\t\tif ( bvhChanged ) {\r\n\r\n\t\t\tmaterial.bvh.updateFrom( bvh );\r\n\t\t\tmaterial.attributesArray.updateFrom(\r\n\t\t\t\tgeometry.attributes.normal,\r\n\t\t\t\tgeometry.attributes.tangent,\r\n\t\t\t\tgeometry.attributes.uv,\r\n\t\t\t\tgeometry.attributes.color,\r\n\t\t\t);\r\n\r\n\t\t\tmaterial.materialIndexAttribute.updateFrom( geometry.attributes.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// save previously used items\r\n\t\tthis._previousScene = scene;\r\n\t\tthis.scene = scene;\r\n\t\tthis.camera = camera;\r\n\r\n\t\tthis.updateCamera();\r\n\t\tthis.updateMaterials();\r\n\t\tthis.updateEnvironment();\r\n\t\tthis.updateLights();\r\n\r\n\t\treturn results;\r\n\r\n\t}\r\n\r\n\trenderSample() {\r\n\r\n\t\tconst lowResPathTracer = this._lowResPathTracer;\r\n\t\tconst pathTracer = this._pathTracer;\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst clock = this._clock;\r\n\t\tconst quad = this._quad;\r\n\r\n\t\tthis._updateScale();\r\n\r\n\t\tif ( this._queueReset ) {\r\n\r\n\t\t\tpathTracer.reset();\r\n\t\t\tlowResPathTracer.reset();\r\n\t\t\tthis._queueReset = false;\r\n\r\n\t\t\tquad.material.opacity = 0;\r\n\t\t\tclock.start();\r\n\r\n\t\t}\r\n\r\n\t\t// render the path tracing sample after enough time has passed\r\n\t\tconst delta = clock.getDelta() * 1e3;\r\n\t\tconst elapsedTime = clock.getElapsedTime() * 1e3;\r\n\t\tif ( ! this.pausePathTracing && this.enablePathTracing && this.renderDelay <= elapsedTime && ! this.isCompiling ) {\r\n\r\n\t\t\tpathTracer.update();\r\n\r\n\t\t}\r\n\r\n\t\t// when alpha is enabled we use a manual blending system rather than\r\n\t\t// rendering with a blend function\r\n\t\tpathTracer.alpha = pathTracer.material.backgroundAlpha !== 1 || ! supportsFloatBlending( renderer );\r\n\t\tlowResPathTracer.alpha = pathTracer.alpha;\r\n\r\n\t\tif ( this.renderToCanvas ) {\r\n\r\n\t\t\tconst renderer = this._renderer;\r\n\t\t\tconst minSamples = this.minSamples;\r\n\r\n\t\t\tif ( elapsedTime >= this.renderDelay && this.samples >= this.minSamples ) {\r\n\r\n\t\t\t\tif ( this.fadeDuration !== 0 ) {\r\n\r\n\t\t\t\t\tquad.material.opacity = Math.min( quad.material.opacity + delta / this.fadeDuration, 1 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tquad.material.opacity = 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// render the fallback if we haven't rendered enough samples, are paused, or are occluded\r\n\t\t\tif ( ! this.enablePathTracing || this.samples < minSamples || quad.material.opacity < 1 ) {\r\n\r\n\t\t\t\tif ( this.dynamicLowRes && ! this.isCompiling ) {\r\n\r\n\t\t\t\t\tif ( lowResPathTracer.samples < 1 ) {\r\n\r\n\t\t\t\t\t\tlowResPathTracer.material = pathTracer.material;\r\n\t\t\t\t\t\tlowResPathTracer.update();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tconst currentOpacity = quad.material.opacity;\r\n\t\t\t\t\tquad.material.opacity = 1 - quad.material.opacity;\r\n\t\t\t\t\tquad.material.map = lowResPathTracer.target.texture;\r\n\t\t\t\t\tquad.render( renderer );\r\n\t\t\t\t\tquad.material.opacity = currentOpacity;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! this.dynamicLowRes && this.rasterizeScene || this.dynamicLowRes && this.isCompiling ) {\r\n\r\n\t\t\t\t\tthis.rasterizeSceneCallback( this.scene, this.camera );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( this.enablePathTracing && quad.material.opacity > 0 ) {\r\n\r\n\t\t\t\tif ( quad.material.opacity < 1 ) {\r\n\r\n\t\t\t\t\t// use additive blending when the low res texture is rendered so we can fade the\r\n\t\t\t\t\t// background out while the full res fades in\r\n\t\t\t\t\tquad.material.blending = this.dynamicLowRes ? AdditiveBlending : NormalBlending;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tquad.material.map = pathTracer.target.texture;\r\n\t\t\t\tthis.renderToCanvasCallback( pathTracer.target, renderer, quad );\r\n\t\t\t\tquad.material.blending = NoBlending;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis._queueReset = true;\r\n\t\tthis._pathTracer.samples = 0;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._quad.dispose();\r\n\t\tthis._quad.material.dispose();\r\n\t\tthis._pathTracer.dispose();\r\n\r\n\t}\r\n\r\n\t_updateScale() {\r\n\r\n\t\t// update the path tracer scale if it has changed\r\n\t\tif ( this.synchronizeRenderSize ) {\r\n\r\n\t\t\tthis._renderer.getDrawingBufferSize( _resolution );\r\n\r\n\t\t\tconst w = Math.floor( this.renderScale * _resolution.x );\r\n\t\t\tconst h = Math.floor( this.renderScale * _resolution.y );\r\n\r\n\t\t\tthis._pathTracer.getSize( _resolution );\r\n\t\t\tif ( _resolution.x !== w || _resolution.y !== h ) {\r\n\r\n\t\t\t\tconst lowResScale = this.lowResScale;\r\n\t\t\t\tthis._pathTracer.setSize( w, h );\r\n\t\t\t\tthis._lowResPathTracer.setSize( Math.floor( w * lowResScale ), Math.floor( h * lowResScale ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { RGBAFormat, FloatType, Color, Vector2, WebGLRenderTarget, NoBlending, NormalBlending, Vector4, NearestFilter } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { BlendMaterial } from '../materials/fullscreen/BlendMaterial.js';\r\nimport { SobolNumberMapGenerator } from '../utils/SobolNumberMapGenerator.js';\r\nimport { PhysicalPathTracingMaterial } from '../materials/pathtracing/PhysicalPathTracingMaterial.js';\r\n\r\nfunction* renderTask() {\r\n\r\n\tconst {\r\n\t\t_renderer,\r\n\t\t_fsQuad,\r\n\t\t_blendQuad,\r\n\t\t_primaryTarget,\r\n\t\t_blendTargets,\r\n\t\t_sobolTarget,\r\n\t\t_subframe,\r\n\t\talpha,\r\n\t\tmaterial,\r\n\t} = this;\r\n\tconst _ogScissor = new Vector4();\r\n\tconst _ogViewport = new Vector4();\r\n\r\n\tconst blendMaterial = _blendQuad.material;\r\n\tlet [ blendTarget1, blendTarget2 ] = _blendTargets;\r\n\r\n\twhile ( true ) {\r\n\r\n\t\tif ( alpha ) {\r\n\r\n\t\t\tblendMaterial.opacity = this._opacityFactor / ( this.samples + 1 );\r\n\t\t\tmaterial.blending = NoBlending;\r\n\t\t\tmaterial.opacity = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterial.opacity = this._opacityFactor / ( this.samples + 1 );\r\n\t\t\tmaterial.blending = NormalBlending;\r\n\r\n\t\t}\r\n\r\n\t\tconst [ subX, subY, subW, subH ] = _subframe;\r\n\r\n\t\tconst w = _primaryTarget.width;\r\n\t\tconst h = _primaryTarget.height;\r\n\t\tmaterial.resolution.set( w * subW, h * subH );\r\n\t\tmaterial.sobolTexture = _sobolTarget.texture;\r\n\t\tmaterial.stratifiedTexture.init( 20, material.bounces + material.transmissiveBounces + 5 );\r\n\t\tmaterial.stratifiedTexture.next();\r\n\t\tmaterial.seed ++;\r\n\r\n\t\tconst tilesX = this.tiles.x || 1;\r\n\t\tconst tilesY = this.tiles.y || 1;\r\n\t\tconst totalTiles = tilesX * tilesY;\r\n\r\n\t\tconst pxSubW = Math.ceil( w * subW );\r\n\t\tconst pxSubH = Math.ceil( h * subH );\r\n\t\tconst pxSubX = Math.floor( subX * w );\r\n\t\tconst pxSubY = Math.floor( subY * h );\r\n\r\n\t\tconst pxTileW = Math.ceil( pxSubW / tilesX );\r\n\t\tconst pxTileH = Math.ceil( pxSubH / tilesY );\r\n\r\n\t\tfor ( let y = 0; y < tilesY; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < tilesX; x ++ ) {\r\n\r\n\t\t\t\t// store og state\r\n\t\t\t\tconst ogRenderTarget = _renderer.getRenderTarget();\r\n\t\t\t\tconst ogAutoClear = _renderer.autoClear;\r\n\t\t\t\tconst ogScissorTest = _renderer.getScissorTest();\r\n\t\t\t\t_renderer.getScissor( _ogScissor );\r\n\t\t\t\t_renderer.getViewport( _ogViewport );\r\n\r\n\t\t\t\tlet tx = x;\r\n\t\t\t\tlet ty = y;\r\n\t\t\t\tif ( ! this.stableTiles ) {\r\n\r\n\t\t\t\t\tconst tileIndex = ( this._currentTile ) % ( tilesX * tilesY );\r\n\t\t\t\t\ttx = tileIndex % tilesX;\r\n\t\t\t\t\tty = ~ ~ ( tileIndex / tilesX );\r\n\r\n\t\t\t\t\tthis._currentTile = tileIndex + 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// set the scissor and the viewport on the render target\r\n\t\t\t\t// note that when using the webgl renderer set viewport the device pixel ratio\r\n\t\t\t\t// is multiplied into the field causing some pixels to not be rendered\r\n\t\t\t\tconst reverseTy = tilesY - ty - 1;\r\n\t\t\t\t_primaryTarget.scissor.set(\r\n\t\t\t\t\tpxSubX + tx * pxTileW,\r\n\t\t\t\t\tpxSubY + reverseTy * pxTileH,\r\n\t\t\t\t\tMath.min( pxTileW, pxSubW - tx * pxTileW ),\r\n\t\t\t\t\tMath.min( pxTileH, pxSubH - reverseTy * pxTileH ),\r\n\t\t\t\t);\r\n\r\n\t\t\t\t_primaryTarget.viewport.set(\r\n\t\t\t\t\tpxSubX,\r\n\t\t\t\t\tpxSubY,\r\n\t\t\t\t\tpxSubW,\r\n\t\t\t\t\tpxSubH,\r\n\t\t\t\t);\r\n\r\n\t\t\t\t// three.js renderer takes values relative to the current pixel ratio\r\n\t\t\t\t_renderer.setRenderTarget( _primaryTarget );\r\n\t\t\t\t_renderer.setScissorTest( true );\r\n\r\n\t\t\t\t_renderer.autoClear = false;\r\n\t\t\t\t_fsQuad.render( _renderer );\r\n\r\n\t\t\t\t// reset original renderer state\r\n\t\t\t\t_renderer.setViewport( _ogViewport );\r\n\t\t\t\t_renderer.setScissor( _ogScissor );\r\n\t\t\t\t_renderer.setScissorTest( ogScissorTest );\r\n\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\t\t\t\t_renderer.autoClear = ogAutoClear;\r\n\r\n\t\t\t\t// swap and blend alpha targets\r\n\t\t\t\tif ( alpha ) {\r\n\r\n\t\t\t\t\tblendMaterial.target1 = blendTarget1.texture;\r\n\t\t\t\t\tblendMaterial.target2 = _primaryTarget.texture;\r\n\r\n\t\t\t\t\t_renderer.setRenderTarget( blendTarget2 );\r\n\t\t\t\t\t_blendQuad.render( _renderer );\r\n\t\t\t\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.samples += ( 1 / totalTiles );\r\n\r\n\t\t\t\t// round the samples value if we've finished the tiles\r\n\t\t\t\tif ( x === tilesX - 1 && y === tilesY - 1 ) {\r\n\r\n\t\t\t\t\tthis.samples = Math.round( this.samples );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tyield;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t[ blendTarget1, blendTarget2 ] = [ blendTarget2, blendTarget1 ];\r\n\r\n\t}\r\n\r\n}\r\n\r\nconst ogClearColor = new Color();\r\nexport class PathTracingRenderer {\r\n\r\n\tget material() {\r\n\r\n\t\treturn this._fsQuad.material;\r\n\r\n\t}\r\n\r\n\tset material( v ) {\r\n\r\n\t\tthis._fsQuad.material.removeEventListener( 'recompilation', this._compileFunction );\r\n\t\tv.addEventListener( 'recompilation', this._compileFunction );\r\n\r\n\t\tthis._fsQuad.material = v;\r\n\r\n\t}\r\n\r\n\tget target() {\r\n\r\n\t\treturn this._alpha ? this._blendTargets[ 1 ] : this._primaryTarget;\r\n\r\n\t}\r\n\r\n\tset alpha( v ) {\r\n\r\n\t\tif ( this._alpha === v ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! v ) {\r\n\r\n\t\t\tthis._blendTargets[ 0 ].dispose();\r\n\t\t\tthis._blendTargets[ 1 ].dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis._alpha = v;\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tget alpha() {\r\n\r\n\t\treturn this._alpha;\r\n\r\n\t}\r\n\r\n\tget isCompiling() {\r\n\r\n\t\treturn Boolean( this._compilePromise );\r\n\r\n\t}\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis.camera = null;\r\n\t\tthis.tiles = new Vector2( 3, 3 );\r\n\r\n\t\tthis.stableNoise = false;\r\n\t\tthis.stableTiles = true;\r\n\r\n\t\tthis.samples = 0;\r\n\t\tthis._subframe = new Vector4( 0, 0, 1, 1 );\r\n\t\tthis._opacityFactor = 1.0;\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._alpha = false;\r\n\t\tthis._fsQuad = new FullScreenQuad( new PhysicalPathTracingMaterial() );\r\n\t\tthis._blendQuad = new FullScreenQuad( new BlendMaterial() );\r\n\t\tthis._task = null;\r\n\t\tthis._currentTile = 0;\r\n\t\tthis._compilePromise = null;\r\n\r\n\t\tthis._sobolTarget = new SobolNumberMapGenerator().generate( renderer );\r\n\r\n\t\tthis._primaryTarget = new WebGLRenderTarget( 1, 1, {\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: FloatType,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t} );\r\n\t\tthis._blendTargets = [\r\n\t\t\tnew WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: FloatType,\r\n\t\t\t\tmagFilter: NearestFilter,\r\n\t\t\t\tminFilter: NearestFilter,\r\n\t\t\t} ),\r\n\t\t\tnew WebGLRenderTarget( 1, 1, {\r\n\t\t\t\tformat: RGBAFormat,\r\n\t\t\t\ttype: FloatType,\r\n\t\t\t\tmagFilter: NearestFilter,\r\n\t\t\t\tminFilter: NearestFilter,\r\n\t\t\t} ),\r\n\t\t];\r\n\r\n\t\t// function for listening to for triggered compilation so we can wait for compilation to finish\r\n\t\t// before starting to render\r\n\t\tthis._compileFunction = () => {\r\n\r\n\t\t\tconst promise = this.compileMaterial( this._fsQuad._mesh );\r\n\t\t\tpromise.then( () => {\r\n\r\n\t\t\t\tif ( this._compilePromise === promise ) {\r\n\r\n\t\t\t\t\tthis._compilePromise = null;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\tthis._compilePromise = promise;\r\n\r\n\t\t};\r\n\r\n\t\tthis.material.addEventListener( 'recompilation', this._compileFunction );\r\n\r\n\t}\r\n\r\n\tcompileMaterial() {\r\n\r\n\t\treturn this._renderer.compileAsync( this._fsQuad._mesh );\r\n\r\n\t}\r\n\r\n\tsetCamera( camera ) {\r\n\r\n\t\tconst { material } = this;\r\n\t\tmaterial.cameraWorldMatrix.copy( camera.matrixWorld );\r\n\t\tmaterial.invProjectionMatrix.copy( camera.projectionMatrixInverse );\r\n\t\tmaterial.physicalCamera.updateFrom( camera );\r\n\r\n\t\t// Perspective camera (default)\r\n\t\tlet cameraType = 0;\r\n\r\n\t\t// An orthographic projection matrix will always have the bottom right element == 1\r\n\t\t// And a perspective projection matrix will always have the bottom right element == 0\r\n\t\tif ( camera.projectionMatrix.elements[ 15 ] > 0 ) {\r\n\r\n\t\t\t// Orthographic\r\n\t\t\tcameraType = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( camera.isEquirectCamera ) {\r\n\r\n\t\t\t// Equirectangular\r\n\t\t\tcameraType = 2;\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.setDefine( 'CAMERA_TYPE', cameraType );\r\n\r\n\t\tthis.camera = camera;\r\n\r\n\t}\r\n\r\n\tsetSize( w, h ) {\r\n\r\n\t\tw = Math.ceil( w );\r\n\t\th = Math.ceil( h );\r\n\r\n\t\tif ( this._primaryTarget.width === w && this._primaryTarget.height === h ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis._primaryTarget.setSize( w, h );\r\n\t\tthis._blendTargets[ 0 ].setSize( w, h );\r\n\t\tthis._blendTargets[ 1 ].setSize( w, h );\r\n\t\tthis.reset();\r\n\r\n\t}\r\n\r\n\tgetSize( target ) {\r\n\r\n\t\ttarget.x = this._primaryTarget.width;\r\n\t\ttarget.y = this._primaryTarget.height;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._primaryTarget.dispose();\r\n\t\tthis._blendTargets[ 0 ].dispose();\r\n\t\tthis._blendTargets[ 1 ].dispose();\r\n\t\tthis._sobolTarget.dispose();\r\n\r\n\t\tthis._fsQuad.dispose();\r\n\t\tthis._blendQuad.dispose();\r\n\t\tthis._task = null;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tconst { _renderer, _primaryTarget, _blendTargets } = this;\r\n\t\tconst ogRenderTarget = _renderer.getRenderTarget();\r\n\t\tconst ogClearAlpha = _renderer.getClearAlpha();\r\n\t\t_renderer.getClearColor( ogClearColor );\r\n\r\n\t\t_renderer.setRenderTarget( _primaryTarget );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setRenderTarget( _blendTargets[ 0 ] );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setRenderTarget( _blendTargets[ 1 ] );\r\n\t\t_renderer.setClearColor( 0, 0 );\r\n\t\t_renderer.clearColor();\r\n\r\n\t\t_renderer.setClearColor( ogClearColor, ogClearAlpha );\r\n\t\t_renderer.setRenderTarget( ogRenderTarget );\r\n\r\n\t\tthis.samples = 0;\r\n\t\tthis._task = null;\r\n\r\n\t\tthis.material.stratifiedTexture.stableNoise = this.stableNoise;\r\n\t\tif ( this.stableNoise ) {\r\n\r\n\t\t\tthis.material.seed = 0;\r\n\t\t\tthis.material.stratifiedTexture.reset();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\t// ensure we've updated our defines before rendering so we can ensure we\r\n\t\t// can wait for compilation to finish\r\n\t\tthis.material.onBeforeRender();\r\n\t\tif ( this.isCompiling ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! this._task ) {\r\n\r\n\t\t\tthis._task = renderTask.call( this );\r\n\r\n\t\t}\r\n\r\n\t\tthis._task.next();\r\n\r\n\t}\r\n\r\n}\r\n","import { NoBlending } from 'three';\r\nimport { MaterialBase } from '../MaterialBase.js';\r\n\r\nexport class BlendMaterial extends MaterialBase {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\ttarget1: { value: null },\r\n\t\t\t\ttarget2: { value: null },\r\n\t\t\t\topacity: { value: 1.0 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tuniform sampler2D target1;\r\n\t\t\t\tuniform sampler2D target2;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 color1 = texture2D( target1, vUv );\r\n\t\t\t\t\tvec4 color2 = texture2D( target2, vUv );\r\n\r\n\t\t\t\t\tfloat invOpacity = 1.0 - opacity;\r\n\t\t\t\t\tfloat totalAlpha = color1.a * invOpacity + color2.a * opacity;\r\n\r\n\t\t\t\t\tif ( color1.a != 0.0 || color2.a != 0.0 ) {\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb = color1.rgb * ( invOpacity * color1.a / totalAlpha ) + color2.rgb * ( opacity * color2.a / totalAlpha );\r\n\t\t\t\t\t\tgl_FragColor.a = totalAlpha;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}`\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n","import { FloatType, NearestFilter, NoBlending, RGBAFormat, Vector2, WebGLRenderTarget } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { MaterialBase } from '../materials/MaterialBase.js';\r\nimport { sobol_common, sobol_point_generation } from '../shader/rand/sobol.glsl.js';\r\n\r\nclass SobolNumbersMaterial extends MaterialBase {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tresolution: { value: new Vector2() },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\t${ sobol_common }\r\n\t\t\t\t${ sobol_point_generation }\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tuint index = uint( gl_FragCoord.y ) * uint( resolution.x ) + uint( gl_FragCoord.x );\r\n\t\t\t\t\tgl_FragColor = generateSobolPoint( index );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class SobolNumberMapGenerator {\r\n\r\n\tgenerate( renderer, dimensions = 256 ) {\r\n\r\n\t\tconst target = new WebGLRenderTarget( dimensions, dimensions, {\r\n\r\n\t\t\ttype: FloatType,\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\tminFilter: NearestFilter,\r\n\t\t\tmagFilter: NearestFilter,\r\n\t\t\tgenerateMipmaps: false,\r\n\r\n\t\t} );\r\n\r\n\t\tconst ogTarget = renderer.getRenderTarget();\r\n\t\trenderer.setRenderTarget( target );\r\n\r\n\t\tconst quad = new FullScreenQuad( new SobolNumbersMaterial() );\r\n\t\tquad.material.resolution.set( dimensions, dimensions );\r\n\t\tquad.render( renderer );\r\n\r\n\t\trenderer.setRenderTarget( ogTarget );\r\n\t\tquad.dispose();\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n","import { ClampToEdgeWrapping, HalfFloatType, Matrix4, Vector2 } from 'three';\r\nimport { MaterialBase } from '../MaterialBase.js';\r\nimport {\r\n\tMeshBVHUniformStruct, UIntVertexAttributeTexture,\r\n\tBVHShaderGLSL,\r\n} from 'three-mesh-bvh';\r\n\r\n// uniforms\r\nimport { PhysicalCameraUniform } from '../../uniforms/PhysicalCameraUniform.js';\r\nimport { EquirectHdrInfoUniform } from '../../uniforms/EquirectHdrInfoUniform.js';\r\nimport { LightsInfoUniformStruct } from '../../uniforms/LightsInfoUniformStruct.js';\r\nimport { AttributesTextureArray } from '../../uniforms/AttributesTextureArray.js';\r\nimport { MaterialsTexture, MATERIAL_PIXELS } from '../../uniforms/MaterialsTexture.js';\r\nimport { RenderTarget2DArray } from '../../uniforms/RenderTarget2DArray.js';\r\nimport { StratifiedSamplesTexture } from '../../uniforms/StratifiedSamplesTexture.js';\r\nimport { BlueNoiseTexture } from '../../textures/BlueNoiseTexture.js';\r\n\r\n// general glsl\r\nimport * as StructsGLSL from '../../shader/structs/index.js';\r\nimport * as SamplingGLSL from '../../shader/sampling/index.js';\r\nimport * as CommonGLSL from '../../shader/common/index.js';\r\nimport * as RandomGLSL from '../../shader/rand/index.js';\r\nimport * as BSDFGLSL from '../../shader/bsdf/index.js';\r\nimport * as PTBVHGLSL from '../../shader/bvh/index.js';\r\n\r\n// path tracer glsl\r\nimport * as RenderGLSL from './glsl/index.js';\r\n\r\nexport class PhysicalPathTracingMaterial extends MaterialBase {\r\n\r\n\tonBeforeRender() {\r\n\r\n\t\tthis.setDefine( 'FEATURE_DOF', this.physicalCamera.bokehSize === 0 ? 0 : 1 );\r\n\t\tthis.setDefine( 'FEATURE_BACKGROUND_MAP', this.backgroundMap ? 1 : 0 );\r\n\t\tthis.setDefine( 'FEATURE_FOG', this.materials.features.isUsed( 'FOG' ) ? 1 : 0 );\r\n\r\n\t}\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\ttransparent: true,\r\n\t\t\tdepthWrite: false,\r\n\r\n\t\t\tdefines: {\r\n\t\t\t\tFEATURE_MIS: 1,\r\n\t\t\t\tFEATURE_RUSSIAN_ROULETTE: 1,\r\n\t\t\t\tFEATURE_DOF: 1,\r\n\t\t\t\tFEATURE_BACKGROUND_MAP: 0,\r\n\t\t\t\tFEATURE_FOG: 1,\r\n\r\n\t\t\t\t// 0 = PCG\r\n\t\t\t\t// 1 = Sobol\r\n\t\t\t\t// 2 = Stratified List\r\n\t\t\t\tRANDOM_TYPE: 2,\r\n\r\n\t\t\t\t// 0 = Perspective\r\n\t\t\t\t// 1 = Orthographic\r\n\t\t\t\t// 2 = Equirectangular\r\n\t\t\t\tCAMERA_TYPE: 0,\r\n\r\n\t\t\t\tDEBUG_MODE: 0,\r\n\r\n\t\t\t\tATTR_NORMAL: 0,\r\n\t\t\t\tATTR_TANGENT: 1,\r\n\t\t\t\tATTR_UV: 2,\r\n\t\t\t\tATTR_COLOR: 3,\r\n\t\t\t\tMATERIAL_PIXELS: MATERIAL_PIXELS,\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\t// path trace uniforms\r\n\t\t\t\tresolution: { value: new Vector2() },\r\n\t\t\t\topacity: { value: 1 },\r\n\t\t\t\tbounces: { value: 10 },\r\n\t\t\t\ttransmissiveBounces: { value: 10 },\r\n\t\t\t\tfilterGlossyFactor: { value: 0 },\r\n\r\n\t\t\t\t// camera uniforms\r\n\t\t\t\tphysicalCamera: { value: new PhysicalCameraUniform() },\r\n\t\t\t\tcameraWorldMatrix: { value: new Matrix4() },\r\n\t\t\t\tinvProjectionMatrix: { value: new Matrix4() },\r\n\r\n\t\t\t\t// scene uniforms\r\n\t\t\t\tbvh: { value: new MeshBVHUniformStruct() },\r\n\t\t\t\tattributesArray: { value: new AttributesTextureArray() },\r\n\t\t\t\tmaterialIndexAttribute: { value: new UIntVertexAttributeTexture() },\r\n\t\t\t\tmaterials: { value: new MaterialsTexture() },\r\n\t\t\t\ttextures: { value: new RenderTarget2DArray().texture },\r\n\r\n\t\t\t\t// light uniforms\r\n\t\t\t\tlights: { value: new LightsInfoUniformStruct() },\r\n\t\t\t\tiesProfiles: { value: new RenderTarget2DArray( 360, 180, {\r\n\t\t\t\t\ttype: HalfFloatType,\r\n\t\t\t\t\twrapS: ClampToEdgeWrapping,\r\n\t\t\t\t\twrapT: ClampToEdgeWrapping,\r\n\t\t\t\t} ).texture },\r\n\t\t\t\tenvironmentIntensity: { value: 1.0 },\r\n\t\t\t\tenvironmentRotation: { value: new Matrix4() },\r\n\t\t\t\tenvMapInfo: { value: new EquirectHdrInfoUniform() },\r\n\r\n\t\t\t\t// background uniforms\r\n\t\t\t\tbackgroundBlur: { value: 0.0 },\r\n\t\t\t\tbackgroundMap: { value: null },\r\n\t\t\t\tbackgroundAlpha: { value: 1.0 },\r\n\t\t\t\tbackgroundIntensity: { value: 1.0 },\r\n\t\t\t\tbackgroundRotation: { value: new Matrix4() },\r\n\r\n\t\t\t\t// randomness uniforms\r\n\t\t\t\tseed: { value: 0 },\r\n\t\t\t\tsobolTexture: { value: null },\r\n\t\t\t\tstratifiedTexture: { value: new StratifiedSamplesTexture() },\r\n\t\t\t\tstratifiedOffsetTexture: { value: new BlueNoiseTexture( 64, 1 ) },\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec4 mvPosition = vec4( position, 1.0 );\r\n\t\t\t\t\tmvPosition = modelViewMatrix * mvPosition;\r\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\t#define RAY_OFFSET 1e-4\r\n\t\t\t\t#define INFINITY 1e20\r\n\r\n\t\t\t\tprecision highp isampler2D;\r\n\t\t\t\tprecision highp usampler2D;\r\n\t\t\t\tprecision highp sampler2DArray;\r\n\t\t\t\tvec4 envMapTexelToLinear( vec4 a ) { return a; }\r\n\t\t\t\t#include <common>\r\n\r\n\t\t\t\t// bvh intersection\r\n\t\t\t\t${ BVHShaderGLSL.common_functions }\r\n\t\t\t\t${ BVHShaderGLSL.bvh_struct_definitions }\r\n\t\t\t\t${ BVHShaderGLSL.bvh_ray_functions }\r\n\r\n\t\t\t\t// uniform structs\r\n\t\t\t\t${ StructsGLSL.camera_struct }\r\n\t\t\t\t${ StructsGLSL.lights_struct }\r\n\t\t\t\t${ StructsGLSL.equirect_struct }\r\n\t\t\t\t${ StructsGLSL.material_struct }\r\n\t\t\t\t${ StructsGLSL.surface_record_struct }\r\n\r\n\t\t\t\t// random\r\n\t\t\t\t#if RANDOM_TYPE == 2 \t// Stratified List\r\n\r\n\t\t\t\t\t${ RandomGLSL.stratified_functions }\r\n\r\n\t\t\t\t#elif RANDOM_TYPE == 1 \t// Sobol\r\n\r\n\t\t\t\t\t${ RandomGLSL.pcg_functions }\r\n\t\t\t\t\t${ RandomGLSL.sobol_common }\r\n\t\t\t\t\t${ RandomGLSL.sobol_functions }\r\n\r\n\t\t\t\t\t#define rand(v) sobol(v)\r\n\t\t\t\t\t#define rand2(v) sobol2(v)\r\n\t\t\t\t\t#define rand3(v) sobol3(v)\r\n\t\t\t\t\t#define rand4(v) sobol4(v)\r\n\r\n\t\t\t\t#else \t\t\t\t\t// PCG\r\n\r\n\t\t\t\t${ RandomGLSL.pcg_functions }\r\n\r\n\t\t\t\t\t// Using the sobol functions seems to break the the compiler on MacOS\r\n\t\t\t\t\t// - specifically the \"sobolReverseBits\" function.\r\n\t\t\t\t\tuint sobolPixelIndex = 0u;\r\n\t\t\t\t\tuint sobolPathIndex = 0u;\r\n\t\t\t\t\tuint sobolBounceIndex = 0u;\r\n\r\n\t\t\t\t\t#define rand(v) pcgRand()\r\n\t\t\t\t\t#define rand2(v) pcgRand2()\r\n\t\t\t\t\t#define rand3(v) pcgRand3()\r\n\t\t\t\t\t#define rand4(v) pcgRand4()\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// common\r\n\t\t\t\t${ CommonGLSL.texture_sample_functions }\r\n\t\t\t\t${ CommonGLSL.fresnel_functions }\r\n\t\t\t\t${ CommonGLSL.util_functions }\r\n\t\t\t\t${ CommonGLSL.math_functions }\r\n\t\t\t\t${ CommonGLSL.shape_intersection_functions }\r\n\r\n\t\t\t\t// environment\r\n\t\t\t\tuniform EquirectHdrInfo envMapInfo;\r\n\t\t\t\tuniform mat4 environmentRotation;\r\n\t\t\t\tuniform float environmentIntensity;\r\n\r\n\t\t\t\t// lighting\r\n\t\t\t\tuniform sampler2DArray iesProfiles;\r\n\t\t\t\tuniform LightsInfo lights;\r\n\r\n\t\t\t\t// background\r\n\t\t\t\tuniform float backgroundBlur;\r\n\t\t\t\tuniform float backgroundAlpha;\r\n\t\t\t\t#if FEATURE_BACKGROUND_MAP\r\n\r\n\t\t\t\tuniform sampler2D backgroundMap;\r\n\t\t\t\tuniform mat4 backgroundRotation;\r\n\t\t\t\tuniform float backgroundIntensity;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// camera\r\n\t\t\t\tuniform mat4 cameraWorldMatrix;\r\n\t\t\t\tuniform mat4 invProjectionMatrix;\r\n\t\t\t\t#if FEATURE_DOF\r\n\r\n\t\t\t\tuniform PhysicalCamera physicalCamera;\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// geometry\r\n\t\t\t\tuniform sampler2DArray attributesArray;\r\n\t\t\t\tuniform usampler2D materialIndexAttribute;\r\n\t\t\t\tuniform sampler2D materials;\r\n\t\t\t\tuniform sampler2DArray textures;\r\n\t\t\t\tuniform BVH bvh;\r\n\r\n\t\t\t\t// path tracer\r\n\t\t\t\tuniform int bounces;\r\n\t\t\t\tuniform int transmissiveBounces;\r\n\t\t\t\tuniform float filterGlossyFactor;\r\n\t\t\t\tuniform int seed;\r\n\r\n\t\t\t\t// image\r\n\t\t\t\tuniform vec2 resolution;\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\t// globals\r\n\t\t\t\tmat3 envRotation3x3;\r\n\t\t\t\tmat3 invEnvRotation3x3;\r\n\t\t\t\tfloat lightsDenom;\r\n\r\n\t\t\t\t// sampling\r\n\t\t\t\t${ SamplingGLSL.shape_sampling_functions }\r\n\t\t\t\t${ SamplingGLSL.equirect_functions }\r\n\t\t\t\t${ SamplingGLSL.light_sampling_functions }\r\n\r\n\t\t\t\t${ PTBVHGLSL.inside_fog_volume_function }\r\n\t\t\t\t${ BSDFGLSL.ggx_functions }\r\n\t\t\t\t${ BSDFGLSL.sheen_functions }\r\n\t\t\t\t${ BSDFGLSL.iridescence_functions }\r\n\t\t\t\t${ BSDFGLSL.fog_functions }\r\n\t\t\t\t${ BSDFGLSL.bsdf_functions }\r\n\r\n\t\t\t\tfloat applyFilteredGlossy( float roughness, float accumulatedRoughness ) {\r\n\r\n\t\t\t\t\treturn clamp(\r\n\t\t\t\t\t\tmax(\r\n\t\t\t\t\t\t\troughness,\r\n\t\t\t\t\t\t\taccumulatedRoughness * filterGlossyFactor * 5.0 ),\r\n\t\t\t\t\t\t0.0,\r\n\t\t\t\t\t\t1.0\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec3 sampleBackground( vec3 direction, vec2 uv ) {\r\n\r\n\t\t\t\t\tvec3 sampleDir = sampleHemisphere( direction, uv ) * 0.5 * backgroundBlur;\r\n\r\n\t\t\t\t\t#if FEATURE_BACKGROUND_MAP\r\n\r\n\t\t\t\t\tsampleDir = normalize( mat3( backgroundRotation ) * direction + sampleDir );\r\n\t\t\t\t\treturn backgroundIntensity * sampleEquirectColor( backgroundMap, sampleDir );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\tsampleDir = normalize( envRotation3x3 * direction + sampleDir );\r\n\t\t\t\t\treturn environmentIntensity * sampleEquirectColor( envMapInfo.map, sampleDir );\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t${ RenderGLSL.render_structs }\r\n\t\t\t\t${ RenderGLSL.camera_util_functions }\r\n\t\t\t\t${ RenderGLSL.trace_scene_function }\r\n\t\t\t\t${ RenderGLSL.attenuate_hit_function }\r\n\t\t\t\t${ RenderGLSL.direct_light_contribution_function }\r\n\t\t\t\t${ RenderGLSL.get_surface_record_function }\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\t// init\r\n\t\t\t\t\trng_initialize( gl_FragCoord.xy, seed );\r\n\t\t\t\t\tsobolPixelIndex = ( uint( gl_FragCoord.x ) << 16 ) | uint( gl_FragCoord.y );\r\n\t\t\t\t\tsobolPathIndex = uint( seed );\r\n\r\n\t\t\t\t\t// get camera ray\r\n\t\t\t\t\tRay ray = getCameraRay();\r\n\r\n\t\t\t\t\t// inverse environment rotation\r\n\t\t\t\t\tenvRotation3x3 = mat3( environmentRotation );\r\n\t\t\t\t\tinvEnvRotation3x3 = inverse( envRotation3x3 );\r\n\t\t\t\t\tlightsDenom =\r\n\t\t\t\t\t\t( environmentIntensity == 0.0 || envMapInfo.totalSum == 0.0 ) && lights.count != 0u ?\r\n\t\t\t\t\t\t\tfloat( lights.count ) :\r\n\t\t\t\t\t\t\tfloat( lights.count + 1u );\r\n\r\n\t\t\t\t\t// final color\r\n\t\t\t\t\tgl_FragColor = vec4( 0, 0, 0, 1 );\r\n\r\n\t\t\t\t\t// surface results\r\n\t\t\t\t\tSurfaceHit surfaceHit;\r\n\t\t\t\t\tScatterRecord scatterRec;\r\n\r\n\t\t\t\t\t// path tracing state\r\n\t\t\t\t\tRenderState state = initRenderState();\r\n\t\t\t\t\tstate.transmissiveTraversals = transmissiveBounces;\r\n\t\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\t\tstate.fogMaterial.fogVolume = bvhIntersectFogVolumeHit(\r\n\t\t\t\t\t\tray.origin, - ray.direction,\r\n\t\t\t\t\t\tmaterialIndexAttribute, materials,\r\n\t\t\t\t\t\tstate.fogMaterial\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\tfor ( int i = 0; i < bounces; i ++ ) {\r\n\r\n\t\t\t\t\t\tsobolBounceIndex ++;\r\n\r\n\t\t\t\t\t\tstate.depth ++;\r\n\t\t\t\t\t\tstate.traversals = bounces - i;\r\n\t\t\t\t\t\tstate.firstRay = i == 0 && state.transmissiveTraversals == transmissiveBounces;\r\n\r\n\t\t\t\t\t\tint hitType = traceScene( ray, state.fogMaterial, surfaceHit );\r\n\r\n\t\t\t\t\t\t// check if we intersect any lights and accumulate the light contribution\r\n\t\t\t\t\t\t// TODO: we can add support for light surface rendering in the else condition if we\r\n\t\t\t\t\t\t// add the ability to toggle visibility of the the light\r\n\t\t\t\t\t\tif ( ! state.firstRay && ! state.transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\tLightRecord lightRec;\r\n\t\t\t\t\t\t\tfloat lightDist = hitType == NO_HIT ? INFINITY : surfaceHit.dist;\r\n\t\t\t\t\t\t\tfor ( uint i = 0u; i < lights.count; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tintersectLightAtIndex( lights.tex, ray.origin, ray.direction, i, lightRec ) &&\r\n\t\t\t\t\t\t\t\t\tlightRec.dist < lightDist\r\n\t\t\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t\t// weight the contribution\r\n\t\t\t\t\t\t\t\t\t// NOTE: Only area lights are supported for forward sampling and can be hit\r\n\t\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, lightRec.pdf / lightsDenom );\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\t\tgl_FragColor.rgb += lightRec.emission * state.throughputColor;\r\n\r\n\t\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif ( hitType == NO_HIT ) {\r\n\r\n\t\t\t\t\t\t\tif ( state.firstRay || state.transmissiveRay ) {\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += sampleBackground( ray.direction, rand2( 2 ) ) * state.throughputColor;\r\n\t\t\t\t\t\t\t\tgl_FragColor.a = backgroundAlpha;\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\t\t\t// get the PDF of the hit envmap point\r\n\t\t\t\t\t\t\t\tvec3 envColor;\r\n\t\t\t\t\t\t\t\tfloat envPdf = sampleEquirect( envRotation3x3 * ray.direction, envColor );\r\n\t\t\t\t\t\t\t\tenvPdf /= lightsDenom;\r\n\r\n\t\t\t\t\t\t\t\t// and weight the contribution\r\n\t\t\t\t\t\t\t\tfloat misWeight = misHeuristic( scatterRec.pdf, envPdf );\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb += environmentIntensity * envColor * state.throughputColor * misWeight;\r\n\r\n\t\t\t\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\t\t\tgl_FragColor.rgb +=\r\n\t\t\t\t\t\t\t\t\tenvironmentIntensity *\r\n\t\t\t\t\t\t\t\t\tsampleEquirectColor( envMapInfo.map, envRotation3x3 * ray.direction ) *\r\n\t\t\t\t\t\t\t\t\tstate.throughputColor;\r\n\r\n\t\t\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\r\n\t\t\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\t\t\tif ( hitType == FOG_HIT ) {\r\n\r\n\t\t\t\t\t\t\tmaterial = state.fogMaterial;\r\n\t\t\t\t\t\t\tstate.accumulatedRoughness += 0.2;\r\n\r\n\t\t\t\t\t\t} else if ( material.fogVolume ) {\r\n\r\n\t\t\t\t\t\t\tstate.fogMaterial = material;\r\n\t\t\t\t\t\t\tstate.fogMaterial.fogVolume = surfaceHit.side == 1.0;\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// early out if this is a matte material\r\n\t\t\t\t\t\tif ( material.matte && state.firstRay ) {\r\n\r\n\t\t\t\t\t\t\tgl_FragColor = vec4( 0.0 );\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we've determined that this is a shadow ray and we've hit an item with no shadow casting\r\n\t\t\t\t\t\t// then skip it\r\n\t\t\t\t\t\tif ( ! material.castShadow && state.isShadowRay ) {\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tSurfaceRecord surf;\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tgetSurfaceRecord(\r\n\t\t\t\t\t\t\t\tmaterial, surfaceHit, attributesArray, state.accumulatedRoughness,\r\n\t\t\t\t\t\t\t\tsurf\r\n\t\t\t\t\t\t\t) == SKIP_SURFACE\r\n\t\t\t\t\t\t) {\r\n\r\n\t\t\t\t\t\t\t// only allow a limited number of transparency discards otherwise we could\r\n\t\t\t\t\t\t\t// crash the context with too long a loop.\r\n\t\t\t\t\t\t\ti -= sign( state.transmissiveTraversals );\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals -= sign( state.transmissiveTraversals );\r\n\r\n\t\t\t\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tscatterRec = bsdfSample( - ray.direction, surf );\r\n\t\t\t\t\t\tstate.isShadowRay = scatterRec.specularPdf < rand( 4 );\r\n\r\n\t\t\t\t\t\tbool isBelowSurface = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal ) < 0.0;\r\n\t\t\t\t\t\tvec3 hitPoint = stepRayOrigin( ray.origin, ray.direction, isBelowSurface ? - surf.faceNormal : surf.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t\t\t// next event estimation\r\n\t\t\t\t\t\t#if FEATURE_MIS\r\n\r\n\t\t\t\t\t\tgl_FragColor.rgb += directLightContribution( - ray.direction, surf, state, hitPoint );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// accumulate a roughness value to offset diffuse, specular, diffuse rays that have high contribution\r\n\t\t\t\t\t\t// to a single pixel resulting in fireflies\r\n\t\t\t\t\t\t// TODO: handle transmissive surfaces\r\n\t\t\t\t\t\tif ( ! surf.volumeParticle && ! isBelowSurface ) {\r\n\r\n\t\t\t\t\t\t\t// determine if this is a rough normal or not by checking how far off straight up it is\r\n\t\t\t\t\t\t\tvec3 halfVector = normalize( - ray.direction + scatterRec.direction );\r\n\t\t\t\t\t\t\tstate.accumulatedRoughness += max(\r\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.normal ) ) ),\r\n\t\t\t\t\t\t\t\tsin( acosApprox( dot( halfVector, surf.clearcoatNormal ) ) )\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tstate.transmissiveRay = false;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// accumulate emissive color\r\n\t\t\t\t\t\tgl_FragColor.rgb += ( surf.emission * state.throughputColor );\r\n\r\n\t\t\t\t\t\t// skip the sample if our PDF or ray is impossible\r\n\t\t\t\t\t\tif ( scatterRec.pdf <= 0.0 || ! isDirectionValid( scatterRec.direction, surf.normal, surf.faceNormal ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// if we're bouncing around the inside a transmissive material then decrement\r\n\t\t\t\t\t\t// perform this separate from a bounce\r\n\t\t\t\t\t\tbool isTransmissiveRay = ! surf.volumeParticle && dot( scatterRec.direction, surf.faceNormal * surfaceHit.side ) < 0.0;\r\n\t\t\t\t\t\tif ( ( isTransmissiveRay || isBelowSurface ) && state.transmissiveTraversals > 0 ) {\r\n\r\n\t\t\t\t\t\t\tstate.transmissiveTraversals --;\r\n\t\t\t\t\t\t\ti --;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//\r\n\r\n\t\t\t\t\t\t// handle throughput color transformation\r\n\t\t\t\t\t\t// attenuate the throughput color by the medium color\r\n\t\t\t\t\t\tif ( ! surf.frontFace ) {\r\n\r\n\t\t\t\t\t\t\tstate.throughputColor *= transmissionAttenuation( surfaceHit.dist, surf.attenuationColor, surf.attenuationDistance );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t#if FEATURE_RUSSIAN_ROULETTE\r\n\r\n\t\t\t\t\t\t// russian roulette path termination\r\n\t\t\t\t\t\t// https://www.arnoldrenderer.com/research/physically_based_shader_design_in_arnold.pdf\r\n\t\t\t\t\t\tuint minBounces = 3u;\r\n\t\t\t\t\t\tfloat depthProb = float( state.depth < minBounces );\r\n\r\n\t\t\t\t\t\tfloat rrProb = luminance( state.throughputColor * scatterRec.color / scatterRec.pdf );\r\n\t\t\t\t\t\trrProb /= luminance( state.throughputColor );\r\n\t\t\t\t\t\trrProb = sqrt( rrProb );\r\n\t\t\t\t\t\trrProb = max( rrProb, depthProb );\r\n\t\t\t\t\t\trrProb = min( rrProb, 1.0 );\r\n\t\t\t\t\t\tif ( rand( 8 ) > rrProb ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// perform sample clamping here to avoid bright pixels\r\n\t\t\t\t\t\tstate.throughputColor *= min( 1.0 / rrProb, 20.0 );\r\n\r\n\t\t\t\t\t\t#endif\r\n\r\n\t\t\t\t\t\t// adjust the throughput and discard and exit if we find discard the sample if there are any NaNs\r\n\t\t\t\t\t\tstate.throughputColor *= scatterRec.color / scatterRec.pdf;\r\n\t\t\t\t\t\tif ( any( isnan( state.throughputColor ) ) || any( isinf( state.throughputColor ) ) ) {\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t//\r\n\r\n\t\t\t\t\t\t// prepare for next ray\r\n\t\t\t\t\t\tray.direction = scatterRec.direction;\r\n\t\t\t\t\t\tray.origin = hitPoint;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgl_FragColor.a *= opacity;\r\n\r\n\t\t\t\t\t#if DEBUG_MODE == 1\r\n\r\n\t\t\t\t\t// output the number of rays checked in the path and number of\r\n\t\t\t\t\t// transmissive rays encountered.\r\n\t\t\t\t\tgl_FragColor.rgb = vec3(\r\n\t\t\t\t\t\tfloat( state.depth ),\r\n\t\t\t\t\t\ttransmissiveBounces - state.transmissiveTraversals,\r\n\t\t\t\t\t\t0.0\r\n\t\t\t\t\t);\r\n\t\t\t\t\tgl_FragColor.a = 1.0;\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n","import { PhysicalCamera } from '../objects/PhysicalCamera.js';\r\nexport class PhysicalCameraUniform {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.bokehSize = 0;\r\n\t\tthis.apertureBlades = 0;\r\n\t\tthis.apertureRotation = 0;\r\n\t\tthis.focusDistance = 10;\r\n\t\tthis.anamorphicRatio = 1;\r\n\r\n\t}\r\n\r\n\tupdateFrom( camera ) {\r\n\r\n\t\tif ( camera instanceof PhysicalCamera ) {\r\n\r\n\t\t\tthis.bokehSize = camera.bokehSize;\r\n\t\t\tthis.apertureBlades = camera.apertureBlades;\r\n\t\t\tthis.apertureRotation = camera.apertureRotation;\r\n\t\t\tthis.focusDistance = camera.focusDistance;\r\n\t\t\tthis.anamorphicRatio = camera.anamorphicRatio;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.bokehSize = 0;\r\n\t\t\tthis.apertureRotation = 0;\r\n\t\t\tthis.apertureBlades = 0;\r\n\t\t\tthis.focusDistance = 10;\r\n\t\t\tthis.anamorphicRatio = 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { PerspectiveCamera } from 'three';\r\n\r\nexport class PhysicalCamera extends PerspectiveCamera {\r\n\r\n\tset bokehSize( size ) {\r\n\r\n\t\tthis.fStop = this.getFocalLength() / size;\r\n\r\n\t}\r\n\r\n\tget bokehSize() {\r\n\r\n\t\treturn this.getFocalLength() / this.fStop;\r\n\r\n\t}\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tthis.fStop = 1.4;\r\n\t\tthis.apertureBlades = 0;\r\n\t\tthis.apertureRotation = 0;\r\n\t\tthis.focusDistance = 25;\r\n\t\tthis.anamorphicRatio = 1;\r\n\r\n\t}\r\n\r\n\tcopy( source, recursive ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.fStop = source.fStop;\r\n\t\tthis.apertureBlades = source.apertureBlades;\r\n\t\tthis.apertureRotation = source.apertureRotation;\r\n\t\tthis.focusDistance = source.focusDistance;\r\n\t\tthis.anamorphicRatio = source.anamorphicRatio;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, RedFormat, LinearFilter, DataUtils, HalfFloatType, Source, RepeatWrapping, RGBAFormat, FloatType, ClampToEdgeWrapping } from 'three';\r\nimport { toHalfFloatArray } from '../utils/TextureUtils.js';\r\n\r\nfunction binarySearchFindClosestIndexOf( array, targetValue, offset = 0, count = array.length ) {\r\n\r\n\tlet lower = offset;\r\n\tlet upper = offset + count - 1;\r\n\r\n\twhile ( lower < upper ) {\r\n\r\n\t\t// calculate the midpoint for this iteration using a bitwise shift right operator to save 1 floating point multiplication\r\n\t\t// and 1 truncation from the double tilde operator to improve performance\r\n\t\t// this results in much better performance over using standard \"~ ~ ( (lower + upper) ) / 2\" to calculate the midpoint\r\n\t\tconst mid = ( lower + upper ) >> 1;\r\n\r\n\t\t// check if the middle array value is above or below the target and shift\r\n\t\t// which half of the array we're looking at\r\n\t\tif ( array[ mid ] < targetValue ) {\r\n\r\n\t\t\tlower = mid + 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tupper = mid;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn lower - offset;\r\n\r\n}\r\n\r\nfunction colorToLuminance( r, g, b ) {\r\n\r\n\t// https://en.wikipedia.org/wiki/Relative_luminance\r\n\treturn 0.2126 * r + 0.7152 * g + 0.0722 * b;\r\n\r\n}\r\n\r\n// ensures the data is all floating point values and flipY is false\r\nfunction preprocessEnvMap( envMap, targetType = HalfFloatType ) {\r\n\r\n\tconst map = envMap.clone();\r\n\tmap.source = new Source( { ...map.image } );\r\n\tconst { width, height, data } = map.image;\r\n\r\n\t// TODO: is there a simple way to avoid cloning and adjusting the env map data here?\r\n\t// convert the data from half float uint 16 arrays to float arrays for cdf computation\r\n\tlet newData = data;\r\n\tif ( map.type !== targetType ) {\r\n\r\n\t\tif ( targetType === HalfFloatType ) {\r\n\r\n\t\t\tnewData = new Uint16Array( data.length );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tnewData = new Float32Array( data.length );\r\n\r\n\t\t}\r\n\r\n\t\tlet maxIntValue;\r\n\t\tif ( data instanceof Int8Array || data instanceof Int16Array || data instanceof Int32Array ) {\r\n\r\n\t\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT - 1 ) - 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaxIntValue = 2 ** ( 8 * data.BYTES_PER_ELEMENT ) - 1;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, l = data.length; i < l; i ++ ) {\r\n\r\n\t\t\tlet v = data[ i ];\r\n\t\t\tif ( map.type === HalfFloatType ) {\r\n\r\n\t\t\t\tv = DataUtils.fromHalfFloat( data[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( map.type !== FloatType && map.type !== HalfFloatType ) {\r\n\r\n\t\t\t\tv /= maxIntValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( targetType === HalfFloatType ) {\r\n\r\n\t\t\t\tnewData[ i ] = DataUtils.toHalfFloat( v );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmap.image.data = newData;\r\n\t\tmap.type = targetType;\r\n\r\n\t}\r\n\r\n\t// remove any y flipping for cdf computation\r\n\tif ( map.flipY ) {\r\n\r\n\t\tconst ogData = newData;\r\n\t\tnewData = newData.slice();\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst newY = height - y - 1;\r\n\t\t\t\tconst ogIndex = 4 * ( y * width + x );\r\n\t\t\t\tconst newIndex = 4 * ( newY * width + x );\r\n\r\n\t\t\t\tnewData[ newIndex + 0 ] = ogData[ ogIndex + 0 ];\r\n\t\t\t\tnewData[ newIndex + 1 ] = ogData[ ogIndex + 1 ];\r\n\t\t\t\tnewData[ newIndex + 2 ] = ogData[ ogIndex + 2 ];\r\n\t\t\t\tnewData[ newIndex + 3 ] = ogData[ ogIndex + 3 ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tmap.flipY = false;\r\n\t\tmap.image.data = newData;\r\n\r\n\t}\r\n\r\n\treturn map;\r\n\r\n}\r\n\r\nexport class EquirectHdrInfoUniform {\r\n\r\n\tconstructor() {\r\n\r\n\t\t// Default to a white texture and associated weights so we don't\r\n\t\t// just render black initially.\r\n\t\tconst blackTex = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 0, 0 ] ) ), 1, 1 );\r\n\t\tblackTex.type = HalfFloatType;\r\n\t\tblackTex.format = RGBAFormat;\r\n\t\tblackTex.minFilter = LinearFilter;\r\n\t\tblackTex.magFilter = LinearFilter;\r\n\t\tblackTex.wrapS = RepeatWrapping;\r\n\t\tblackTex.wrapT = RepeatWrapping;\r\n\t\tblackTex.generateMipmaps = false;\r\n\t\tblackTex.needsUpdate = true;\r\n\r\n\t\t// Stores a map of [0, 1] value -> cumulative importance row & pdf\r\n\t\t// used to sampling a random value to a relevant row to sample from\r\n\t\tconst marginalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 1 ] ) ), 1, 2 );\r\n\t\tmarginalWeights.type = HalfFloatType;\r\n\t\tmarginalWeights.format = RedFormat;\r\n\t\tmarginalWeights.minFilter = LinearFilter;\r\n\t\tmarginalWeights.magFilter = LinearFilter;\r\n\t\tmarginalWeights.generateMipmaps = false;\r\n\t\tmarginalWeights.needsUpdate = true;\r\n\r\n\t\t// Stores a map of [0, 1] value -> cumulative importance column & pdf\r\n\t\t// used to sampling a random value to a relevant pixel to sample from\r\n\t\tconst conditionalWeights = new DataTexture( toHalfFloatArray( new Float32Array( [ 0, 0, 1, 1 ] ) ), 2, 2 );\r\n\t\tconditionalWeights.type = HalfFloatType;\r\n\t\tconditionalWeights.format = RedFormat;\r\n\t\tconditionalWeights.minFilter = LinearFilter;\r\n\t\tconditionalWeights.magFilter = LinearFilter;\r\n\t\tconditionalWeights.generateMipmaps = false;\r\n\t\tconditionalWeights.needsUpdate = true;\r\n\r\n\t\tthis.map = blackTex;\r\n\t\tthis.marginalWeights = marginalWeights;\r\n\t\tthis.conditionalWeights = conditionalWeights;\r\n\t\tthis.totalSum = 0;\r\n\r\n\t\t// TODO: Add support for float or half float types here. We need to pass this into\r\n\t\t// the preprocess function and ensure our CDF and MDF textures are appropriately sized\r\n\t\t// Ideally we wouldn't upscale a bit depth if we didn't need to.\r\n\t\t// this.type = HalfFloatType;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.marginalWeights.dispose();\r\n\t\tthis.conditionalWeights.dispose();\r\n\t\tthis.map.dispose();\r\n\r\n\t}\r\n\r\n\tupdateFrom( hdr ) {\r\n\r\n\t\t// https://github.com/knightcrawler25/GLSL-PathTracer/blob/3c6fd9b6b3da47cd50c527eeb45845eef06c55c3/src/loaders/hdrloader.cpp\r\n\t\t// https://pbr-book.org/3ed-2018/Light_Transport_I_Surface_Reflection/Sampling_Light_Sources#InfiniteAreaLights\r\n\t\tconst map = preprocessEnvMap( hdr );\r\n\t\tmap.wrapS = RepeatWrapping;\r\n\t\tmap.wrapT = ClampToEdgeWrapping;\r\n\r\n\t\tconst { width, height, data } = map.image;\r\n\r\n\t\t// \"conditional\" = \"pixel relative to row pixels sum\"\r\n\t\t// \"marginal\" = \"row relative to row sum\"\r\n\r\n\t\t// track the importance of any given pixel in the image by tracking its weight relative to other pixels in the image\r\n\t\tconst pdfConditional = new Float32Array( width * height );\r\n\t\tconst cdfConditional = new Float32Array( width * height );\r\n\r\n\t\tconst pdfMarginal = new Float32Array( height );\r\n\t\tconst cdfMarginal = new Float32Array( height );\r\n\r\n\t\tlet totalSumValue = 0.0;\r\n\t\tlet cumulativeWeightMarginal = 0.0;\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tlet cumulativeRowWeight = 0.0;\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst r = DataUtils.fromHalfFloat( data[ 4 * i + 0 ] );\r\n\t\t\t\tconst g = DataUtils.fromHalfFloat( data[ 4 * i + 1 ] );\r\n\t\t\t\tconst b = DataUtils.fromHalfFloat( data[ 4 * i + 2 ] );\r\n\r\n\t\t\t\t// the probability of the pixel being selected in this row is the\r\n\t\t\t\t// scale of the luminance relative to the rest of the pixels.\r\n\t\t\t\t// TODO: this should also account for the solid angle of the pixel when sampling\r\n\t\t\t\tconst weight = colorToLuminance( r, g, b );\r\n\t\t\t\tcumulativeRowWeight += weight;\r\n\t\t\t\ttotalSumValue += weight;\r\n\r\n\t\t\t\tpdfConditional[ i ] = weight;\r\n\t\t\t\tcdfConditional[ i ] = cumulativeRowWeight;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// can happen if the row is all black\r\n\t\t\tif ( cumulativeRowWeight !== 0 ) {\r\n\r\n\t\t\t\t// scale the pdf and cdf to [0.0, 1.0]\r\n\t\t\t\tfor ( let i = y * width, l = y * width + width; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tpdfConditional[ i ] /= cumulativeRowWeight;\r\n\t\t\t\t\tcdfConditional[ i ] /= cumulativeRowWeight;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcumulativeWeightMarginal += cumulativeRowWeight;\r\n\r\n\t\t\t// compute the marginal pdf and cdf along the height of the map.\r\n\t\t\tpdfMarginal[ y ] = cumulativeRowWeight;\r\n\t\t\tcdfMarginal[ y ] = cumulativeWeightMarginal;\r\n\r\n\t\t}\r\n\r\n\t\t// can happen if the texture is all black\r\n\t\tif ( cumulativeWeightMarginal !== 0 ) {\r\n\r\n\t\t\t// scale the marginal pdf and cdf to [0.0, 1.0]\r\n\t\t\tfor ( let i = 0, l = pdfMarginal.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tpdfMarginal[ i ] /= cumulativeWeightMarginal;\r\n\t\t\t\tcdfMarginal[ i ] /= cumulativeWeightMarginal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compute a sorted index of distributions and the probabilities along them for both\r\n\t\t// the marginal and conditional data. These will be used to sample with a random number\r\n\t\t// to retrieve a uv value to sample in the environment map.\r\n\t\t// These values continually increase so it's okay to interpolate between them.\r\n\t\tconst marginalDataArray = new Uint16Array( height );\r\n\t\tconst conditionalDataArray = new Uint16Array( width * height );\r\n\r\n\t\t// we add a half texel offset so we're sampling the center of the pixel\r\n\t\tfor ( let i = 0; i < height; i ++ ) {\r\n\r\n\t\t\tconst dist = ( i + 1 ) / height;\r\n\t\t\tconst row = binarySearchFindClosestIndexOf( cdfMarginal, dist );\r\n\r\n\t\t\tmarginalDataArray[ i ] = DataUtils.toHalfFloat( ( row + 0.5 ) / height );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst dist = ( x + 1 ) / width;\r\n\t\t\t\tconst col = binarySearchFindClosestIndexOf( cdfConditional, dist, y * width, width );\r\n\r\n\t\t\t\tconditionalDataArray[ i ] = DataUtils.toHalfFloat( ( col + 0.5 ) / width );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.dispose();\r\n\r\n\t\tconst { marginalWeights, conditionalWeights } = this;\r\n\t\tmarginalWeights.image = { width: height, height: 1, data: marginalDataArray };\r\n\t\tmarginalWeights.needsUpdate = true;\r\n\r\n\t\tconditionalWeights.image = { width, height, data: conditionalDataArray };\r\n\t\tconditionalWeights.needsUpdate = true;\r\n\r\n\t\tthis.totalSum = totalSumValue;\r\n\t\tthis.map = map;\r\n\r\n\t}\r\n\r\n}\r\n","import { DataUtils } from 'three';\r\n\r\n\r\nexport function toHalfFloatArray( f32Array ) {\r\n\r\n\tconst f16Array = new Uint16Array( f32Array.length );\r\n\tfor ( let i = 0, n = f32Array.length; i < n; ++ i ) {\r\n\r\n\t\tf16Array[ i ] = DataUtils.toHalfFloat( f32Array[ i ] );\r\n\r\n\t}\r\n\r\n\treturn f16Array;\r\n\r\n}\r\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, Vector3, Quaternion, Matrix4, NearestFilter } from 'three';\r\nimport { bufferToHash } from '../utils/bufferToHash.js';\r\n\r\nconst LIGHT_PIXELS = 6;\r\nconst RECT_AREA_LIGHT = 0;\r\nconst CIRC_AREA_LIGHT = 1;\r\nconst SPOT_LIGHT = 2;\r\nconst DIR_LIGHT = 3;\r\nconst POINT_LIGHT = 4;\r\n\r\nconst u = new Vector3();\r\nconst v = new Vector3();\r\nconst m = new Matrix4();\r\nconst worldQuaternion = new Quaternion();\r\nconst eye = new Vector3();\r\nconst target = new Vector3();\r\nconst up = new Vector3( 0, 1, 0 );\r\nexport class LightsInfoUniformStruct {\r\n\r\n\tconstructor() {\r\n\r\n\t\tconst tex = new DataTexture( new Float32Array( 4 ), 1, 1 );\r\n\t\ttex.format = RGBAFormat;\r\n\t\ttex.type = FloatType;\r\n\t\ttex.wrapS = ClampToEdgeWrapping;\r\n\t\ttex.wrapT = ClampToEdgeWrapping;\r\n\t\ttex.generateMipmaps = false;\r\n\t\ttex.minFilter = NearestFilter;\r\n\t\ttex.magFilter = NearestFilter;\r\n\r\n\t\tthis.tex = tex;\r\n\t\tthis.count = 0;\r\n\r\n\t}\r\n\r\n\tupdateFrom( lights, iesTextures = [] ) {\r\n\r\n\t\tconst tex = this.tex;\r\n\t\tconst pixelCount = Math.max( lights.length * LIGHT_PIXELS, 1 );\r\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) );\r\n\r\n\t\tif ( tex.image.width !== dimension ) {\r\n\r\n\t\t\ttex.dispose();\r\n\r\n\t\t\ttex.image.data = new Float32Array( dimension * dimension * 4 );\r\n\t\t\ttex.image.width = dimension;\r\n\t\t\ttex.image.height = dimension;\r\n\r\n\t\t}\r\n\r\n\t\tconst floatArray = tex.image.data;\r\n\r\n\t\tfor ( let i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst l = lights[ i ];\r\n\r\n\t\t\tconst baseIndex = i * LIGHT_PIXELS * 4;\r\n\t\t\tlet index = 0;\r\n\r\n\t\t\t// initialize to 0\r\n\t\t\tfor ( let p = 0; p < LIGHT_PIXELS * 4; p ++ ) {\r\n\r\n\t\t\t\tfloatArray[ baseIndex + p ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 1\r\n\t\t    // position\r\n\t\t\tl.getWorldPosition( v );\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t// type\r\n\t\t\tlet type = RECT_AREA_LIGHT;\r\n\t\t\tif ( l.isRectAreaLight && l.isCircular ) {\r\n\r\n\t\t\t\ttype = CIRC_AREA_LIGHT;\r\n\r\n\t\t\t} else if ( l.isSpotLight ) {\r\n\r\n\t\t\t\ttype = SPOT_LIGHT;\r\n\r\n\t\t\t} else if ( l.isDirectionalLight ) {\r\n\r\n\t\t\t\ttype = DIR_LIGHT;\r\n\r\n\t\t\t} else if ( l.isPointLight ) {\r\n\r\n\t\t\t\ttype = POINT_LIGHT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = type;\r\n\r\n\t\t\t// sample 2\r\n\t\t\t// color\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.r;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.g;\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.color.b;\r\n\r\n\t\t\t// intensity\r\n\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.intensity;\r\n\r\n\t\t\tl.getWorldQuaternion( worldQuaternion );\r\n\r\n\t\t\tif ( l.isRectAreaLight ) {\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tu.set( l.width, 0, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\t// v vector\r\n\t\t\t\tv.set( 0, l.height, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t\t// area\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.cross( v ).length() * ( l.isCircular ? ( Math.PI / 4.0 ) : 1.0 );\r\n\r\n\t\t\t} else if ( l.isSpotLight ) {\r\n\r\n\t\t\t\tconst radius = l.radius || 0;\r\n\t\t\t\teye.setFromMatrixPosition( l.matrixWorld );\r\n\t\t\t\ttarget.setFromMatrixPosition( l.target.matrixWorld );\r\n\t\t\t\tm.lookAt( eye, target, up );\r\n\t\t\t\tworldQuaternion.setFromRotationMatrix( m );\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tu.set( 1, 0, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = u.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\t// v vector\r\n\t\t\t\tv.set( 0, 1, 0 ).applyQuaternion( worldQuaternion );\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = v.z;\r\n\r\n\t\t\t\t// area\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.PI * radius * radius;\r\n\r\n\t\t\t\t// sample 5\r\n\t\t\t\t// radius\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = radius;\r\n\r\n\t\t\t\t// decay\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\r\n\r\n\t\t\t\t// distance\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\r\n\r\n\t\t\t\t// coneCos\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle );\r\n\r\n\t\t\t\t// sample 6\r\n\t\t\t\t// penumbraCos\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = Math.cos( l.angle * ( 1 - l.penumbra ) );\r\n\r\n\t\t\t\t// iesProfile\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.iesMap ? iesTextures.indexOf( l.iesMap ) : - 1;\r\n\r\n\t\t\t} else if ( l.isPointLight ) {\r\n\r\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = worldPosition.z;\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t\t// sample 4\r\n\t\t\t\tindex += 4;\r\n\r\n\t\t\t\t// sample 5\r\n\t\t\t\tindex += 1;\r\n\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.decay;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = l.distance;\r\n\r\n\t\t\t} else if ( l.isDirectionalLight ) {\r\n\r\n\t\t\t\tconst worldPosition = u.setFromMatrixPosition( l.matrixWorld );\r\n\t\t\t\tconst targetPosition = v.setFromMatrixPosition( l.target.matrixWorld );\r\n\t\t\t\ttarget.subVectors( worldPosition, targetPosition ).normalize();\r\n\r\n\t\t\t\t// sample 3\r\n\t\t\t\t// u vector\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.x;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.y;\r\n\t\t\t\tfloatArray[ baseIndex + ( index ++ ) ] = target.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.count = lights.length;\r\n\r\n\t\tconst hash = bufferToHash( floatArray.buffer );\r\n\t\tif ( this.hash !== hash ) {\r\n\r\n\t\t\tthis.hash = hash;\r\n\t\t\ttex.needsUpdate = true;\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n","import { FloatAttributeTextureArray } from './FloatAttributeTextureArray.js';\r\n\r\nexport class AttributesTextureArray extends FloatAttributeTextureArray {\r\n\r\n\tupdateNormalAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 0, attr );\r\n\r\n\t}\r\n\r\n\tupdateTangentAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 1, attr );\r\n\r\n\t}\r\n\r\n\tupdateUvAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 2, attr );\r\n\r\n\t}\r\n\r\n\tupdateColorAttribute( attr ) {\r\n\r\n\t\tthis.updateAttribute( 3, attr );\r\n\r\n\t}\r\n\r\n\tupdateFrom( normal, tangent, uv, color ) {\r\n\r\n\t\tthis.setAttributes( [ normal, tangent, uv, color ] );\r\n\r\n\t}\r\n\r\n}\r\n","import { DataArrayTexture, FloatType, RGBAFormat } from 'three';\r\nimport { FloatVertexAttributeTexture } from 'three-mesh-bvh';\r\n\r\nfunction copyArrayToArray( fromArray, fromStride, toArray, toStride, offset ) {\r\n\r\n\tif ( fromStride > toStride ) {\r\n\r\n\t\tthrow new Error();\r\n\r\n\t}\r\n\r\n\t// scale non-float values to their normalized range\r\n\tconst count = fromArray.length / fromStride;\r\n\tconst bpe = fromArray.constructor.BYTES_PER_ELEMENT * 8;\r\n\tlet maxValue = 1.0;\r\n\tswitch ( fromArray.constructor ) {\r\n\r\n\tcase Uint8Array:\r\n\tcase Uint16Array:\r\n\tcase Uint32Array:\r\n\t\tmaxValue = 2 ** bpe - 1;\r\n\t\tbreak;\r\n\r\n\tcase Int8Array:\r\n\tcase Int16Array:\r\n\tcase Int32Array:\r\n\t\tmaxValue = 2 ** ( bpe - 1 ) - 1;\r\n\t\tbreak;\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\tconst i4 = 4 * i;\r\n\t\tconst is = fromStride * i;\r\n\t\tfor ( let j = 0; j < toStride; j ++ ) {\r\n\r\n\t\t\ttoArray[ offset + i4 + j ] = fromStride >= j + 1 ? fromArray[ is + j ] / maxValue : 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class FloatAttributeTextureArray extends DataArrayTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis._textures = [];\r\n\t\tthis.type = FloatType;\r\n\t\tthis.format = RGBAFormat;\r\n\t\tthis.internalFormat = 'RGBA32F';\r\n\r\n\t}\r\n\r\n\tupdateAttribute( index, attr ) {\r\n\r\n\t\t// update the texture\r\n\t\tconst tex = this._textures[ index ];\r\n\t\ttex.updateFrom( attr );\r\n\r\n\t\t// ensure compatibility\r\n\t\tconst baseImage = tex.image;\r\n\t\tconst image = this.image;\r\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height ) {\r\n\r\n\t\t\tthrow new Error( 'FloatAttributeTextureArray: Attribute must be the same dimensions when updating single layer.' );\r\n\r\n\t\t}\r\n\r\n\t\t// update the image\r\n\t\tconst { width, height, data } = image;\r\n\t\tconst length = width * height * 4;\r\n\t\tconst offset = length * index;\r\n\t\tlet itemSize = attr.itemSize;\r\n\t\tif ( itemSize === 3 ) {\r\n\r\n\t\t\titemSize = 4;\r\n\r\n\t\t}\r\n\r\n\t\t// copy the data\r\n\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\r\n\r\n\t\tthis.dispose();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tsetAttributes( attrs ) {\r\n\r\n\t\t// ensure the attribute count\r\n\t\tconst itemCount = attrs[ 0 ].count;\r\n\t\tconst attrsLength = attrs.length;\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\tif ( attrs[ i ].count !== itemCount ) {\r\n\r\n\t\t\t\tthrow new Error( 'FloatAttributeTextureArray: All attributes must have the same item count.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// initialize all textures\r\n\t\tconst textures = this._textures;\r\n\t\twhile ( textures.length < attrsLength ) {\r\n\r\n\t\t\tconst tex = new FloatVertexAttributeTexture();\r\n\t\t\ttextures.push( tex );\r\n\r\n\t\t}\r\n\r\n\t\twhile ( textures.length > attrsLength ) {\r\n\r\n\t\t\ttextures.pop();\r\n\r\n\t\t}\r\n\r\n\t\t// update all textures\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\ttextures[ i ].updateFrom( attrs[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// determine if we need to create a new array\r\n\t\tconst baseTexture = textures[ 0 ];\r\n\t\tconst baseImage = baseTexture.image;\r\n\t\tconst image = this.image;\r\n\r\n\t\tif ( baseImage.width !== image.width || baseImage.height !== image.height || baseImage.depth !== attrsLength ) {\r\n\r\n\t\t\timage.width = baseImage.width;\r\n\t\t\timage.height = baseImage.height;\r\n\t\t\timage.depth = attrsLength;\r\n\t\t\timage.data = new Float32Array( image.width * image.height * image.depth * 4 );\r\n\r\n\t\t}\r\n\r\n\t\t// copy the other texture data into the data array texture\r\n\t\tconst { data, width, height } = image;\r\n\t\tfor ( let i = 0, l = attrsLength; i < l; i ++ ) {\r\n\r\n\t\t\tconst tex = textures[ i ];\r\n\t\t\tconst length = width * height * 4;\r\n\t\t\tconst offset = length * i;\r\n\r\n\t\t\tlet itemSize = attrs[ i ].itemSize;\r\n\t\t\tif ( itemSize === 3 ) {\r\n\r\n\t\t\t\titemSize = 4;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcopyArrayToArray( tex.image.data, itemSize, data, 4, offset );\r\n\r\n\t\t}\r\n\r\n\t\t// reset the texture\r\n\t\tthis.dispose();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\r\n}\r\n","import { DataTexture, RGBAFormat, ClampToEdgeWrapping, FloatType, FrontSide, BackSide, DoubleSide, NearestFilter } from 'three';\r\nimport { getTextureHash } from '../core/utils/sceneUpdateUtils.js';\r\nimport { bufferToHash } from '../utils/bufferToHash.js';\r\n\r\nexport const MATERIAL_PIXELS = 47;\r\nconst MATERIAL_STRIDE = MATERIAL_PIXELS * 4;\r\n\r\nclass MaterialFeatures {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis._features = {};\r\n\r\n\t}\r\n\r\n\tisUsed( feature ) {\r\n\r\n\t\treturn feature in this._features;\r\n\r\n\t}\r\n\r\n\tsetUsed( feature, used = true ) {\r\n\r\n\t\tif ( used === false ) {\r\n\r\n\t\t\tdelete this._features[ feature ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._features[ feature ] = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis._features = {};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class MaterialsTexture extends DataTexture {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( new Float32Array( 4 ), 1, 1 );\r\n\r\n\t\tthis.format = RGBAFormat;\r\n\t\tthis.type = FloatType;\r\n\t\tthis.wrapS = ClampToEdgeWrapping;\r\n\t\tthis.wrapT = ClampToEdgeWrapping;\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\t\tthis.generateMipmaps = false;\r\n\t\tthis.features = new MaterialFeatures();\r\n\r\n\t}\r\n\r\n\tupdateFrom( materials, textures ) {\r\n\r\n\t\tfunction getTexture( material, key, def = - 1 ) {\r\n\r\n\t\t\tif ( key in material && material[ key ] ) {\r\n\r\n\t\t\t\tconst hash = getTextureHash( material[ key ] );\r\n\t\t\t\treturn textureLookUp[ hash ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn def;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction getField( material, key, def ) {\r\n\r\n\t\t\treturn key in material ? material[ key ] : def;\r\n\r\n\t\t}\r\n\r\n\t\tfunction writeTextureMatrixToArray( material, textureKey, array, offset ) {\r\n\r\n\t\t\tconst texture = material[ textureKey ] && material[ textureKey ].isTexture ? material[ textureKey ] : null;\r\n\r\n\t\t\t// check if texture exists\r\n\t\t\tif ( texture ) {\r\n\r\n\t\t\t\tif ( texture.matrixAutoUpdate ) {\r\n\r\n\t\t\t\t\ttexture.updateMatrix();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst elements = texture.matrix.elements;\r\n\r\n\t\t\t\tlet i = 0;\r\n\r\n\t\t\t\t// first row\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 0 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 3 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 6 ];\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t\t// second row\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 1 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 4 ];\r\n\t\t\t\tarray[ offset + i ++ ] = elements[ 7 ];\r\n\t\t\t\ti ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn 8;\r\n\r\n\t\t}\r\n\r\n\t\tlet index = 0;\r\n\t\tconst pixelCount = materials.length * MATERIAL_PIXELS;\r\n\t\tconst dimension = Math.ceil( Math.sqrt( pixelCount ) ) || 1;\r\n\t\tconst { image, features } = this;\r\n\r\n\t\t// index the list of textures based on shareable source\r\n\t\tconst textureLookUp = {};\r\n\t\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\r\n\r\n\t\t\ttextureLookUp[ getTextureHash( textures[ i ] ) ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tif ( image.width !== dimension ) {\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t\timage.data = new Float32Array( dimension * dimension * 4 );\r\n\t\t\timage.width = dimension;\r\n\t\t\timage.height = dimension;\r\n\r\n\t\t}\r\n\r\n\t\tconst floatArray = image.data;\r\n\r\n\t\t// on some devices (Google Pixel 6) the \"floatBitsToInt\" function does not work correctly so we\r\n\t\t// can't encode texture ids that way.\r\n\t\t// const intArray = new Int32Array( floatArray.buffer );\r\n\r\n\t\tfeatures.reset();\r\n\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst m = materials[ i ];\r\n\r\n\t\t\tif ( m.isFogVolumeMaterial ) {\r\n\r\n\t\t\t\tfeatures.setUsed( 'FOG' );\r\n\r\n\t\t\t\tfor ( let j = 0; j < MATERIAL_STRIDE; j ++ ) {\r\n\r\n\t\t\t\t\tfloatArray[ index + j ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// sample 0 .rgb\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 0 ] = m.color.r;\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 1 ] = m.color.g;\r\n\t\t\t\tfloatArray[ index + 0 * 4 + 2 ] = m.color.b;\r\n\r\n\t\t\t\t// sample 2 .a\r\n\t\t\t\tfloatArray[ index + 2 * 4 + 3 ] = getField( m, 'emissiveIntensity', 0.0 );\r\n\r\n\t\t\t\t// sample 3 .rgb\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 0 ] = m.emissive.r;\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 1 ] = m.emissive.g;\r\n\t\t\t\tfloatArray[ index + 3 * 4 + 2 ] = m.emissive.b;\r\n\r\n\t\t\t\t// sample 13 .g\r\n\t\t\t\t// reusing opacity field\r\n\t\t\t\tfloatArray[ index + 13 * 4 + 1 ] = m.density;\r\n\r\n\t\t\t\t// side\r\n\t\t\t\tfloatArray[ index + 13 * 4 + 3 ] = 0.0;\r\n\r\n\t\t\t\t// sample 14 .b\r\n\t\t\t\tfloatArray[ index + 14 * 4 + 2 ] = 1 << 2;\r\n\r\n\t\t\t\tindex += MATERIAL_STRIDE;\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 0\r\n\t\t\t// color\r\n\t\t\tfloatArray[ index ++ ] = m.color.r;\r\n\t\t\tfloatArray[ index ++ ] = m.color.g;\r\n\t\t\tfloatArray[ index ++ ] = m.color.b;\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'map' );\r\n\r\n\t\t\t// sample 1\r\n\t\t\t// metalness & roughness\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'metalness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'metalnessMap' );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'roughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'roughnessMap' );\r\n\r\n\t\t\t// sample 2\r\n\t\t\t// transmission & emissiveIntensity\r\n\t\t\t// three.js assumes a default f0 of 0.04 if no ior is provided which equates to an ior of 1.5\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'ior', 1.5 );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'transmission', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'transmissionMap' );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'emissiveIntensity', 0.0 );\r\n\r\n\t\t\t// sample 3\r\n\t\t\t// emission\r\n\t\t\tif ( 'emissive' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.emissive.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'emissiveMap' );\r\n\r\n\t\t\t// sample 4\r\n\t\t\t// normals\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'normalMap' );\r\n\t\t\tif ( 'normalScale' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.x;\r\n\t\t\t\tfloatArray[ index ++ ] = m.normalScale.y;\r\n\r\n \t\t\t} else {\r\n\r\n \t\t\t\tfloatArray[ index ++ ] = 1;\r\n \t\t\t\tfloatArray[ index ++ ] = 1;\r\n\r\n \t\t\t}\r\n\r\n\t\t\t// clearcoat\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoat', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatMap' ); // sample 5\r\n\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'clearcoatRoughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatRoughnessMap' );\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'clearcoatNormalMap' );\r\n\r\n\t\t\t// sample 6\r\n\t\t\tif ( 'clearcoatNormalScale' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.x;\r\n\t\t\t\tfloatArray[ index ++ ] = m.clearcoatNormalScale.y;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex ++;\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheen', 0.0 );\r\n\r\n\t\t\t// sample 7\r\n\t\t\t// sheen\r\n\t\t\tif ( 'sheenColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.sheenColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenColorMap' );\r\n\r\n\t\t\t// sample 8\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'sheenRoughness', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'sheenRoughnessMap' );\r\n\r\n\t\t\t// iridescence\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceMap' );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'iridescenceThicknessMap' );\r\n\r\n\t\t\t// sample 9\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescence', 0.0 );\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'iridescenceIOR', 1.3 );\r\n\r\n\t\t\tconst iridescenceThicknessRange = getField( m, 'iridescenceThicknessRange', [ 100, 400 ] );\r\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 0 ];\r\n\t\t\tfloatArray[ index ++ ] = iridescenceThicknessRange[ 1 ];\r\n\r\n\t\t\t// sample 10\r\n\t\t\t// specular color\r\n\t\t\tif ( 'specularColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.specularColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularColorMap' );\r\n\r\n\t\t\t// sample 11\r\n\t\t\t// specular intensity\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'specularIntensity', 1.0 );\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'specularIntensityMap' );\r\n\r\n\t\t\t// isThinFilm\r\n\t\t\tconst isThinFilm = getField( m, 'thickness', 0.0 ) === 0.0 && getField( m, 'attenuationDistance', Infinity ) === Infinity;\r\n\t\t\tfloatArray[ index ++ ] = Number( isThinFilm );\r\n\t\t\tindex ++;\r\n\r\n\t\t\t// sample 12\r\n\t\t\tif ( 'attenuationColor' in m ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.r;\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.g;\r\n\t\t\t\tfloatArray[ index ++ ] = m.attenuationColor.b;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\t\t\t\tfloatArray[ index ++ ] = 1.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfloatArray[ index ++ ] = getField( m, 'attenuationDistance', Infinity );\r\n\r\n\t\t\t// sample 13\r\n\t\t\t// alphaMap\r\n\t\t\tfloatArray[ index ++ ] = getTexture( m, 'alphaMap' );\r\n\r\n\t\t\t// side & matte\r\n\t\t\tfloatArray[ index ++ ] = m.opacity;\r\n\t\t\tfloatArray[ index ++ ] = m.alphaTest;\r\n\t\t\tif ( ! isThinFilm && m.transmission > 0.0 ) {\r\n\r\n\t\t\t\tfloatArray[ index ++ ] = 0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tswitch ( m.side ) {\r\n\r\n\t\t\t\tcase FrontSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase BackSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = - 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase DoubleSide:\r\n\t\t\t\t\tfloatArray[ index ++ ] = 0;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// sample 14\r\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'matte', false ) ); // matte\r\n\t\t\tfloatArray[ index ++ ] = Number( getField( m, 'castShadow', true ) ); // shadow\r\n\t\t\tfloatArray[ index ++ ] = Number( m.vertexColors ) | ( Number( m.flatShading ) << 1 ); // vertexColors & flatShading\r\n\t\t\tfloatArray[ index ++ ] = Number( m.transparent ); // transparent\r\n\r\n\t\t\t// map transform 15\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'map', floatArray, index );\r\n\r\n\t\t\t// metalnessMap transform 17\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'metalnessMap', floatArray, index );\r\n\r\n\t\t\t// roughnessMap transform 19\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'roughnessMap', floatArray, index );\r\n\r\n\t\t\t// transmissionMap transform 21\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'transmissionMap', floatArray, index );\r\n\r\n\t\t\t// emissiveMap transform 22\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'emissiveMap', floatArray, index );\r\n\r\n\t\t\t// normalMap transform 25\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'normalMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatMap transform 27\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatNormalMap transform 29\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatNormalMap', floatArray, index );\r\n\r\n\t\t\t// clearcoatRoughnessMap transform 31\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'clearcoatRoughnessMap', floatArray, index );\r\n\r\n\t\t\t// sheenColorMap transform 33\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenColorMap', floatArray, index );\r\n\r\n\t\t\t// sheenRoughnessMap transform 35\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'sheenRoughnessMap', floatArray, index );\r\n\r\n\t\t\t// iridescenceMap transform 37\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceMap', floatArray, index );\r\n\r\n\t\t\t// iridescenceThicknessMap transform 39\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'iridescenceThicknessMap', floatArray, index );\r\n\r\n\t\t\t// specularColorMap transform 41\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularColorMap', floatArray, index );\r\n\r\n\t\t\t// specularIntensityMap transform 43\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'specularIntensityMap', floatArray, index );\r\n\r\n\t\t\t// alphaMap transform 45\r\n\t\t\tindex += writeTextureMatrixToArray( m, 'alphaMap', floatArray, index );\r\n\r\n\t\t}\r\n\r\n\t\t// check if the contents have changed\r\n\t\tconst hash = bufferToHash( floatArray.buffer );\r\n\t\tif ( this.hash !== hash ) {\r\n\r\n\t\t\tthis.hash = hash;\r\n\t\t\tthis.needsUpdate = true;\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n","function uuidSort( a, b ) {\r\n\r\n\tif ( a.uuid < b.uuid ) return 1;\r\n\tif ( a.uuid > b.uuid ) return - 1;\r\n\treturn 0;\r\n\r\n}\r\n\r\n// we must hash the texture to determine uniqueness using the encoding, as well, because the\r\n// when rendering each texture to the texture array they must have a consistent color space.\r\nexport function getTextureHash( t ) {\r\n\r\n\treturn `${ t.source.uuid }:${ t.colorSpace }`;\r\n\r\n}\r\n\r\n// reduce the set of textures to just those with a unique source while retaining\r\n// the order of the textures.\r\nfunction reduceTexturesToUniqueSources( textures ) {\r\n\r\n\tconst sourceSet = new Set();\r\n\tconst result = [];\r\n\tfor ( let i = 0, l = textures.length; i < l; i ++ ) {\r\n\r\n\t\tconst tex = textures[ i ];\r\n\t\tconst hash = getTextureHash( tex );\r\n\t\tif ( ! sourceSet.has( hash ) ) {\r\n\r\n\t\t\tsourceSet.add( hash );\r\n\t\t\tresult.push( tex );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function getIesTextures( lights ) {\r\n\r\n\tconst textures = lights.map( l => l.iesMap || null ).filter( t => t );\r\n\tconst textureSet = new Set( textures );\r\n\treturn Array.from( textureSet ).sort( uuidSort );\r\n\r\n}\r\n\r\nexport function getTextures( materials ) {\r\n\r\n\tconst textureSet = new Set();\r\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\tconst material = materials[ i ];\r\n\t\tfor ( const key in material ) {\r\n\r\n\t\t\tconst value = material[ key ];\r\n\t\t\tif ( value && value.isTexture ) {\r\n\r\n\t\t\t\ttextureSet.add( value );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconst textureArray = Array.from( textureSet );\r\n\treturn reduceTexturesToUniqueSources( textureArray ).sort( uuidSort );\r\n\r\n}\r\n\r\nexport function getLights( scene ) {\r\n\r\n\tconst lights = [];\r\n\tscene.traverse( c => {\r\n\r\n\t\tif ( c.visible ) {\r\n\r\n\t\t\tif (\r\n\t\t\t\tc.isRectAreaLight ||\r\n\t\t\t\tc.isSpotLight ||\r\n\t\t\t\tc.isPointLight ||\r\n\t\t\t\tc.isDirectionalLight\r\n\t\t\t) {\r\n\r\n\t\t\t\tlights.push( c );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\treturn lights.sort( uuidSort );\r\n\r\n}\r\n","import {\r\n\tWebGLArrayRenderTarget,\r\n\tRGBAFormat,\r\n\tUnsignedByteType,\r\n\tColor,\r\n\tRepeatWrapping,\r\n\tLinearFilter,\r\n\tNoToneMapping,\r\n\tShaderMaterial,\r\n} from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\n\r\nconst prevColor = new Color();\r\nfunction getTextureHash( texture ) {\r\n\r\n\treturn texture ? `${ texture.uuid }:${ texture.version }` : null;\r\n\r\n}\r\n\r\nfunction assignOptions( target, options ) {\r\n\r\n\tfor ( const key in options ) {\r\n\r\n\t\tif ( key in target ) {\r\n\r\n\t\t\ttarget[ key ] = options[ key ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class RenderTarget2DArray extends WebGLArrayRenderTarget {\r\n\r\n\tconstructor( width, height, options ) {\r\n\r\n\t\tconst textureOptions = {\r\n\t\t\tformat: RGBAFormat,\r\n\t\t\ttype: UnsignedByteType,\r\n\t\t\tminFilter: LinearFilter,\r\n\t\t\tmagFilter: LinearFilter,\r\n\t\t\twrapS: RepeatWrapping,\r\n\t\t\twrapT: RepeatWrapping,\r\n\t\t\tgenerateMipmaps: false,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tsuper( width, height, 1, textureOptions );\r\n\r\n\t\t// manually assign the options because passing options into the\r\n\t\t// constructor does not work\r\n\t\tassignOptions( this.texture, textureOptions );\r\n\r\n\t\tthis.texture.setTextures = ( ...args ) => {\r\n\r\n\t\t\tthis.setTextures( ...args );\r\n\r\n\t\t};\r\n\r\n\t\tthis.hashes = [ null ];\r\n\r\n\t\tconst fsQuad = new FullScreenQuad( new CopyMaterial() );\r\n\t\tthis.fsQuad = fsQuad;\r\n\r\n\t}\r\n\r\n\tsetTextures( renderer, textures, width = this.width, height = this.height ) {\r\n\r\n\t\t// save previous renderer state\r\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\r\n\t\tconst prevToneMapping = renderer.toneMapping;\r\n\t\tconst prevAlpha = renderer.getClearAlpha();\r\n\t\trenderer.getClearColor( prevColor );\r\n\r\n\t\t// resize the render target and ensure we don't have an empty texture\r\n\t\t// render target depth must be >= 1 to avoid unbound texture error on android devices\r\n\t\tconst depth = textures.length || 1;\r\n\t\tif ( width !== this.width || height !== this.height || this.depth !== depth ) {\r\n\r\n\t\t\tthis.setSize( width, height, depth );\r\n\t\t\tthis.hashes = new Array( depth ).fill( null );\r\n\r\n\t\t}\r\n\r\n\t\trenderer.setClearColor( 0, 0 );\r\n\t\trenderer.toneMapping = NoToneMapping;\r\n\r\n\t\t// render each texture into each layer of the target\r\n\t\tconst fsQuad = this.fsQuad;\r\n\t\tconst hashes = this.hashes;\r\n\t\tlet updated = false;\r\n\t\tfor ( let i = 0, l = depth; i < l; i ++ ) {\r\n\r\n\t\t\tconst texture = textures[ i ];\r\n\t\t\tconst hash = getTextureHash( texture );\r\n\t\t\tif ( texture && ( hashes[ i ] !== hash || texture.isWebGLRenderTarget ) ) {\r\n\r\n\t\t\t\t// revert to default texture transform before rendering\r\n\t\t\t\ttexture.matrixAutoUpdate = false;\r\n\t\t\t\ttexture.matrix.identity();\r\n\r\n\t\t\t\tfsQuad.material.map = texture;\r\n\r\n\t\t\t\trenderer.setRenderTarget( this, i );\r\n\t\t\t\tfsQuad.render( renderer );\r\n\r\n\t\t\t\t// restore custom texture transform\r\n\t\t\t\ttexture.updateMatrix();\r\n\t\t\t\ttexture.matrixAutoUpdate = true;\r\n\r\n\t\t\t\t// ensure textures are not updated unnecessarily\r\n\t\t\t\thashes[ i ] = hash;\r\n\t\t\t\tupdated = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// reset the renderer\r\n\t\tfsQuad.material.map = null;\r\n\t\trenderer.setClearColor( prevColor, prevAlpha );\r\n\t\trenderer.setRenderTarget( prevRenderTarget );\r\n\t\trenderer.toneMapping = prevToneMapping;\r\n\r\n\t\treturn updated;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tsuper.dispose();\r\n\t\tthis.fsQuad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass CopyMaterial extends ShaderMaterial {\r\n\r\n\tget map() {\r\n\r\n\t\treturn this.uniforms.map.value;\r\n\r\n\t}\r\n\tset map( v ) {\r\n\r\n\t\tthis.uniforms.map.value = v;\r\n\r\n\t}\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tmap: { value: null },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\tuniform sampler2D map;\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tgl_FragColor = texture2D( map, vUv );\r\n\r\n\t\t\t\t}\r\n\t\t\t`\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, FloatType, NearestFilter, RGBAFormat } from 'three';\r\nimport { StratifiedSamplerCombined } from './stratified/StratifiedSamplerCombined.js';\r\n\r\n// https://stackoverflow.com/questions/424292/seedable-javascript-random-number-generator\r\nclass RandomGenerator {\r\n\r\n\tconstructor( seed = 0 ) {\r\n\r\n\t\t// LCG using GCC's constants\r\n\t\tthis.m = 0x80000000; // 2**31;\r\n\t\tthis.a = 1103515245;\r\n\t\tthis.c = 12345;\r\n\r\n\t\tthis.seed = seed;\r\n\r\n\t}\r\n\r\n\tnextInt() {\r\n\r\n\t\tthis.seed = ( this.a * this.seed + this.c ) % this.m;\r\n\t\treturn this.seed;\r\n\r\n\t}\r\n\r\n\tnextFloat() {\r\n\r\n\t\t// returns in range [0,1]\r\n\t\treturn this.nextInt() / ( this.m - 1 );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class StratifiedSamplesTexture extends DataTexture {\r\n\r\n\tconstructor( count = 1, depth = 1, strata = 8 ) {\r\n\r\n\t\tsuper( new Float32Array( 1 ), 1, 1, RGBAFormat, FloatType );\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\r\n\t\tthis.strata = strata;\r\n\t\tthis.sampler = null;\r\n\t\tthis.generator = new RandomGenerator();\r\n\t\tthis.stableNoise = false;\r\n\t\tthis.random = () => {\r\n\r\n\t\t\tif ( this.stableNoise ) {\r\n\r\n\t\t\t\treturn this.generator.nextFloat();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn Math.random();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.init( count, depth, strata );\r\n\r\n\t}\r\n\r\n\tinit( count = this.image.height, depth = this.image.width, strata = this.strata ) {\r\n\r\n\t\tconst { image } = this;\r\n\t\tif ( image.width === depth && image.height === count && this.sampler !== null ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst dimensions = new Array( count * depth ).fill( 4 );\r\n\t\tconst sampler = new StratifiedSamplerCombined( strata, dimensions, this.random );\r\n\r\n\t\timage.width = depth;\r\n\t\timage.height = count;\r\n\t\timage.data = sampler.samples;\r\n\r\n\t\tthis.sampler = sampler;\r\n\r\n\t\tthis.dispose();\r\n\t\tthis.next();\r\n\r\n\t}\r\n\r\n\tnext() {\r\n\r\n\t\tthis.sampler.next();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\treset() {\r\n\r\n\t\tthis.sampler.reset();\r\n\t\tthis.generator.seed = 0;\r\n\r\n\t}\r\n\r\n}\r\n","// Stratified Sampling based on implementation from hoverinc pathtracer\r\n// - https://github.com/hoverinc/ray-tracing-renderer\r\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\r\n\r\nimport { StratifiedSampler } from './StratifiedSampler.js';\r\n\r\n// Stratified set of data with each tuple stratified separately and combined\r\nexport class StratifiedSamplerCombined {\r\n\r\n\tconstructor( strataCount, listOfDimensions, random = Math.random ) {\r\n\r\n\t\tlet totalDim = 0;\r\n\t\tfor ( const dim of listOfDimensions ) {\r\n\r\n\t\t\ttotalDim += dim;\r\n\r\n\t\t}\r\n\r\n\t\tconst combined = new Float32Array( totalDim );\r\n\t\tconst strataObjs = [];\r\n\t\tlet offset = 0;\r\n\t\tfor ( const dim of listOfDimensions ) {\r\n\r\n\t\t\tconst sampler = new StratifiedSampler( strataCount, dim, random );\r\n\t\t\tsampler.samples = new Float32Array( combined.buffer, offset, sampler.samples.length );\r\n\t\t\toffset += sampler.samples.length * 4;\r\n\t\t\tstrataObjs.push( sampler );\r\n\r\n\t\t}\r\n\r\n\t\tthis.samples = combined;\r\n\r\n\t\tthis.strataCount = strataCount;\r\n\r\n\t\tthis.next = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.next();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn combined;\r\n\r\n\t\t};\r\n\r\n\t\tthis.reshuffle = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.reshuffle();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tthis.reset = function () {\r\n\r\n\t\t\tfor ( const strata of strataObjs ) {\r\n\r\n\t\t\t\tstrata.reset();\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","// Stratified Sampling based on implementation from hoverinc pathtracer\r\n// - https://github.com/hoverinc/ray-tracing-renderer\r\n// - http://www.pbr-book.org/3ed-2018/Sampling_and_Reconstruction/Stratified_Sampling.html\r\n\r\nexport function shuffle( arr, random = Math.random() ) {\r\n\r\n\tfor ( let i = arr.length - 1; i > 0; i -- ) {\r\n\r\n\t  const j = Math.floor( random() * ( i + 1 ) );\r\n\t  const x = arr[ i ];\r\n\t  arr[ i ] = arr[ j ];\r\n\t  arr[ j ] = x;\r\n\r\n\t}\r\n\r\n\treturn arr;\r\n\r\n}\r\n\r\n// strataCount : The number of bins per dimension\r\n// dimensions  : The number of dimensions to generate stratified values for\r\nexport class StratifiedSampler {\r\n\r\n\tconstructor( strataCount, dimensions, random = Math.random ) {\r\n\r\n\t\tconst l = strataCount ** dimensions;\r\n\t\tconst strata = new Uint16Array( l );\r\n\t\tlet index = l;\r\n\r\n\t\t// each integer represents a statum bin\r\n\t\tfor ( let i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tstrata[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tthis.samples = new Float32Array( dimensions );\r\n\r\n\t\tthis.strataCount = strataCount;\r\n\r\n\t\tthis.reset = function () {\r\n\r\n\t\t\tfor ( let i = 0; i < l; i ++ ) {\r\n\r\n\t\t\t\tstrata[ i ] = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t\tthis.reshuffle = function () {\r\n\r\n\t\t\tindex = 0;\r\n\r\n\t\t};\r\n\r\n\t\tthis.next = function () {\r\n\r\n\t\t\tconst { samples } = this;\r\n\r\n\t\t\tif ( index >= strata.length ) {\r\n\r\n\t\t\t\tshuffle( strata, random );\r\n\t\t\t\tthis.reshuffle();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlet stratum = strata[ index ++ ];\r\n\r\n\t\t\tfor ( let i = 0; i < dimensions; i ++ ) {\r\n\r\n\t\t\t\tsamples[ i ] = ( stratum % strataCount + random() ) / strataCount;\r\n\t\t\t\tstratum = Math.floor( stratum / strataCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn samples;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { DataTexture, FloatType, NearestFilter, RGBAFormat, RGFormat, RedFormat } from 'three';\r\nimport { BlueNoiseGenerator } from './blueNoise/BlueNoiseGenerator.js';\r\n\r\nfunction getStride( channels ) {\r\n\r\n\tif ( channels >= 3 ) {\r\n\r\n\t\treturn 4;\r\n\r\n\t} else {\r\n\r\n\t\treturn channels;\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getFormat( channels ) {\r\n\r\n\tswitch ( channels ) {\r\n\r\n\tcase 1:\r\n\t\treturn RedFormat;\r\n\tcase 2:\r\n\t\treturn RGFormat;\r\n\tdefault:\r\n\t\treturn RGBAFormat;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class BlueNoiseTexture extends DataTexture {\r\n\r\n\tconstructor( size = 64, channels = 1 ) {\r\n\r\n\t\tsuper( new Float32Array( 4 ), 1, 1, RGBAFormat, FloatType );\r\n\t\tthis.minFilter = NearestFilter;\r\n\t\tthis.magFilter = NearestFilter;\r\n\r\n\t\tthis.size = size;\r\n\t\tthis.channels = channels;\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst channels = this.channels;\r\n\t\tconst size = this.size;\r\n\t\tconst generator = new BlueNoiseGenerator();\r\n\t\tgenerator.channels = channels;\r\n\t\tgenerator.size = size;\r\n\r\n\t\tconst stride = getStride( channels );\r\n\t\tconst format = getFormat( stride );\r\n\t\tif ( this.image.width !== size || format !== this.format ) {\r\n\r\n\t\t\tthis.image.width = size;\r\n\t\t\tthis.image.height = size;\r\n\t\t\tthis.image.data = new Float32Array( ( size ** 2 ) * stride );\r\n\t\t\tthis.format = format;\r\n\t\t\tthis.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tconst data = this.image.data;\r\n\t\tfor ( let i = 0, l = channels; i < l; i ++ ) {\r\n\r\n\t\t\tconst result = generator.generate();\r\n\t\t\tconst bin = result.data;\r\n\t\t\tconst maxValue = result.maxValue;\r\n\r\n\t\t\tfor ( let j = 0, l2 = bin.length; j < l2; j ++ ) {\r\n\r\n\t\t\t\tconst value = bin[ j ] / maxValue;\r\n\t\t\t\tdata[ j * stride + i ] = value;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n","import { shuffleArray, fillWithOnes } from './utils.js';\r\nimport { BlueNoiseSamples } from './BlueNoiseSamples.js';\r\n\r\nexport class BlueNoiseGenerator {\r\n\r\n\tconstructor() {\r\n\r\n\t\tthis.random = Math.random;\r\n\t\tthis.sigma = 1.5;\r\n\t\tthis.size = 64;\r\n\t\tthis.majorityPointsRatio = 0.1;\r\n\r\n\t\tthis.samples = new BlueNoiseSamples( 1 );\r\n\t\tthis.savedSamples = new BlueNoiseSamples( 1 );\r\n\r\n\t}\r\n\r\n\tgenerate() {\r\n\r\n\t\t// http://cv.ulichney.com/papers/1993-void-cluster.pdf\r\n\r\n\t\tconst {\r\n\t\t\tsamples,\r\n\t\t\tsavedSamples,\r\n\t\t\tsigma,\r\n\t\t\tmajorityPointsRatio,\r\n\t\t\tsize,\r\n\t\t} = this;\r\n\r\n\t\tsamples.resize( size );\r\n\t\tsamples.setSigma( sigma );\r\n\r\n\t\t// 1. Randomly place the minority points.\r\n\t\tconst pointCount = Math.floor( size * size * majorityPointsRatio );\r\n\t\tconst initialSamples = samples.binaryPattern;\r\n\r\n\t\tfillWithOnes( initialSamples, pointCount );\r\n\t\tshuffleArray( initialSamples, this.random );\r\n\r\n\t\tfor ( let i = 0, l = initialSamples.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( initialSamples[ i ] === 1 ) {\r\n\r\n\t\t\t\tsamples.addPointIndex( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// 2. Remove minority point that is in densest cluster and place it in the largest void.\r\n\t\twhile ( true ) {\r\n\r\n\t\t\tconst clusterIndex = samples.findCluster();\r\n\t\t\tsamples.removePointIndex( clusterIndex );\r\n\r\n\t\t\tconst voidIndex = samples.findVoid();\r\n\t\t\tif ( clusterIndex === voidIndex ) {\r\n\r\n\t\t\t\tsamples.addPointIndex( clusterIndex );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsamples.addPointIndex( voidIndex );\r\n\r\n\t\t}\r\n\r\n\t\t// 3. PHASE I: Assign a rank to each progressively less dense cluster point and put it\r\n\t\t// in the dither array.\r\n\t\tconst ditherArray = new Uint32Array( size * size );\r\n\t\tsavedSamples.copy( samples );\r\n\r\n\t\tlet rank;\r\n\t\trank = samples.count - 1;\r\n\t\twhile ( rank >= 0 ) {\r\n\r\n\t\t\tconst clusterIndex = samples.findCluster();\r\n\t\t\tsamples.removePointIndex( clusterIndex );\r\n\r\n\t\t\tditherArray[ clusterIndex ] = rank;\r\n\t\t\trank --;\r\n\r\n\t\t}\r\n\r\n\t\t// 4. PHASE II: Do the same thing for the largest voids up to half of the total pixels using\r\n\t\t// the initial binary pattern.\r\n\t\tconst totalSize = size * size;\r\n\t\trank = savedSamples.count;\r\n\t\twhile ( rank < totalSize / 2 ) {\r\n\r\n\t\t\tconst voidIndex = savedSamples.findVoid();\r\n\t\t\tsavedSamples.addPointIndex( voidIndex );\r\n\t\t\tditherArray[ voidIndex ] = rank;\r\n\t\t\trank ++;\r\n\r\n\t\t}\r\n\r\n\t\t// 5. PHASE III: Invert the pattern and finish out by assigning a rank to the remaining\r\n\t\t// and iteratively removing them.\r\n\t\tsavedSamples.invert();\r\n\r\n\t\twhile ( rank < totalSize ) {\r\n\r\n\t\t\tconst clusterIndex = savedSamples.findCluster();\r\n\t\t\tsavedSamples.removePointIndex( clusterIndex );\r\n\t\t\tditherArray[ clusterIndex ] = rank;\r\n\t\t\trank ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn { data: ditherArray, maxValue: totalSize };\r\n\r\n\t}\r\n\r\n}\r\n","export function shuffleArray( array, random = Math.random ) {\r\n\r\n\tfor ( let i = array.length - 1; i > 0; i -- ) {\r\n\r\n\t\tconst replaceIndex = ~ ~ ( ( random() - 1e-6 ) * i );\r\n\t\tconst tmp = array[ i ];\r\n\t\tarray[ i ] = array[ replaceIndex ];\r\n\t\tarray[ replaceIndex ] = tmp;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function fillWithOnes( array, count ) {\r\n\r\n\tarray.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < count; i ++ ) {\r\n\r\n\t\tarray[ i ] = 1;\r\n\r\n\t}\r\n\r\n}\r\n","export class BlueNoiseSamples {\r\n\r\n\tconstructor( size ) {\r\n\r\n\t\tthis.count = 0;\r\n\t\tthis.size = - 1;\r\n\t\tthis.sigma = - 1;\r\n\t\tthis.radius = - 1;\r\n\t\tthis.lookupTable = null;\r\n\t\tthis.score = null;\r\n\t\tthis.binaryPattern = null;\r\n\r\n\t\tthis.resize( size );\r\n\t\tthis.setSigma( 1.5 );\r\n\r\n\t}\r\n\r\n\tfindVoid() {\r\n\r\n\t\tconst { score, binaryPattern } = this;\r\n\r\n\t\tlet currValue = Infinity;\r\n\t\tlet currIndex = - 1;\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] !== 0 ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pScore = score[ i ];\r\n\t\t\tif ( pScore < currValue ) {\r\n\r\n\t\t\t\tcurrValue = pScore;\r\n\t\t\t\tcurrIndex = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn currIndex;\r\n\r\n\t}\r\n\r\n\tfindCluster() {\r\n\r\n\t\tconst { score, binaryPattern } = this;\r\n\r\n\t\tlet currValue = - Infinity;\r\n\t\tlet currIndex = - 1;\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] !== 1 ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst pScore = score[ i ];\r\n\t\t\tif ( pScore > currValue ) {\r\n\r\n\t\t\t\tcurrValue = pScore;\r\n\t\t\t\tcurrIndex = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn currIndex;\r\n\r\n\t}\r\n\r\n\tsetSigma( sigma ) {\r\n\r\n\t\tif ( sigma === this.sigma ) {\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// generate a radius in which the score will be updated under the\r\n\t\t// assumption that e^-10 is insignificant enough to be the border at\r\n\t\t// which we drop off.\r\n\t\tconst radius = ~ ~ ( Math.sqrt( 10 * 2 * ( sigma ** 2 ) ) + 1 );\r\n\t\tconst lookupWidth = 2 * radius + 1;\r\n\t\tconst lookupTable = new Float32Array( lookupWidth * lookupWidth );\r\n\t\tconst sigma2 = sigma * sigma;\r\n\t\tfor ( let x = - radius; x <= radius; x ++ ) {\r\n\r\n\t\t\tfor ( let y = - radius; y <= radius; y ++ ) {\r\n\r\n\t\t\t\tconst index = ( radius + y ) * lookupWidth + x + radius;\r\n\t\t\t\tconst dist2 = x * x + y * y;\r\n\t\t\t\tlookupTable[ index ] = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.lookupTable = lookupTable;\r\n\t\tthis.sigma = sigma;\r\n\t\tthis.radius = radius;\r\n\r\n\t}\r\n\r\n\tresize( size ) {\r\n\r\n\t\tif ( this.size !== size ) {\r\n\r\n\t\t\tthis.size = size;\r\n\t\t\tthis.score = new Float32Array( size * size );\r\n\t\t\tthis.binaryPattern = new Uint8Array( size * size );\r\n\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\tinvert() {\r\n\r\n\t\tconst { binaryPattern, score, size } = this;\r\n\r\n\t\tscore.fill( 0 );\r\n\r\n\t\tfor ( let i = 0, l = binaryPattern.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( binaryPattern[ i ] === 0 ) {\r\n\r\n\t\t\t\tconst y = ~ ~ ( i / size );\r\n\t\t\t\tconst x = i - y * size;\r\n\t\t\t\tthis.updateScore( x, y, 1 );\r\n\t\t\t\tbinaryPattern[ i ] = 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbinaryPattern[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateScore( x, y, multiplier ) {\r\n\r\n\t\t// TODO: Is there a way to keep track of the highest and lowest scores here to avoid have to search over\r\n\t\t// everything in the buffer?\r\n\t\tconst { size, score, lookupTable } = this;\r\n\r\n\t\t// const sigma2 = sigma * sigma;\r\n\t\t// const radius = Math.floor( size / 2 );\r\n\t\tconst radius = this.radius;\r\n\t\tconst lookupWidth = 2 * radius + 1;\r\n\t\tfor ( let px = - radius; px <= radius; px ++ ) {\r\n\r\n\t\t\tfor ( let py = - radius; py <= radius; py ++ ) {\r\n\r\n\t\t\t\t// const dist2 = px * px + py * py;\r\n\t\t\t\t// const value = Math.E ** ( - dist2 / ( 2 * sigma2 ) );\r\n\r\n\t\t\t\tconst lookupIndex = ( radius + py ) * lookupWidth + px + radius;\r\n\t\t\t\tconst value = lookupTable[ lookupIndex ];\r\n\r\n\t\t\t\tlet sx = ( x + px );\r\n\t\t\t\tsx = sx < 0 ? size + sx : sx % size;\r\n\r\n\t\t\t\tlet sy = ( y + py );\r\n\t\t\t\tsy = sy < 0 ? size + sy : sy % size;\r\n\r\n\t\t\t\tconst sindex = sy * size + sx;\r\n\t\t\t\tscore[ sindex ] += multiplier * value;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\taddPointIndex( index ) {\r\n\r\n\t\tthis.binaryPattern[ index ] = 1;\r\n\r\n\t\tconst size = this.size;\r\n\t\tconst y = ~ ~ ( index / size );\r\n\t\tconst x = index - y * size;\r\n\t\tthis.updateScore( x, y, 1 );\r\n\t\tthis.count ++;\r\n\r\n\t}\r\n\r\n\tremovePointIndex( index ) {\r\n\r\n\t\tthis.binaryPattern[ index ] = 0;\r\n\r\n\t\tconst size = this.size;\r\n\t\tconst y = ~ ~ ( index / size );\r\n\t\tconst x = index - y * size;\r\n\t\tthis.updateScore( x, y, - 1 );\r\n\t\tthis.count --;\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.resize( source.size );\r\n\t\tthis.score.set( source.score );\r\n\t\tthis.binaryPattern.set( source.binaryPattern );\r\n\t\tthis.setSigma( source.sigma );\r\n\t\tthis.count = source.count;\r\n\r\n\t}\r\n\r\n}\r\n","export * from './inside_fog_volume_function.glsl.js';\r\nexport * from './ray_any_hit_function.glsl.js';\r\n","export const inside_fog_volume_function = /* glsl */`\r\n\r\n#ifndef FOG_CHECK_ITERATIONS\r\n#define FOG_CHECK_ITERATIONS 30\r\n#endif\r\n\r\n// returns whether the given material is a fog material or not\r\nbool isMaterialFogVolume( sampler2D materials, uint materialIndex ) {\r\n\r\n\tuint i = materialIndex * uint( MATERIAL_PIXELS );\r\n\tvec4 s14 = texelFetch1D( materials, i + 14u );\r\n\treturn bool( int( s14.b ) & 4 );\r\n\r\n}\r\n\r\n// returns true if we're within the first fog volume we hit\r\nbool bvhIntersectFogVolumeHit(\r\n\tvec3 rayOrigin, vec3 rayDirection,\r\n\tusampler2D materialIndexAttribute, sampler2D materials,\r\n\tinout Material material\r\n) {\r\n\r\n\tmaterial.fogVolume = false;\r\n\r\n\tfor ( int i = 0; i < FOG_CHECK_ITERATIONS; i ++ ) {\r\n\r\n\t\t// find nearest hit\r\n\t\tuvec4 faceIndices = uvec4( 0u );\r\n\t\tvec3 faceNormal = vec3( 0.0, 0.0, 1.0 );\r\n\t\tvec3 barycoord = vec3( 0.0 );\r\n\t\tfloat side = 1.0;\r\n\t\tfloat dist = 0.0;\r\n\t\tbool hit = bvhIntersectFirstHit( bvh, rayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist );\r\n\t\tif ( hit ) {\r\n\r\n\t\t\t// if it's a fog volume return whether we hit the front or back face\r\n\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, faceIndices.x ).r;\r\n\t\t\tif ( isMaterialFogVolume( materials, materialIndex ) ) {\r\n\r\n\t\t\t\tmaterial = readMaterialInfo( materials, materialIndex );\r\n\t\t\t\treturn side == - 1.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// move the ray forward\r\n\t\t\t\trayOrigin = stepRayOrigin( rayOrigin, rayDirection, - faceNormal, dist );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn false;\r\n\r\n}\r\n\r\n`;\r\n","export const ray_any_hit_function = /* glsl */`\r\n\r\n\tbool bvhIntersectAnyHit(\r\n\t\tvec3 rayOrigin, vec3 rayDirection,\r\n\r\n\t\t// output variables\r\n\t\tinout float side, inout float dist\r\n\t) {\r\n\r\n\t\tuvec4 faceIndices;\r\n\t\tvec3 faceNormal;\r\n\t\tvec3 barycoord;\r\n\r\n\t\t// stack needs to be twice as long as the deepest tree we expect because\r\n\t\t// we push both the left and right child onto the stack every traversal\r\n\t\tint ptr = 0;\r\n\t\tuint stack[ 60 ];\r\n\t\tstack[ 0 ] = 0u;\r\n\r\n\t\tfloat triangleDistance = 1e20;\r\n\t\twhile ( ptr > - 1 && ptr < 60 ) {\r\n\r\n\t\t\tuint currNodeIndex = stack[ ptr ];\r\n\t\t\tptr --;\r\n\r\n\t\t\t// check if we intersect the current bounds\r\n\t\t\tfloat boundsHitDistance = intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh, currNodeIndex );\r\n\t\t\tif ( boundsHitDistance == INFINITY ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvec2 boundsInfo = uTexelFetch1D( bvh.bvhContents, currNodeIndex ).xy;\r\n\t\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\r\n\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\r\n\t\t\t\tuint offset = boundsInfo.y;\r\n\r\n\t\t\t\tbool found = intersectTriangles(\r\n\t\t\t\t\tbvh, rayOrigin, rayDirection, offset, count, triangleDistance,\r\n\t\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\r\n\t\t\t\t);\r\n\r\n\t\t\t\tif ( found ) {\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tuint leftIndex = currNodeIndex + 1u;\r\n\t\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\r\n\t\t\t\tuint rightIndex = boundsInfo.y;\r\n\r\n\t\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\r\n\t\t\t\t// the stack while we traverse. The second pointer added is the one that will be\r\n\t\t\t\t// traversed first\r\n\t\t\t\tptr ++;\r\n\t\t\t\tstack[ ptr ] = leftIndex;\r\n\r\n\t\t\t\tptr ++;\r\n\t\t\t\tstack[ ptr ] = rightIndex;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n`;\r\n","export * from './attenuate_hit_function.glsl.js';\r\nexport * from './camera_util_functions.glsl.js';\r\nexport * from './direct_light_contribution_function.glsl.js';\r\nexport * from './get_surface_record_function.glsl.js';\r\nexport * from './render_structs.glsl.js';\r\nexport * from './trace_scene_function.glsl.js';\r\n","export const attenuate_hit_function = /* glsl */`\r\n\r\n\t// step through multiple surface hits and accumulate color attenuation based on transmissive surfaces\r\n\t// returns true if a solid surface was hit\r\n\tbool attenuateHit(\r\n\t\tRenderState state,\r\n\t\tRay ray, float rayDist,\r\n\t\tout vec3 color\r\n\t) {\r\n\r\n\t\t// store the original bounce index so we can reset it after\r\n\t\tuint originalBounceIndex = sobolBounceIndex;\r\n\r\n\t\tint traversals = state.traversals;\r\n\t\tint transmissiveTraversals = state.transmissiveTraversals;\r\n\t\tbool isShadowRay = state.isShadowRay;\r\n\t\tMaterial fogMaterial = state.fogMaterial;\r\n\r\n\t\tvec3 startPoint = ray.origin;\r\n\r\n\t\t// hit results\r\n\t\tSurfaceHit surfaceHit;\r\n\r\n\t\tcolor = vec3( 1.0 );\r\n\r\n\t\tbool result = true;\r\n\t\tfor ( int i = 0; i < traversals; i ++ ) {\r\n\r\n\t\t\tsobolBounceIndex ++;\r\n\r\n\t\t\tint hitType = traceScene( ray, fogMaterial, surfaceHit );\r\n\r\n\t\t\tif ( hitType == FOG_HIT ) {\r\n\r\n\t\t\t\tresult = true;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t} else if ( hitType == SURFACE_HIT ) {\r\n\r\n\t\t\t\tfloat totalDist = distance( startPoint, ray.origin + ray.direction * surfaceHit.dist );\r\n\t\t\t\tif ( totalDist > rayDist ) {\r\n\r\n\t\t\t\t\tresult = false;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// TODO: attenuate the contribution based on the PDF of the resulting ray including refraction values\r\n\t\t\t\t// Should be able to work using the material BSDF functions which will take into account specularity, etc.\r\n\t\t\t\t// TODO: should we account for emissive surfaces here?\r\n\r\n\t\t\t\tuint materialIndex = uTexelFetch1D( materialIndexAttribute, surfaceHit.faceIndices.x ).r;\r\n\t\t\t\tMaterial material = readMaterialInfo( materials, materialIndex );\r\n\r\n\t\t\t\t// adjust the ray to the new surface\r\n\t\t\t\tbool isEntering = surfaceHit.side == 1.0;\r\n\t\t\t\tray.origin = stepRayOrigin( ray.origin, ray.direction, - surfaceHit.faceNormal, surfaceHit.dist );\r\n\r\n\t\t\t\t#if FEATURE_FOG\r\n\r\n\t\t\t\tif ( material.fogVolume ) {\r\n\r\n\t\t\t\t\tfogMaterial = material;\r\n\t\t\t\t\tfogMaterial.fogVolume = surfaceHit.side == 1.0;\r\n\t\t\t\t\ti -= sign( transmissiveTraversals );\r\n\t\t\t\t\ttransmissiveTraversals --;\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\tif ( ! material.castShadow && isShadowRay ) {\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\r\n\t\t\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\r\n\r\n\t\t\t\t// albedo\r\n\t\t\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\t\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\t\t\talbedo *= vertexColor;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// alphaMap\r\n\t\t\t\tif ( material.alphaMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.alphaMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\talbedo.a *= texture2D( textures, vec3( uvPrime.xy, material.alphaMap ) ).x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// transmission\r\n\t\t\t\tfloat transmission = material.transmission;\r\n\t\t\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// metalness\r\n\t\t\t\tfloat metalness = material.metalness;\r\n\t\t\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfloat alphaTest = material.alphaTest;\r\n\t\t\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\t\t\tfloat transmissionFactor = ( 1.0 - metalness ) * transmission;\r\n\t\t\t\tif (\r\n\t\t\t\t\ttransmissionFactor < rand( 9 ) && ! (\r\n\t\t\t\t\t\t// material sidedness\r\n\t\t\t\t\t\tmaterial.side != 0.0 && surfaceHit.side == material.side\r\n\r\n\t\t\t\t\t\t// alpha test\r\n\t\t\t\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t\t\t\t// opacity\r\n\t\t\t\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 10 )\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tresult = true;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( surfaceHit.side == 1.0 && isEntering ) {\r\n\r\n\t\t\t\t\t// only attenuate by surface color on the way in\r\n\t\t\t\t\tcolor *= mix( vec3( 1.0 ), albedo.rgb, transmissionFactor );\r\n\r\n\t\t\t\t} else if ( surfaceHit.side == - 1.0 ) {\r\n\r\n\t\t\t\t\t// attenuate by medium once we hit the opposite side of the model\r\n\t\t\t\t\tcolor *= transmissionAttenuation( surfaceHit.dist, material.attenuationColor, material.attenuationDistance );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbool isTransmissiveRay = dot( ray.direction, surfaceHit.faceNormal * surfaceHit.side ) < 0.0;\r\n\t\t\t\tif ( ( isTransmissiveRay || isEntering ) && transmissiveTraversals > 0 ) {\r\n\r\n\t\t\t\t\ti -= sign( transmissiveTraversals );\r\n\t\t\t\t\ttransmissiveTraversals --;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresult = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// reset the bounce index\r\n\t\tsobolBounceIndex = originalBounceIndex;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const camera_util_functions = /* glsl */`\r\n\r\n\tvec3 ndcToRayOrigin( vec2 coord ) {\r\n\r\n\t\tvec4 rayOrigin4 = cameraWorldMatrix * invProjectionMatrix * vec4( coord, - 1.0, 1.0 );\r\n\t\treturn rayOrigin4.xyz / rayOrigin4.w;\r\n\t}\r\n\r\n\tRay getCameraRay() {\r\n\r\n\t\tvec2 ssd = vec2( 1.0 ) / resolution;\r\n\r\n\t\t// Jitter the camera ray by finding a uv coordinate at a random sample\r\n\t\t// around this pixel's UV coordinate for AA\r\n\t\tvec2 ruv = rand2( 0 );\r\n\t\tvec2 jitteredUv = vUv + vec2( tentFilter( ruv.x ) * ssd.x, tentFilter( ruv.y ) * ssd.y );\r\n\t\tRay ray;\r\n\r\n\t\t#if CAMERA_TYPE == 2\r\n\r\n\t\t\t// Equirectangular projection\r\n\t\t\tvec4 rayDirection4 = vec4( equirectUvToDirection( jitteredUv ), 0.0 );\r\n\t\t\tvec4 rayOrigin4 = vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\t\t\trayDirection4 = cameraWorldMatrix * rayDirection4;\r\n\t\t\trayOrigin4 = cameraWorldMatrix * rayOrigin4;\r\n\r\n\t\t\tray.direction = normalize( rayDirection4.xyz );\r\n\t\t\tray.origin = rayOrigin4.xyz / rayOrigin4.w;\r\n\r\n\t\t#else\r\n\r\n\t\t\t// get [- 1, 1] normalized device coordinates\r\n\t\t\tvec2 ndc = 2.0 * jitteredUv - vec2( 1.0 );\r\n\t\t\tray.origin = ndcToRayOrigin( ndc );\r\n\r\n\t\t\t#if CAMERA_TYPE == 1\r\n\r\n\t\t\t\t// Orthographic projection\r\n\t\t\t\tray.direction = ( cameraWorldMatrix * vec4( 0.0, 0.0, - 1.0, 0.0 ) ).xyz;\r\n\t\t\t\tray.direction = normalize( ray.direction );\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t// Perspective projection\r\n\t\t\t\tray.direction = normalize( mat3( cameraWorldMatrix ) * ( invProjectionMatrix * vec4( ndc, 0.0, 1.0 ) ).xyz );\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#endif\r\n\r\n\t\t#if FEATURE_DOF\r\n\t\t{\r\n\r\n\t\t\t// depth of field\r\n\t\t\tvec3 focalPoint = ray.origin + normalize( ray.direction ) * physicalCamera.focusDistance;\r\n\r\n\t\t\t// get the aperture sample\r\n\t\t\t// if blades === 0 then we assume a circle\r\n\t\t\tvec3 shapeUVW= rand3( 1 );\r\n\t\t\tint blades = physicalCamera.apertureBlades;\r\n\t\t\tfloat anamorphicRatio = physicalCamera.anamorphicRatio;\r\n\t\t\tvec2 apertureSample = blades == 0 ? sampleCircle( shapeUVW.xy ) : sampleRegularPolygon( blades, shapeUVW );\r\n\t\t\tapertureSample *= physicalCamera.bokehSize * 0.5 * 1e-3;\r\n\r\n\t\t\t// rotate the aperture shape\r\n\t\t\tapertureSample =\r\n\t\t\t\trotateVector( apertureSample, physicalCamera.apertureRotation ) *\r\n\t\t\t\tsaturate( vec2( anamorphicRatio, 1.0 / anamorphicRatio ) );\r\n\r\n\t\t\t// create the new ray\r\n\t\t\tray.origin += ( cameraWorldMatrix * vec4( apertureSample, 0.0, 0.0 ) ).xyz;\r\n\t\t\tray.direction = focalPoint - ray.origin;\r\n\r\n\t\t}\r\n\t\t#endif\r\n\r\n\t\tray.direction = normalize( ray.direction );\r\n\r\n\t\treturn ray;\r\n\r\n\t}\r\n\r\n`;\r\n","export const direct_light_contribution_function = /*glsl*/`\r\n\r\n\tvec3 directLightContribution( vec3 worldWo, SurfaceRecord surf, RenderState state, vec3 rayOrigin ) {\r\n\r\n\t\tvec3 result = vec3( 0.0 );\r\n\r\n\t\t// uniformly pick a light or environment map\r\n\t\tif( lightsDenom != 0.0 && rand( 5 ) < float( lights.count ) / lightsDenom ) {\r\n\r\n\t\t\t// sample a light or environment\r\n\t\t\tLightRecord lightRec = randomLightSample( lights.tex, iesProfiles, lights.count, rayOrigin, rand3( 6 ) );\r\n\r\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, lightRec.direction ) < 0.0;\r\n\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\tlightRec.pdf = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if a ray could even reach the light area\r\n\t\t\tRay lightRay;\r\n\t\t\tlightRay.origin = rayOrigin;\r\n\t\t\tlightRay.direction = lightRec.direction;\r\n\t\t\tvec3 attenuatedColor;\r\n\t\t\tif (\r\n\t\t\t\tlightRec.pdf > 0.0 &&\r\n\t\t\t\tisDirectionValid( lightRec.direction, surf.normal, surf.faceNormal ) &&\r\n\t\t\t\t! attenuateHit( state, lightRay, lightRec.dist, attenuatedColor )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// get the material pdf\r\n\t\t\t\tvec3 sampleColor;\r\n\t\t\t\tfloat lightMaterialPdf = bsdfResult( worldWo, lightRec.direction, surf, sampleColor );\r\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\tif ( lightMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\tfloat lightPdf = lightRec.pdf / lightsDenom;\r\n\t\t\t\t\tfloat misWeight = lightRec.type == SPOT_LIGHT_TYPE || lightRec.type == DIR_LIGHT_TYPE || lightRec.type == POINT_LIGHT_TYPE ? 1.0 : misHeuristic( lightPdf, lightMaterialPdf );\r\n\t\t\t\t\tresult = attenuatedColor * lightRec.emission * state.throughputColor * sampleColor * misWeight / lightPdf;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( envMapInfo.totalSum != 0.0 && environmentIntensity != 0.0 ) {\r\n\r\n\t\t\t// find a sample in the environment map to include in the contribution\r\n\t\t\tvec3 envColor, envDirection;\r\n\t\t\tfloat envPdf = sampleEquirectProbability( rand2( 7 ), envColor, envDirection );\r\n\t\t\tenvDirection = invEnvRotation3x3 * envDirection;\r\n\r\n\t\t\t// this env sampling is not set up for transmissive sampling and yields overly bright\r\n\t\t\t// results so we ignore the sample in this case.\r\n\t\t\t// TODO: this should be improved but how? The env samples could traverse a few layers?\r\n\t\t\tbool isSampleBelowSurface = ! surf.volumeParticle && dot( surf.faceNormal, envDirection ) < 0.0;\r\n\t\t\tif ( isSampleBelowSurface ) {\r\n\r\n\t\t\t\tenvPdf = 0.0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// check if a ray could even reach the surface\r\n\t\t\tRay envRay;\r\n\t\t\tenvRay.origin = rayOrigin;\r\n\t\t\tenvRay.direction = envDirection;\r\n\t\t\tvec3 attenuatedColor;\r\n\t\t\tif (\r\n\t\t\t\tenvPdf > 0.0 &&\r\n\t\t\t\tisDirectionValid( envDirection, surf.normal, surf.faceNormal ) &&\r\n\t\t\t\t! attenuateHit( state, envRay, INFINITY, attenuatedColor )\r\n\t\t\t) {\r\n\r\n\t\t\t\t// get the material pdf\r\n\t\t\t\tvec3 sampleColor;\r\n\t\t\t\tfloat envMaterialPdf = bsdfResult( worldWo, envDirection, surf, sampleColor );\r\n\t\t\t\tbool isValidSampleColor = all( greaterThanEqual( sampleColor, vec3( 0.0 ) ) );\r\n\t\t\t\tif ( envMaterialPdf > 0.0 && isValidSampleColor ) {\r\n\r\n\t\t\t\t\t// weight the direct light contribution\r\n\t\t\t\t\tenvPdf /= lightsDenom;\r\n\t\t\t\t\tfloat misWeight = misHeuristic( envPdf, envMaterialPdf );\r\n\t\t\t\t\tresult = attenuatedColor * environmentIntensity * envColor * state.throughputColor * sampleColor * misWeight / envPdf;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Function changed to have a single return statement to potentially help with crashes on Mac OS.\r\n\t\t// See issue #470\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","\r\nexport const get_surface_record_function = /* glsl */`\r\n\r\n\t#define SKIP_SURFACE 0\r\n\t#define HIT_SURFACE 1\r\n\tint getSurfaceRecord(\r\n\t\tMaterial material, SurfaceHit surfaceHit, sampler2DArray attributesArray,\r\n\t\tfloat accumulatedRoughness,\r\n\t\tinout SurfaceRecord surf\r\n\t) {\r\n\r\n\t\tif ( material.fogVolume ) {\r\n\r\n\t\t\tvec3 normal = vec3( 0, 0, 1 );\r\n\r\n\t\t\tSurfaceRecord fogSurface;\r\n\t\t\tfogSurface.volumeParticle = true;\r\n\t\t\tfogSurface.color = material.color;\r\n\t\t\tfogSurface.emission = material.emissiveIntensity * material.emissive;\r\n\t\t\tfogSurface.normal = normal;\r\n\t\t\tfogSurface.faceNormal = normal;\r\n\t\t\tfogSurface.clearcoatNormal = normal;\r\n\r\n\t\t\tsurf = fogSurface;\r\n\t\t\treturn HIT_SURFACE;\r\n\r\n\t\t}\r\n\r\n\t\t// uv coord for textures\r\n\t\tvec2 uv = textureSampleBarycoord( attributesArray, ATTR_UV, surfaceHit.barycoord, surfaceHit.faceIndices.xyz ).xy;\r\n\t\tvec4 vertexColor = textureSampleBarycoord( attributesArray, ATTR_COLOR, surfaceHit.barycoord, surfaceHit.faceIndices.xyz );\r\n\r\n\t\t// albedo\r\n\t\tvec4 albedo = vec4( material.color, material.opacity );\r\n\t\tif ( material.map != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.mapTransform * vec3( uv, 1 );\r\n\t\t\talbedo *= texture2D( textures, vec3( uvPrime.xy, material.map ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.vertexColors ) {\r\n\r\n\t\t\talbedo *= vertexColor;\r\n\r\n\t\t}\r\n\r\n\t\t// alphaMap\r\n\t\tif ( material.alphaMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.alphaMapTransform * vec3( uv, 1 );\r\n\t\t\talbedo.a *= texture2D( textures, vec3( uvPrime.xy, material.alphaMap ) ).x;\r\n\r\n\t\t}\r\n\r\n\t\t// possibly skip this sample if it's transparent, alpha test is enabled, or we hit the wrong material side\r\n\t\t// and it's single sided.\r\n\t\t// - alpha test is disabled when it === 0\r\n\t\t// - the material sidedness test is complicated because we want light to pass through the back side but still\r\n\t\t// be able to see the front side. This boolean checks if the side we hit is the front side on the first ray\r\n\t\t// and we're rendering the other then we skip it. Do the opposite on subsequent bounces to get incoming light.\r\n\t\tfloat alphaTest = material.alphaTest;\r\n\t\tbool useAlphaTest = alphaTest != 0.0;\r\n\t\tif (\r\n\t\t\t// material sidedness\r\n\t\t\tmaterial.side != 0.0 && surfaceHit.side != material.side\r\n\r\n\t\t\t// alpha test\r\n\t\t\t|| useAlphaTest && albedo.a < alphaTest\r\n\r\n\t\t\t// opacity\r\n\t\t\t|| material.transparent && ! useAlphaTest && albedo.a < rand( 3 )\r\n\t\t) {\r\n\r\n\t\t\treturn SKIP_SURFACE;\r\n\r\n\t\t}\r\n\r\n\t\t// fetch the interpolated smooth normal\r\n\t\tvec3 normal = normalize( textureSampleBarycoord(\r\n\t\t\tattributesArray,\r\n\t\t\tATTR_NORMAL,\r\n\t\t\tsurfaceHit.barycoord,\r\n\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t).xyz );\r\n\r\n\t\t// roughness\r\n\t\tfloat roughness = material.roughness;\r\n\t\tif ( material.roughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.roughnessMapTransform * vec3( uv, 1 );\r\n\t\t\troughness *= texture2D( textures, vec3( uvPrime.xy, material.roughnessMap ) ).g;\r\n\r\n\t\t}\r\n\r\n\t\t// metalness\r\n\t\tfloat metalness = material.metalness;\r\n\t\tif ( material.metalnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.metalnessMapTransform * vec3( uv, 1 );\r\n\t\t\tmetalness *= texture2D( textures, vec3( uvPrime.xy, material.metalnessMap ) ).b;\r\n\r\n\t\t}\r\n\r\n\t\t// emission\r\n\t\tvec3 emission = material.emissiveIntensity * material.emissive;\r\n\t\tif ( material.emissiveMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.emissiveMapTransform * vec3( uv, 1 );\r\n\t\t\temission *= texture2D( textures, vec3( uvPrime.xy, material.emissiveMap ) ).xyz;\r\n\r\n\t\t}\r\n\r\n\t\t// transmission\r\n\t\tfloat transmission = material.transmission;\r\n\t\tif ( material.transmissionMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.transmissionMapTransform * vec3( uv, 1 );\r\n\t\t\ttransmission *= texture2D( textures, vec3( uvPrime.xy, material.transmissionMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// normal\r\n\t\tif ( material.flatShading ) {\r\n\r\n\t\t\t// if we're rendering a flat shaded object then use the face normals - the face normal\r\n\t\t\t// is provided based on the side the ray hits the mesh so flip it to align with the\r\n\t\t\t// interpolated vertex normals.\r\n\t\t\tnormal = surfaceHit.faceNormal * surfaceHit.side;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 baseNormal = normal;\r\n\t\tif ( material.normalMap != - 1 ) {\r\n\r\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\tattributesArray,\r\n\t\t\t\tATTR_TANGENT,\r\n\t\t\t\tsurfaceHit.barycoord,\r\n\t\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t\t);\r\n\r\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\tvec3 bitangent = normalize( cross( normal, tangent ) * tangentSample.w );\r\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\r\n\r\n\t\t\t\tvec3 uvPrime = material.normalMapTransform * vec3( uv, 1 );\r\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.normalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\ttexNormal.xy *= material.normalScale;\r\n\t\t\t\tnormal = vTBN * texNormal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tnormal *= surfaceHit.side;\r\n\r\n\t\t// clearcoat\r\n\t\tfloat clearcoat = material.clearcoat;\r\n\t\tif ( material.clearcoatMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.clearcoatMapTransform * vec3( uv, 1 );\r\n\t\t\tclearcoat *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// clearcoatRoughness\r\n\t\tfloat clearcoatRoughness = material.clearcoatRoughness;\r\n\t\tif ( material.clearcoatRoughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.clearcoatRoughnessMapTransform * vec3( uv, 1 );\r\n\t\t\tclearcoatRoughness *= texture2D( textures, vec3( uvPrime.xy, material.clearcoatRoughnessMap ) ).g;\r\n\r\n\t\t}\r\n\r\n\t\t// clearcoatNormal\r\n\t\tvec3 clearcoatNormal = baseNormal;\r\n\t\tif ( material.clearcoatNormalMap != - 1 ) {\r\n\r\n\t\t\tvec4 tangentSample = textureSampleBarycoord(\r\n\t\t\t\tattributesArray,\r\n\t\t\t\tATTR_TANGENT,\r\n\t\t\t\tsurfaceHit.barycoord,\r\n\t\t\t\tsurfaceHit.faceIndices.xyz\r\n\t\t\t);\r\n\r\n\t\t\t// some provided tangents can be malformed (0, 0, 0) causing the normal to be degenerate\r\n\t\t\t// resulting in NaNs and slow path tracing.\r\n\t\t\tif ( length( tangentSample.xyz ) > 0.0 ) {\r\n\r\n\t\t\t\tvec3 tangent = normalize( tangentSample.xyz );\r\n\t\t\t\tvec3 bitangent = normalize( cross( clearcoatNormal, tangent ) * tangentSample.w );\r\n\t\t\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\r\n\r\n\t\t\t\tvec3 uvPrime = material.clearcoatNormalMapTransform * vec3( uv, 1 );\r\n\t\t\t\tvec3 texNormal = texture2D( textures, vec3( uvPrime.xy, material.clearcoatNormalMap ) ).xyz * 2.0 - 1.0;\r\n\t\t\t\ttexNormal.xy *= material.clearcoatNormalScale;\r\n\t\t\t\tclearcoatNormal = vTBN * texNormal;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tclearcoatNormal *= surfaceHit.side;\r\n\r\n\t\t// sheenColor\r\n\t\tvec3 sheenColor = material.sheenColor;\r\n\t\tif ( material.sheenColorMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.sheenColorMapTransform * vec3( uv, 1 );\r\n\t\t\tsheenColor *= texture2D( textures, vec3( uvPrime.xy, material.sheenColorMap ) ).rgb;\r\n\r\n\t\t}\r\n\r\n\t\t// sheenRoughness\r\n\t\tfloat sheenRoughness = material.sheenRoughness;\r\n\t\tif ( material.sheenRoughnessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.sheenRoughnessMapTransform * vec3( uv, 1 );\r\n\t\t\tsheenRoughness *= texture2D( textures, vec3( uvPrime.xy, material.sheenRoughnessMap ) ).a;\r\n\r\n\t\t}\r\n\r\n\t\t// iridescence\r\n\t\tfloat iridescence = material.iridescence;\r\n\t\tif ( material.iridescenceMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.iridescenceMapTransform * vec3( uv, 1 );\r\n\t\t\tiridescence *= texture2D( textures, vec3( uvPrime.xy, material.iridescenceMap ) ).r;\r\n\r\n\t\t}\r\n\r\n\t\t// iridescence thickness\r\n\t\tfloat iridescenceThickness = material.iridescenceThicknessMaximum;\r\n\t\tif ( material.iridescenceThicknessMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.iridescenceThicknessMapTransform * vec3( uv, 1 );\r\n\t\t\tfloat iridescenceThicknessSampled = texture2D( textures, vec3( uvPrime.xy, material.iridescenceThicknessMap ) ).g;\r\n\t\t\tiridescenceThickness = mix( material.iridescenceThicknessMinimum, material.iridescenceThicknessMaximum, iridescenceThicknessSampled );\r\n\r\n\t\t}\r\n\r\n\t\tiridescence = iridescenceThickness == 0.0 ? 0.0 : iridescence;\r\n\r\n\t\t// specular color\r\n\t\tvec3 specularColor = material.specularColor;\r\n\t\tif ( material.specularColorMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.specularColorMapTransform * vec3( uv, 1 );\r\n\t\t\tspecularColor *= texture2D( textures, vec3( uvPrime.xy, material.specularColorMap ) ).rgb;\r\n\r\n\t\t}\r\n\r\n\t\t// specular intensity\r\n\t\tfloat specularIntensity = material.specularIntensity;\r\n\t\tif ( material.specularIntensityMap != - 1 ) {\r\n\r\n\t\t\tvec3 uvPrime = material.specularIntensityMapTransform * vec3( uv, 1 );\r\n\t\t\tspecularIntensity *= texture2D( textures, vec3( uvPrime.xy, material.specularIntensityMap ) ).a;\r\n\r\n\t\t}\r\n\r\n\t\tsurf.volumeParticle = false;\r\n\r\n\t\tsurf.faceNormal = surfaceHit.faceNormal;\r\n\t\tsurf.normal = normal;\r\n\r\n\t\tsurf.metalness = metalness;\r\n\t\tsurf.color = albedo.rgb;\r\n\t\tsurf.emission = emission;\r\n\r\n\t\tsurf.ior = material.ior;\r\n\t\tsurf.transmission = transmission;\r\n\t\tsurf.thinFilm = material.thinFilm;\r\n\t\tsurf.attenuationColor = material.attenuationColor;\r\n\t\tsurf.attenuationDistance = material.attenuationDistance;\r\n\r\n\t\tsurf.clearcoatNormal = clearcoatNormal;\r\n\t\tsurf.clearcoat = clearcoat;\r\n\r\n\t\tsurf.sheen = material.sheen;\r\n\t\tsurf.sheenColor = sheenColor;\r\n\r\n\t\tsurf.iridescence = iridescence;\r\n\t\tsurf.iridescenceIor = material.iridescenceIor;\r\n\t\tsurf.iridescenceThickness = iridescenceThickness;\r\n\r\n\t\tsurf.specularColor = specularColor;\r\n\t\tsurf.specularIntensity = specularIntensity;\r\n\r\n\t\t// apply perceptual roughness factor from gltf. sheen perceptual roughness is\r\n\t\t// applied by its brdf function\r\n\t\t// https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#microfacet-surfaces\r\n\t\tsurf.roughness = roughness * roughness;\r\n\t\tsurf.clearcoatRoughness = clearcoatRoughness * clearcoatRoughness;\r\n\t\tsurf.sheenRoughness = sheenRoughness;\r\n\r\n\t\t// frontFace is used to determine transmissive properties and PDF. If no transmission is used\r\n\t\t// then we can just always assume this is a front face.\r\n\t\tsurf.frontFace = surfaceHit.side == 1.0 || transmission == 0.0;\r\n\t\tsurf.eta = material.thinFilm || surf.frontFace ? 1.0 / material.ior : material.ior;\r\n\t\tsurf.f0 = iorRatioToF0( surf.eta );\r\n\r\n\t\t// Compute the filtered roughness value to use during specular reflection computations.\r\n\t\t// The accumulated roughness value is scaled by a user setting and a \"magic value\" of 5.0.\r\n\t\t// If we're exiting something transmissive then scale the factor down significantly so we can retain\r\n\t\t// sharp internal reflections\r\n\t\tsurf.filteredRoughness = applyFilteredGlossy( surf.roughness, accumulatedRoughness );\r\n\t\tsurf.filteredClearcoatRoughness = applyFilteredGlossy( surf.clearcoatRoughness, accumulatedRoughness );\r\n\r\n\t\t// get the normal frames\r\n\t\tsurf.normalBasis = getBasisFromNormal( surf.normal );\r\n\t\tsurf.normalInvBasis = inverse( surf.normalBasis );\r\n\r\n\t\tsurf.clearcoatBasis = getBasisFromNormal( surf.clearcoatNormal );\r\n\t\tsurf.clearcoatInvBasis = inverse( surf.clearcoatBasis );\r\n\r\n\t\treturn HIT_SURFACE;\r\n\r\n\t}\r\n`;\r\n","export const render_structs = /* glsl */`\r\n\r\n\tstruct Ray {\r\n\r\n\t\tvec3 origin;\r\n\t\tvec3 direction;\r\n\r\n\t};\r\n\r\n\tstruct SurfaceHit {\r\n\r\n\t\tuvec4 faceIndices;\r\n\t\tvec3 barycoord;\r\n\t\tvec3 faceNormal;\r\n\t\tfloat side;\r\n\t\tfloat dist;\r\n\r\n\t};\r\n\r\n\tstruct RenderState {\r\n\r\n\t\tbool firstRay;\r\n\t\tbool transmissiveRay;\r\n\t\tbool isShadowRay;\r\n\t\tfloat accumulatedRoughness;\r\n\t\tint transmissiveTraversals;\r\n\t\tint traversals;\r\n\t\tuint depth;\r\n\t\tvec3 throughputColor;\r\n\t\tMaterial fogMaterial;\r\n\r\n\t};\r\n\r\n\tRenderState initRenderState() {\r\n\r\n\t\tRenderState result;\r\n\t\tresult.firstRay = true;\r\n\t\tresult.transmissiveRay = true;\r\n\t\tresult.isShadowRay = false;\r\n\t\tresult.accumulatedRoughness = 0.0;\r\n\t\tresult.transmissiveTraversals = 0;\r\n\t\tresult.traversals = 0;\r\n\t\tresult.throughputColor = vec3( 1.0 );\r\n\t\tresult.depth = 0u;\r\n\t\tresult.fogMaterial.fogVolume = false;\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const trace_scene_function = /* glsl */`\r\n\r\n\t#define NO_HIT 0\r\n\t#define SURFACE_HIT 1\r\n\t#define LIGHT_HIT 2\r\n\t#define FOG_HIT 3\r\n\r\n\t// Passing the global variable 'lights' into this function caused shader program errors.\r\n\t// So global variables like 'lights' and 'bvh' were moved out of the function parameters.\r\n\t// For more information, refer to: https://github.com/disini/three-gpu-pathtracer/pull/457\r\n\tint traceScene(\r\n\t\tRay ray, Material fogMaterial, inout SurfaceHit surfaceHit\r\n\t) {\r\n\r\n\t\tint result = NO_HIT;\r\n\t\tbool hit = bvhIntersectFirstHit( bvh, ray.origin, ray.direction, surfaceHit.faceIndices, surfaceHit.faceNormal, surfaceHit.barycoord, surfaceHit.side, surfaceHit.dist );\r\n\r\n\t\t#if FEATURE_FOG\r\n\r\n\t\tif ( fogMaterial.fogVolume ) {\r\n\r\n\t\t\t// offset the distance so we don't run into issues with particles on the same surface\r\n\t\t\t// as other objects\r\n\t\t\tfloat particleDist = intersectFogVolume( fogMaterial, rand( 1 ) );\r\n\t\t\tif ( particleDist + RAY_OFFSET < surfaceHit.dist ) {\r\n\r\n\t\t\t\tsurfaceHit.side = 1.0;\r\n\t\t\t\tsurfaceHit.faceNormal = normalize( - ray.direction );\r\n\t\t\t\tsurfaceHit.dist = particleDist;\r\n\t\t\t\treturn FOG_HIT;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t#endif\r\n\r\n\t\tif ( hit ) {\r\n\r\n\t\t\tresult = SURFACE_HIT;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","import { Color, Vector3 } from 'three';\r\nimport { ProceduralEquirectTexture } from './ProceduralEquirectTexture.js';\r\n\r\nconst _direction = new Vector3();\r\nexport class GradientEquirectTexture extends ProceduralEquirectTexture {\r\n\r\n\tconstructor( resolution = 512 ) {\r\n\r\n\t\tsuper( resolution, resolution );\r\n\r\n\t\tthis.topColor = new Color().set( 0xffffff );\r\n\t\tthis.bottomColor = new Color().set( 0x000000 );\r\n\t\tthis.exponent = 2;\r\n\t\tthis.generationCallback = ( polar, uv, coord, color ) => {\r\n\r\n\t\t\t_direction.setFromSpherical( polar );\r\n\r\n\t\t\tconst t = _direction.y * 0.5 + 0.5;\r\n\t\t\tcolor.lerpColors( this.bottomColor, this.topColor, t ** this.exponent );\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\r\n\t\tthis.topColor.copy( other.topColor );\r\n\t\tthis.bottomColor.copy( other.bottomColor );\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import {\r\n\tClampToEdgeWrapping,\r\n\tColor,\r\n\tDataTexture,\r\n\tEquirectangularReflectionMapping,\r\n\tLinearFilter,\r\n\tRepeatWrapping,\r\n\tRGBAFormat,\r\n\tSpherical,\r\n\tVector2,\r\n\tFloatType\r\n} from 'three';\r\n\r\nconst _uv = new Vector2();\r\nconst _coord = new Vector2();\r\nconst _polar = new Spherical();\r\nconst _color = new Color();\r\nexport class ProceduralEquirectTexture extends DataTexture {\r\n\r\n\tconstructor( width = 512, height = 512 ) {\r\n\r\n\t\tsuper(\r\n\t\t\tnew Float32Array( width * height * 4 ),\r\n\t\t\twidth, height, RGBAFormat, FloatType, EquirectangularReflectionMapping,\r\n\t\t\tRepeatWrapping, ClampToEdgeWrapping, LinearFilter, LinearFilter,\r\n\t\t);\r\n\r\n\t\tthis.generationCallback = null;\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tthis.dispose();\r\n\t\tthis.needsUpdate = true;\r\n\r\n\t\tconst { data, width, height } = this.image;\r\n\t\tfor ( let x = 0; x < width; x ++ ) {\r\n\r\n\t\t\tfor ( let y = 0; y < height; y ++ ) {\r\n\r\n\t\t\t\t_coord.set( width, height );\r\n\r\n\t\t\t\t_uv.set( x / width, y / height );\r\n\t\t\t\t_uv.x -= 0.5;\r\n\t\t\t\t_uv.y = 1.0 - _uv.y;\r\n\r\n\t\t\t\t_polar.theta = _uv.x * 2.0 * Math.PI;\r\n\t\t\t\t_polar.phi = _uv.y * Math.PI;\r\n\t\t\t\t_polar.radius = 1.0;\r\n\r\n\t\t\t\tthis.generationCallback( _polar, _uv, _coord, _color );\r\n\r\n\t\t\t\tconst i = y * width + x;\r\n\t\t\t\tconst i4 = 4 * i;\r\n\t\t\t\tdata[ i4 + 0 ] = ( _color.r );\r\n\t\t\t\tdata[ i4 + 1 ] = ( _color.g );\r\n\t\t\t\tdata[ i4 + 2 ] = ( _color.b );\r\n\t\t\t\tdata[ i4 + 3 ] = ( 1.0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tcopy( other ) {\r\n\r\n\t\tsuper.copy( other );\r\n\t\tthis.generationCallback = other.generationCallback;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import { ShaderMaterial } from 'three';\r\n\r\n// Material that tone maps a texture before performing interpolation to prevent\r\n// unexpected high values during texture stretching interpolation.\r\n// Emulates browser image stretching\r\nexport class ClampedInterpolationMaterial extends ShaderMaterial {\r\n\r\n\tget map() {\r\n\r\n\t\treturn this.uniforms.map.value;\r\n\r\n\t}\r\n\r\n\tset map( v ) {\r\n\r\n\t\tthis.uniforms.map.value = v;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this.uniforms.opacity.value;\r\n\r\n\t}\r\n\r\n\tset opacity( v ) {\r\n\r\n\t\tif ( this.uniforms ) {\r\n\r\n\t\t\tthis.uniforms.opacity.value = v;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tconstructor( params ) {\r\n\r\n\t\tsuper( {\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tmap: { value: null },\r\n\t\t\t\topacity: { value: 1 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\tuniform sampler2D map;\r\n\t\t\t\tuniform float opacity;\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvec4 clampedTexelFatch( sampler2D map, ivec2 px, int lod ) {\r\n\r\n\t\t\t\t\tvec4 res = texelFetch( map, ivec2( px.x, px.y ), 0 );\r\n\r\n\t\t\t\t\t#if defined( TONE_MAPPING )\r\n\r\n\t\t\t\t\tres.xyz = toneMapping( res.xyz );\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t  \t\treturn linearToOutputTexel( res );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec2 size = vec2( textureSize( map, 0 ) );\r\n\t\t\t\t\tvec2 pxUv = vUv * size;\r\n\t\t\t\t\tvec2 pxCurr = floor( pxUv );\r\n\t\t\t\t\tvec2 pxFrac = fract( pxUv ) - 0.5;\r\n\t\t\t\t\tvec2 pxOffset;\r\n\t\t\t\t\tpxOffset.x = pxFrac.x > 0.0 ? 1.0 : - 1.0;\r\n\t\t\t\t\tpxOffset.y = pxFrac.y > 0.0 ? 1.0 : - 1.0;\r\n\r\n\t\t\t\t\tvec2 pxNext = clamp( pxOffset + pxCurr, vec2( 0.0 ), size - 1.0 );\r\n\t\t\t\t\tvec2 alpha = abs( pxFrac );\r\n\r\n\t\t\t\t\tvec4 p1 = mix(\r\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxCurr.y ), 0 ),\r\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxCurr.y ), 0 ),\r\n\t\t\t\t\t\talpha.x\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tvec4 p2 = mix(\r\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxCurr.x, pxNext.y ), 0 ),\r\n\t\t\t\t\t\tclampedTexelFatch( map, ivec2( pxNext.x, pxNext.y ), 0 ),\r\n\t\t\t\t\t\talpha.x\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t\tgl_FragColor = mix( p1, p2, alpha.y );\r\n\t\t\t\t\tgl_FragColor.a *= opacity;\r\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\r\n\r\n\t\t\t\t}\r\n\t\t\t`\r\n\t\t} );\r\n\r\n\t\tthis.setValues( params );\r\n\r\n\t}\r\n\r\n}\r\n","import {\r\n\tDataTexture,\r\n\tDataUtils,\r\n\tEquirectangularReflectionMapping,\r\n\tFloatType,\r\n\tHalfFloatType,\r\n\tLinearFilter,\r\n\tLinearMipMapLinearFilter,\r\n\tRGBAFormat,\r\n\tRepeatWrapping,\r\n\tShaderMaterial,\r\n\tWebGLRenderTarget,\r\n} from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport * as CommonGLSL from '../shader/common/index.js';\r\n\r\nclass CubeToEquirectMaterial extends ShaderMaterial {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tenvMap: { value: null },\r\n\t\t\t\tflipEnvMap: { value: - 1 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\t\t\t\t#define ENVMAP_TYPE_CUBE_UV\r\n\r\n\t\t\t\tuniform samplerCube envMap;\r\n\t\t\t\tuniform float flipEnvMap;\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <cube_uv_reflection_fragment>\r\n\r\n\t\t\t\t${ CommonGLSL.util_functions }\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\r\n\t\t\t\t\trayDirection.x *= flipEnvMap;\r\n\t\t\t\t\tgl_FragColor = textureCube( envMap, rayDirection );\r\n\r\n\t\t\t\t}`\r\n\t\t} );\r\n\r\n\t\tthis.depthWrite = false;\r\n\t\tthis.depthTest = false;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class CubeToEquirectGenerator {\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis._renderer = renderer;\r\n\t\tthis._quad = new FullScreenQuad( new CubeToEquirectMaterial() );\r\n\r\n\t}\r\n\r\n\tgenerate( source, width = null, height = null ) {\r\n\r\n\t\tif ( ! source.isCubeTexture ) {\r\n\r\n\t\t\tthrow new Error( 'CubeToEquirectMaterial: Source can only be cube textures.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst image = source.images[ 0 ];\r\n\t\tconst renderer = this._renderer;\r\n\t\tconst quad = this._quad;\r\n\r\n\t\t// determine the dimensions if not provided\r\n\t\tif ( width === null ) {\r\n\r\n\t\t\twidth = 4 * image.height;\r\n\r\n\t\t}\r\n\r\n\t\tif ( height === null ) {\r\n\r\n\t\t\theight = 2 * image.height;\r\n\r\n\t\t}\r\n\r\n\t\tconst target = new WebGLRenderTarget( width, height, {\r\n\t\t\ttype: FloatType,\r\n\t\t\tcolorSpace: image.colorSpace,\r\n\t\t} );\r\n\r\n\t\t// prep the cube map data\r\n\t\tconst imageHeight = image.height;\r\n\t\tconst maxMip = Math.log2( imageHeight ) - 2;\r\n\t\tconst texelHeight = 1.0 / imageHeight;\r\n\t\tconst texelWidth = 1.0 / ( 3 * Math.max( Math.pow( 2, maxMip ), 7 * 16 ) );\r\n\r\n\t\tquad.material.defines.CUBEUV_MAX_MIP = `${ maxMip }.0`;\r\n\t\tquad.material.defines.CUBEUV_TEXEL_WIDTH = texelWidth;\r\n\t\tquad.material.defines.CUBEUV_TEXEL_HEIGHT = texelHeight;\r\n\t\tquad.material.uniforms.envMap.value = source;\r\n\t\tquad.material.uniforms.flipEnvMap.value = source.isRenderTargetTexture ? 1 : - 1;\r\n\t\tquad.material.needsUpdate = true;\r\n\r\n\t\t// save state and render the contents\r\n\t\tconst currentTarget = renderer.getRenderTarget();\r\n\t\tconst currentAutoClear = renderer.autoClear;\r\n\t\trenderer.autoClear = true;\r\n\t\trenderer.setRenderTarget( target );\r\n\t\tquad.render( renderer );\r\n\t\trenderer.setRenderTarget( currentTarget );\r\n\t\trenderer.autoClear = currentAutoClear;\r\n\r\n\t\t// read the data back\r\n\t\tconst buffer = new Uint16Array( width * height * 4 );\r\n\t\tconst readBuffer = new Float32Array( width * height * 4 );\r\n\t\trenderer.readRenderTargetPixels( target, 0, 0, width, height, readBuffer );\r\n\t\ttarget.dispose();\r\n\r\n\t\tfor ( let i = 0, l = readBuffer.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer[ i ] = DataUtils.toHalfFloat( readBuffer[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\t// produce the data texture\r\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, HalfFloatType );\r\n\t\tresult.minFilter = LinearMipMapLinearFilter;\r\n\t\tresult.magFilter = LinearFilter;\r\n\t\tresult.wrapS = RepeatWrapping;\r\n\t\tresult.wrapT = RepeatWrapping;\r\n\t\tresult.mapping = EquirectangularReflectionMapping;\r\n\t\tresult.needsUpdate = true;\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis._quad.dispose();\r\n\r\n\t}\r\n\r\n}\r\n","import { Camera } from 'three';\r\n\r\nexport class EquirectCamera extends Camera {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.isEquirectCamera = true;\r\n\r\n\t}\r\n\r\n}\r\n","import { SpotLight } from 'three';\r\n\r\nexport class PhysicalSpotLight extends SpotLight {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.iesMap = null;\r\n\t\tthis.radius = 0;\r\n\r\n\t}\r\n\r\n\tcopy( source, recursive ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.iesMap = source.iesMap;\r\n\t\tthis.radius = source.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import { RectAreaLight } from 'three';\r\n\r\nexport class ShapedAreaLight extends RectAreaLight {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tthis.isCircular = false;\r\n\r\n\t}\r\n\r\n\tcopy( source, recursive ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.isCircular = source.isCircular;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","import { WebGLRenderTarget, RGBAFormat, HalfFloatType, PMREMGenerator, DataTexture, EquirectangularReflectionMapping, FloatType, DataUtils } from 'three';\r\nimport { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass.js';\r\nimport { MaterialBase } from '../materials/MaterialBase.js';\r\nimport * as CommonGLSL from '../shader/common/index.js';\r\n\r\nclass PMREMCopyMaterial extends MaterialBase {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tenvMap: { value: null },\r\n\t\t\t\tblur: { value: 0 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\t#include <common>\r\n\t\t\t\t#include <cube_uv_reflection_fragment>\r\n\r\n\t\t\t\t${ CommonGLSL.util_functions }\r\n\r\n\t\t\t\tuniform sampler2D envMap;\r\n\t\t\t\tuniform float blur;\r\n\t\t\t\tvarying vec2 vUv;\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvec3 rayDirection = equirectUvToDirection( vUv );\r\n\t\t\t\t\tgl_FragColor = textureCubeUV( envMap, rayDirection, blur );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class BlurredEnvMapGenerator {\r\n\r\n\tconstructor( renderer ) {\r\n\r\n\t\tthis.renderer = renderer;\r\n\t\tthis.pmremGenerator = new PMREMGenerator( renderer );\r\n\t\tthis.copyQuad = new FullScreenQuad( new PMREMCopyMaterial() );\r\n\t\tthis.renderTarget = new WebGLRenderTarget( 1, 1, { type: FloatType, format: RGBAFormat } );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.pmremGenerator.dispose();\r\n\t\tthis.copyQuad.dispose();\r\n\t\tthis.renderTarget.dispose();\r\n\r\n\t}\r\n\r\n\tgenerate( texture, blur ) {\r\n\r\n\t\tconst { pmremGenerator, renderTarget, copyQuad, renderer } = this;\r\n\r\n\t\t// get the pmrem target\r\n\t\tconst pmremTarget = pmremGenerator.fromEquirectangular( texture );\r\n\r\n\t\t// set up the material\r\n\t\tconst { width, height } = texture.image;\r\n\t\trenderTarget.setSize( width, height );\r\n\t\tcopyQuad.material.envMap = pmremTarget.texture;\r\n\t\tcopyQuad.material.blur = blur;\r\n\r\n\t\t// render\r\n\t\tconst prevRenderTarget = renderer.getRenderTarget();\r\n\t\tconst prevClear = renderer.autoClear;\r\n\r\n\t\trenderer.setRenderTarget( renderTarget );\r\n\t\trenderer.autoClear = true;\r\n\t\tcopyQuad.render( renderer );\r\n\r\n\t\trenderer.setRenderTarget( prevRenderTarget );\r\n\t\trenderer.autoClear = prevClear;\r\n\r\n\t\t// read the data back\r\n\t\tconst buffer = new Uint16Array( width * height * 4 );\r\n\t\tconst readBuffer = new Float32Array( width * height * 4 );\r\n\t\trenderer.readRenderTargetPixels( renderTarget, 0, 0, width, height, readBuffer );\r\n\r\n\t\tfor ( let i = 0, l = readBuffer.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer[ i ] = DataUtils.toHalfFloat( readBuffer[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\tconst result = new DataTexture( buffer, width, height, RGBAFormat, HalfFloatType );\r\n\t\tresult.minFilter = texture.minFilter;\r\n\t\tresult.magFilter = texture.magFilter;\r\n\t\tresult.wrapS = texture.wrapS;\r\n\t\tresult.wrapT = texture.wrapT;\r\n\t\tresult.mapping = EquirectangularReflectionMapping;\r\n\t\tresult.needsUpdate = true;\r\n\r\n\t\t// dispose of the now unneeded target\r\n\t\tpmremTarget.dispose();\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n","import { NoBlending } from 'three';\r\nimport { MaterialBase } from '../MaterialBase.js';\r\n\r\nexport class DenoiseMaterial extends MaterialBase {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\tblending: NoBlending,\r\n\r\n\t\t\ttransparent: false,\r\n\r\n\t\t\tdepthWrite: false,\r\n\r\n\t\t\tdepthTest: false,\r\n\r\n\t\t\tdefines: {\r\n\r\n\t\t\t\tUSE_SLIDER: 0,\r\n\r\n\t\t\t},\r\n\r\n\t\t\tuniforms: {\r\n\r\n\t\t\t\tsigma: { value: 5.0 },\r\n\t\t\t\tthreshold: { value: 0.03 },\r\n\t\t\t\tkSigma: { value: 1.0 },\r\n\r\n\t\t\t\tmap: { value: null },\r\n\t\t\t\topacity: { value: 1 },\r\n\r\n\t\t\t},\r\n\r\n\t\t\tvertexShader: /* glsl */`\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tvUv = uv;\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`,\r\n\r\n\t\t\tfragmentShader: /* glsl */`\r\n\r\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\t\t\t\t//  Copyright (c) 2018-2019 Michele Morrone\r\n\t\t\t\t//  All rights reserved.\r\n\t\t\t\t//\r\n\t\t\t\t//  https://michelemorrone.eu - https://BrutPitt.com\r\n\t\t\t\t//\r\n\t\t\t\t//  me@michelemorrone.eu - brutpitt@gmail.com\r\n\t\t\t\t//  twitter: @BrutPitt - github: BrutPitt\r\n\t\t\t\t//\r\n\t\t\t\t//  https://github.com/BrutPitt/glslSmartDeNoise/\r\n\t\t\t\t//\r\n\t\t\t\t//  This software is distributed under the terms of the BSD 2-Clause license\r\n\t\t\t\t//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n\r\n\t\t\t\tuniform sampler2D map;\r\n\r\n\t\t\t\tuniform float sigma;\r\n\t\t\t\tuniform float threshold;\r\n\t\t\t\tuniform float kSigma;\r\n\t\t\t\tuniform float opacity;\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t\t#define INV_SQRT_OF_2PI 0.39894228040143267793994605993439\r\n\t\t\t\t#define INV_PI 0.31830988618379067153776752674503\r\n\r\n\t\t\t\t// Parameters:\r\n\t\t\t\t//\t sampler2D tex\t - sampler image / texture\r\n\t\t\t\t//\t vec2 uv\t\t   - actual fragment coord\r\n\t\t\t\t//\t float sigma  >  0 - sigma Standard Deviation\r\n\t\t\t\t//\t float kSigma >= 0 - sigma coefficient\r\n\t\t\t\t//\t\t kSigma * sigma  -->  radius of the circular kernel\r\n\t\t\t\t//\t float threshold   - edge sharpening threshold\r\n\t\t\t\tvec4 smartDeNoise( sampler2D tex, vec2 uv, float sigma, float kSigma, float threshold ) {\r\n\r\n\t\t\t\t\tfloat radius = round( kSigma * sigma );\r\n\t\t\t\t\tfloat radQ = radius * radius;\r\n\r\n\t\t\t\t\tfloat invSigmaQx2 = 0.5 / ( sigma * sigma );\r\n\t\t\t\t\tfloat invSigmaQx2PI = INV_PI * invSigmaQx2;\r\n\r\n\t\t\t\t\tfloat invThresholdSqx2 = 0.5 / ( threshold * threshold );\r\n\t\t\t\t\tfloat invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;\r\n\r\n\t\t\t\t\tvec4 centrPx = texture2D( tex, uv );\r\n\t\t\t\t\tcentrPx.rgb *= centrPx.a;\r\n\r\n\t\t\t\t\tfloat zBuff = 0.0;\r\n\t\t\t\t\tvec4 aBuff = vec4( 0.0 );\r\n\t\t\t\t\tvec2 size = vec2( textureSize( tex, 0 ) );\r\n\r\n\t\t\t\t\tvec2 d;\r\n\t\t\t\t\tfor ( d.x = - radius; d.x <= radius; d.x ++ ) {\r\n\r\n\t\t\t\t\t\tfloat pt = sqrt( radQ - d.x * d.x );\r\n\r\n\t\t\t\t\t\tfor ( d.y = - pt; d.y <= pt; d.y ++ ) {\r\n\r\n\t\t\t\t\t\t\tfloat blurFactor = exp( - dot( d, d ) * invSigmaQx2 ) * invSigmaQx2PI;\r\n\r\n\t\t\t\t\t\t\tvec4 walkPx = texture2D( tex, uv + d / size );\r\n\t\t\t\t\t\t\twalkPx.rgb *= walkPx.a;\r\n\r\n\t\t\t\t\t\t\tvec4 dC = walkPx - centrPx;\r\n\t\t\t\t\t\t\tfloat deltaFactor = exp( - dot( dC.rgba, dC.rgba ) * invThresholdSqx2 ) * invThresholdSqrt2PI * blurFactor;\r\n\r\n\t\t\t\t\t\t\tzBuff += deltaFactor;\r\n\t\t\t\t\t\t\taBuff += deltaFactor * walkPx;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn aBuff / zBuff;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvoid main() {\r\n\r\n\t\t\t\t\tgl_FragColor = smartDeNoise( map, vec2( vUv.x, vUv.y ), sigma, kSigma, threshold );\r\n\t\t\t\t\t#include <tonemapping_fragment>\r\n\t\t\t\t\t#include <colorspace_fragment>\r\n\t\t\t\t\t#include <premultiplied_alpha_fragment>\r\n\r\n\t\t\t\t\tgl_FragColor.a *= opacity;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t`\r\n\r\n\t\t} );\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n}\r\n","import { Color, MeshStandardMaterial } from 'three';\r\n\r\nexport class FogVolumeMaterial extends MeshStandardMaterial {\r\n\r\n\tconstructor( params ) {\r\n\r\n\t\tsuper( params );\r\n\r\n\t\tthis.isFogVolumeMaterial = true;\r\n\r\n\t\tthis.density = 0.015;\r\n\t\tthis.emissive = new Color();\r\n\t\tthis.emissiveIntensity = 0.0;\r\n\t\tthis.opacity = 0.15;\r\n\t\tthis.transparent = true;\r\n\t\tthis.roughness = 1.0;\r\n\t\tthis.metalness = 0.0;\r\n\r\n\t\tthis.setValues( params );\r\n\r\n\t}\r\n\r\n}\r\n"],"names":[],"version":3,"file":"areaLight.c4483dbf.js.map","sourceRoot":"/__parcel_source_root/"}