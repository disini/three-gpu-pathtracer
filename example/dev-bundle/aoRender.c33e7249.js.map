{"mappings":"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","sources":["node_modules/three/examples/jsm/postprocessing/Pass.js","src/core/PathTracingSceneGenerator.js","node_modules/three-mesh-bvh/src/index.js","node_modules/three-mesh-bvh/src/core/MeshBVH.js","node_modules/three-mesh-bvh/src/core/Constants.js","node_modules/three-mesh-bvh/src/core/build/buildTree.js","node_modules/three-mesh-bvh/src/core/build/geometryUtils.js","node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js","node_modules/three-mesh-bvh/src/core/build/splitUtils.js","node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js","node_modules/three-mesh-bvh/src/core/MeshBVHNode.js","node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js","node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js","node_modules/three-mesh-bvh/src/core/build/buildUtils.js","node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js","node_modules/three-mesh-bvh/src/math/OrientedBox.js","node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js","node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js","node_modules/three-mesh-bvh/src/math/MathUtilities.js","node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js","node_modules/three-mesh-bvh/src/utils/PrimitivePool.js","node_modules/three-mesh-bvh/src/core/cast/shapecast.js","node_modules/three-mesh-bvh/src/core/utils/BufferStack.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js","node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js","node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js","node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js","node_modules/three-mesh-bvh/src/core/cast/refit.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js","node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js","node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js","node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js","node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js","node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js","node_modules/three-mesh-bvh/src/utils/BufferUtils.js","node_modules/three-mesh-bvh/src/core/cast/bvhcast.js","node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js","node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js","node_modules/three-mesh-bvh/src/gpu/BVHShaderGLSL.js","node_modules/three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js","node_modules/three-mesh-bvh/src/gpu/glsl/bvh_distance_functions.glsl.js","node_modules/three-mesh-bvh/src/gpu/glsl/bvh_ray_functions.glsl.js","node_modules/three-mesh-bvh/src/gpu/glsl/bvh_struct_definitions.glsl.js","src/core/utils/StaticGeometryGenerator.js","src/core/utils/mergeGeometries.js","src/core/utils/BufferAttributeUtils.js","src/core/utils/GeometryPreparationUtils.js","src/core/utils/BakedGeometry.js","src/core/utils/MeshDiff.js","src/utils/bufferToHash.js","src/core/utils/convertToStaticGeometry.js","src/shader/structs/index.js","src/shader/structs/camera_struct.glsl.js","src/shader/structs/equirect_struct.glsl.js","src/shader/structs/lights_struct.glsl.js","src/shader/structs/material_struct.glsl.js","src/shader/structs/surface_record_struct.glsl.js","src/shader/sampling/index.js","src/shader/sampling/equirect_sampling_functions.glsl.js","src/shader/sampling/light_sampling_functions.glsl.js","src/shader/sampling/shape_sampling_functions.glsl.js","src/shader/rand/index.js","src/shader/rand/pcg.glsl.js","src/shader/rand/sobol.glsl.js","src/shader/rand/stratified.glsl.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\tthis.isPass = true;\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n\tdispose() {}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nclass FullscreenTriangleGeometry extends BufferGeometry {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\n\t}\n\n}\n\nconst _geometry = new FullscreenTriangleGeometry();\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import { BufferGeometry } from 'three';\r\nimport { MeshBVH, SAH } from 'three-mesh-bvh';\r\nimport { StaticGeometryGenerator, NO_CHANGE, GEOMETRY_ADJUSTED, GEOMETRY_REBUILT } from './utils/StaticGeometryGenerator.js';\r\nimport { updateMaterialIndexAttribute } from './utils/GeometryPreparationUtils.js';\r\n\r\n// collect the textures from the materials\r\nfunction getTextures( materials ) {\r\n\r\n\tconst textureSet = new Set();\r\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\tconst material = materials[ i ];\r\n\t\tfor ( const key in material ) {\r\n\r\n\t\t\tconst value = material[ key ];\r\n\t\t\tif ( value && value.isTexture ) {\r\n\r\n\t\t\t\ttextureSet.add( value );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn Array.from( textureSet );\r\n\r\n}\r\n\r\n// collect the lights in the scene\r\nfunction getLights( objects ) {\r\n\r\n\tconst lights = [];\r\n\tconst iesSet = new Set();\r\n\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\tobjects[ i ].traverse( c => {\r\n\r\n\t\t\tif ( c.visible ) {\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tc.isRectAreaLight ||\r\n\t\t\t\t\tc.isSpotLight ||\r\n\t\t\t\t\tc.isPointLight ||\r\n\t\t\t\t\tc.isDirectionalLight\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tlights.push( c );\r\n\r\n\t\t\t\t\tif ( c.iesMap ) {\r\n\r\n\t\t\t\t\t\tiesSet.add( c.iesMap );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tconst iesTextures = Array.from( iesSet ).sort( ( a, b ) => {\r\n\r\n\t\tif ( a.uuid < b.uuid ) return 1;\r\n\t\tif ( a.uuid > b.uuid ) return - 1;\r\n\t\treturn 0;\r\n\r\n\t} );\r\n\r\n\treturn { lights, iesTextures };\r\n\r\n}\r\n\r\nexport class PathTracingSceneGenerator {\r\n\r\n\tget initialized() {\r\n\r\n\t\treturn Boolean( this.bvh );\r\n\r\n\t}\r\n\r\n\tconstructor( objects ) {\r\n\r\n\t\t// options\r\n\t\tthis.bvhOptions = {};\r\n\t\tthis.attributes = [ 'position', 'normal', 'tangent', 'color', 'uv', 'uv2' ];\r\n\t\tthis.generateBVH = true;\r\n\r\n\t\t// state\r\n\t\tthis.bvh = null;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.staticGeometryGenerator = new StaticGeometryGenerator( objects );\r\n\t\tthis._bvhWorker = null;\r\n\t\tthis._pendingGenerate = null;\r\n\t\tthis._buildAsync = false;\r\n\r\n\t}\r\n\r\n\tsetObjects( objects ) {\r\n\r\n\t\tthis.staticGeometryGenerator.setObjects( objects );\r\n\r\n\t}\r\n\r\n\tsetBVHWorker( bvhWorker ) {\r\n\r\n\t\tthis._bvhWorker = bvhWorker;\r\n\r\n\t}\r\n\r\n\tasync generateAsync( onProgress = null ) {\r\n\r\n\t\tif ( ! this._bvhWorker ) {\r\n\r\n\t\t\tthrow new Error( 'PathTracingSceneGenerator: \"setBVHWorker\" must be called before \"generateAsync\" can be called.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.bvh instanceof Promise ) {\r\n\r\n\t\t\t// if a bvh is already being generated we can wait for that to finish\r\n\t\t\t// and build another with the latest data while sharing the results.\r\n\t\t\tif ( ! this._pendingGenerate ) {\r\n\r\n\t\t\t\tthis._pendingGenerate = new Promise( async () => {\r\n\r\n\t\t\t\t\tawait this.bvh;\r\n\t\t\t\t\tthis._pendingGenerate = null;\r\n\r\n\t\t\t\t\t// TODO: support multiple callbacks queued?\r\n\t\t\t\t\treturn this.generateAsync( onProgress );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this._pendingGenerate;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._buildAsync = true;\r\n\t\t\tconst result = this.generate( onProgress );\r\n\t\t\tthis._buildAsync = false;\r\n\r\n\t\t\tresult.bvh = this.bvh = await result.bvh;\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( onProgress = null ) {\r\n\r\n\t\tconst { staticGeometryGenerator, geometry, attributes } = this;\r\n\t\tconst objects = staticGeometryGenerator.objects;\r\n\t\tstaticGeometryGenerator.attributes = attributes;\r\n\r\n\t\t// update the skeleton animations in case WebGLRenderer is not running\r\n\t\t// to update it.\r\n\t\tobjects.forEach( o => {\r\n\r\n\t\t\to.traverse( c => {\r\n\r\n\t\t\t\tif ( c.isSkinnedMesh && c.skeleton ) {\r\n\r\n\t\t\t\t\tc.skeleton.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t} );\r\n\r\n\t\t// generate the geometry\r\n\t\tconst result = staticGeometryGenerator.generate( geometry );\r\n\t\tconst materials = result.materials;\r\n\t\tconst textures = getTextures( materials );\r\n\t\tconst { lights, iesTextures } = getLights( objects );\r\n\r\n\t\tif ( result.changeType !== NO_CHANGE ) {\r\n\r\n\t\t\tupdateMaterialIndexAttribute( geometry, materials, materials );\r\n\r\n\t\t}\r\n\r\n\t\t// only generate a new bvh if the objects used have changed\r\n\t\tif ( this.generateBVH ) {\r\n\r\n\t\t\tif ( this.bvh instanceof Promise ) {\r\n\r\n\t\t\t\tthrow new Error( 'PathTracingSceneGenerator: BVH is already building asynchronously.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( result.changeType === GEOMETRY_REBUILT ) {\r\n\r\n\t\t\t\tconst bvhOptions = {\r\n\t\t\t\t\tstrategy: SAH,\r\n\t\t\t\t\tmaxLeafTris: 1,\r\n\t\t\t\t\tindirect: true,\r\n\t\t\t\t\tonProgress,\r\n\t\t\t\t\t...this.bvhOptions,\r\n\t\t\t\t};\r\n\r\n\t\t\t\tif ( this._buildAsync ) {\r\n\r\n\t\t\t\t\tthis.bvh = this._bvhWorker.generate( geometry, bvhOptions );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthis.bvh = new MeshBVH( geometry, bvhOptions );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( result.changeType === GEOMETRY_ADJUSTED ) {\r\n\r\n\t\t\t\tthis.bvh.refit();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\tbvhChanged: result.changeType !== NO_CHANGE,\r\n\t\t\tbvh: this.bvh,\r\n\t\t\tlights,\r\n\t\t\tiesTextures,\r\n\t\t\tgeometry,\r\n\t\t\tmaterials,\r\n\t\t\ttextures,\r\n\t\t\tobjects,\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class DynamicPathTracingSceneGenerator extends PathTracingSceneGenerator {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tconsole.warn( 'DynamicPathTracingSceneGenerator has been deprecated and renamed to \"PathTracingSceneGenerator\".' );\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport class PathTracingSceneWorker extends PathTracingSceneGenerator {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\t\tconsole.warn( 'PathTracingSceneWorker has been deprecated and renamed to \"PathTracingSceneGenerator\".' );\r\n\r\n\t}\r\n\r\n}\r\n","export { MeshBVH } from './core/MeshBVH.js';\nexport { MeshBVHHelper } from './objects/MeshBVHHelper.js';\nexport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './core/Constants.js';\nexport { getBVHExtremes, estimateMemoryInBytes, getJSONStructure, validateBounds } from './debug/Debug.js';\nexport { acceleratedRaycast, computeBoundsTree, disposeBoundsTree } from './utils/ExtensionUtilities.js';\nexport { getTriangleHitPointInfo } from './utils/TriangleUtilities.js';\nexport * from './math/ExtendedTriangle.js';\nexport * from './math/OrientedBox.js';\nexport * from './gpu/MeshBVHUniformStruct.js';\nexport * from './gpu/VertexAttributeTexture.js';\nexport * from './utils/StaticGeometryGenerator.js';\nexport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\n\n// backwards compatibility\nimport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\nexport const shaderStructs = BVHShaderGLSL.bvh_struct_definitions;\nexport const shaderDistanceFunction = BVHShaderGLSL.bvh_distance_functions;\nexport const shaderIntersectFunction = `\n\t${ BVHShaderGLSL.common_functions }\n\t${ BVHShaderGLSL.bvh_ray_functions }\n`;\n","import { BufferAttribute, Box3, FrontSide } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG, SKIP_GENERATION } from './Constants.js';\nimport { buildPackedTree } from './build/buildTree.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { ExtendedTrianglePool } from '../utils/ExtendedTrianglePool.js';\nimport { shapecast } from './cast/shapecast.js';\nimport { closestPointToPoint } from './cast/closestPointToPoint.js';\n\nimport { iterateOverTriangles } from './utils/iterationUtils.generated.js';\nimport { refit } from './cast/refit.generated.js';\nimport { raycast } from './cast/raycast.generated.js';\nimport { raycastFirst } from './cast/raycastFirst.generated.js';\nimport { intersectsGeometry } from './cast/intersectsGeometry.generated.js';\nimport { closestPointToGeometry } from './cast/closestPointToGeometry.generated.js';\n\nimport { iterateOverTriangles_indirect } from './utils/iterationUtils_indirect.generated.js';\nimport { refit_indirect } from './cast/refit_indirect.generated.js';\nimport { raycast_indirect } from './cast/raycast_indirect.generated.js';\nimport { raycastFirst_indirect } from './cast/raycastFirst_indirect.generated.js';\nimport { intersectsGeometry_indirect } from './cast/intersectsGeometry_indirect.generated.js';\nimport { closestPointToGeometry_indirect } from './cast/closestPointToGeometry_indirect.generated.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\nimport { setTriangle } from '../utils/TriangleUtilities.js';\nimport { bvhcast } from './cast/bvhcast.js';\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst tempBox = /* @__PURE__ */ new Box3();\nexport const DEFAULT_OPTIONS = {\n\tstrategy: CENTER,\n\tmaxDepth: 40,\n\tmaxLeafTris: 10,\n\tuseSharedArrayBuffer: false,\n\tsetBoundingBox: true,\n\tonProgress: null,\n\tindirect: false,\n\tverbose: true,\n};\n\nexport class MeshBVH {\n\n\tstatic serialize( bvh, options = {} ) {\n\n\t\toptions = {\n\t\t\tcloneBuffers: true,\n\t\t\t...options,\n\t\t};\n\n\t\tconst geometry = bvh.geometry;\n\t\tconst rootData = bvh._roots;\n\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\tconst indexAttribute = geometry.getIndex();\n\t\tlet result;\n\t\tif ( options.cloneBuffers ) {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData.map( root => root.slice() ),\n\t\t\t\tindex: indexAttribute ? indexAttribute.array.slice() : null,\n\t\t\t\tindirectBuffer: indirectBuffer ? indirectBuffer.slice() : null,\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tresult = {\n\t\t\t\troots: rootData,\n\t\t\t\tindex: indexAttribute ? indexAttribute.array : null,\n\t\t\t\tindirectBuffer: indirectBuffer,\n\t\t\t};\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tstatic deserialize( data, geometry, options = {} ) {\n\n\t\toptions = {\n\t\t\tsetIndex: true,\n\t\t\tindirect: Boolean( data.indirectBuffer ),\n\t\t\t...options,\n\t\t};\n\n\t\tconst { index, roots, indirectBuffer } = data;\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\n\t\tbvh._roots = roots;\n\t\tbvh._indirectBuffer = indirectBuffer || null;\n\n\t\tif ( options.setIndex ) {\n\n\t\t\tconst indexAttribute = geometry.getIndex();\n\t\t\tif ( indexAttribute === null ) {\n\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\n\t\t\t\tgeometry.setIndex( newIndex );\n\n\t\t\t} else if ( indexAttribute.array !== index ) {\n\n\t\t\t\tindexAttribute.array.set( index );\n\t\t\t\tindexAttribute.needsUpdate = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvh;\n\n\t}\n\n\tget indirect() {\n\n\t\treturn ! ! this._indirectBuffer;\n\n\t}\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tif ( ! geometry.isBufferGeometry ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\n\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\n\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\n\n\t\t}\n\n\t\t// default options\n\t\toptions = Object.assign( {\n\n\t\t\t...DEFAULT_OPTIONS,\n\n\t\t\t// undocumented options\n\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\n\t\t\t[ SKIP_GENERATION ]: false,\n\n\t\t}, options );\n\n\t\tif ( options.useSharedArrayBuffer && ! isSharedArrayBufferSupported() ) {\n\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\n\n\t\t}\n\n\t\t// retain references to the geometry so we can use them it without having to\n\t\t// take a geometry reference in every function.\n\t\tthis.geometry = geometry;\n\t\tthis._roots = null;\n\t\tthis._indirectBuffer = null;\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\n\n\t\t\tbuildPackedTree( this, options );\n\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\n\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst { _indirectBuffer } = this;\n\t\tthis.resolveTriangleIndex = options.indirect ? i => _indirectBuffer[ i ] : i => i;\n\n\t}\n\n\trefit( nodeIndices = null ) {\n\n\t\tconst refitFunc = this.indirect ? refit_indirect : refit;\n\t\treturn refitFunc( this, nodeIndices );\n\n\t}\n\n\ttraverse( callback, rootIndex = 0 ) {\n\n\t\tconst buffer = this._roots[ rootIndex ];\n\t\tconst uint32Array = new Uint32Array( buffer );\n\t\tconst uint16Array = new Uint16Array( buffer );\n\t\t_traverse( 0 );\n\n\t\tfunction _traverse( node32Index, depth = 0 ) {\n\n\t\t\tconst node16Index = node32Index * 2;\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\t\tif ( isLeaf ) {\n\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\n\n\t\t\t} else {\n\n\t\t\t\t// TODO: use node functions here\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\n\n\t\t\t\tif ( ! stopTraversal ) {\n\n\t\t\t\t\t_traverse( left, depth + 1 );\n\t\t\t\t\t_traverse( right, depth + 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/* Core Cast Functions */\n\traycast( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst intersects = [];\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFunc = this.indirect ? raycast_indirect : raycast;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst startCount = intersects.length;\n\n\t\t\traycastFunc( this, i, materialSide, ray, intersects );\n\n\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn intersects;\n\n\t}\n\n\traycastFirst( ray, materialOrSide = FrontSide ) {\n\n\t\tconst roots = this._roots;\n\t\tconst geometry = this.geometry;\n\t\tconst isMaterial = materialOrSide.isMaterial;\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\n\n\t\tlet closestResult = null;\n\n\t\tconst groups = geometry.groups;\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\n\t\tconst raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\n\t\t\tconst result = raycastFirstFunc( this, i, materialSide, ray );\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\n\n\t\t\t\tclosestResult = result;\n\t\t\t\tif ( isArrayMaterial ) {\n\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn closestResult;\n\n\t}\n\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\n\n\t\tlet result = false;\n\t\tconst roots = this._roots;\n\t\tconst intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tresult = intersectsGeometryFunc( this, i, otherGeometry, geomToMesh );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tshapecast( callbacks ) {\n\n\t\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\t\tconst iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;\n\t\tlet {\n\t\t\tboundsTraverseOrder,\n\t\t\tintersectsBounds,\n\t\t\tintersectsRange,\n\t\t\tintersectsTriangle,\n\t\t} = callbacks;\n\n\t\t// wrap the intersectsRange function\n\t\tif ( intersectsRange && intersectsTriangle ) {\n\n\t\t\tconst originalIntersectsRange = intersectsRange;\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\n\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t} else if ( ! intersectsRange ) {\n\n\t\t\tif ( intersectsTriangle ) {\n\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\n\n\t\t\t\t\treturn iterateFunc( offset, count, this, intersectsTriangle, contained, depth, triangle );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\n\n\t\t\t\t\treturn contained;\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t}\n\n\t\t// run shapecast\n\t\tlet result = false;\n\t\tlet byteOffset = 0;\n\t\tconst roots = this._roots;\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\t\tconst root = roots[ i ];\n\t\t\tresult = shapecast( this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tbyteOffset += root.byteLength;\n\n\t\t}\n\n\t\tExtendedTrianglePool.releasePrimitive( triangle );\n\n\t\treturn result;\n\n\t}\n\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\n\n\t\tlet {\n\t\t\tintersectsRanges,\n\t\t\tintersectsTriangles,\n\t\t} = callbacks;\n\n\t\tconst triangle1 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr1 = this.geometry.index;\n\t\tconst positionAttr1 = this.geometry.attributes.position;\n\t\tconst assignTriangle1 = this.indirect ?\n\t\t\ti1 => {\n\n\n\t\t\t\tconst ti = this.resolveTriangleIndex( i1 );\n\t\t\t\tsetTriangle( triangle1, ti * 3, indexAttr1, positionAttr1 );\n\n\t\t\t} :\n\t\t\ti1 => {\n\n\t\t\t\tsetTriangle( triangle1, i1 * 3, indexAttr1, positionAttr1 );\n\n\t\t\t};\n\n\t\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\t\tconst indexAttr2 = otherBvh.geometry.index;\n\t\tconst positionAttr2 = otherBvh.geometry.attributes.position;\n\t\tconst assignTriangle2 = otherBvh.indirect ?\n\t\t\ti2 => {\n\n\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\tsetTriangle( triangle2, ti2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t} :\n\t\t\ti2 => {\n\n\t\t\t\tsetTriangle( triangle2, i2 * 3, indexAttr2, positionAttr2 );\n\n\t\t\t};\n\n\t\t// generate triangle callback if needed\n\t\tif ( intersectsTriangles ) {\n\n\t\t\tconst iterateOverDoubleTriangles = ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) => {\n\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\tassignTriangle2( i2 );\n\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\n\n\t\t\t\t\t\tassignTriangle1( i1 );\n\n\t\t\t\t\t\ttriangle1.needsUpdate = true;\n\n\t\t\t\t\t\tif ( intersectsTriangles( triangle1, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t};\n\n\t\t\tif ( intersectsRanges ) {\n\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\n\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\n\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn bvhcast( this, otherBvh, matrixToLocal, intersectsRanges );\n\n\t}\n\n\n\t/* Derived Cast Functions */\n\tintersectsBox( box, boxToMesh ) {\n\n\t\tobb.set( box.min, box.max, boxToMesh );\n\t\tobb.needsUpdate = true;\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.shapecast(\n\t\t\t{\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\n\t\t\t}\n\t\t);\n\n\t}\n\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\tconst closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;\n\t\treturn closestPointToGeometryFunc(\n\t\t\tthis,\n\t\t\totherGeometry,\n\t\t\tgeometryToBvh,\n\t\t\ttarget1,\n\t\t\ttarget2,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\n\n\t\treturn closestPointToPoint(\n\t\t\tthis,\n\t\t\tpoint,\n\t\t\ttarget,\n\t\t\tminThreshold,\n\t\t\tmaxThreshold,\n\t\t);\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\ttarget.makeEmpty();\n\n\t\tconst roots = this._roots;\n\t\troots.forEach( buffer => {\n\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\n\t\t\ttarget.union( tempBox );\n\n\t\t} );\n\n\t\treturn target;\n\n\t}\n\n}\n","// Split strategy constants\nexport const CENTER = 0;\nexport const AVERAGE = 1;\nexport const SAH = 2;\n\n// Traversal constants\nexport const NOT_INTERSECTED = 0;\nexport const INTERSECTED = 1;\nexport const CONTAINED = 2;\n\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nexport const TRIANGLE_INTERSECT_COST = 1.25;\nexport const TRAVERSAL_COST = 1;\n\n\n// Build constants\nexport const BYTES_PER_NODE = 6 * 4 + 4 + 4;\nexport const IS_LEAFNODE_FLAG = 0xFFFF;\n\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nexport const FLOAT32_EPSILON = Math.pow( 2, - 24 );\n\nexport const SKIP_GENERATION = Symbol( 'SKIP_GENERATION' );\n","import { ensureIndex, getFullGeometryRange, getRootIndexRanges, getTriCount, hasGroupGaps, } from './geometryUtils.js';\nimport { getBounds, computeTriangleBounds } from './computeBoundsUtils.js';\nimport { getOptimalSplit } from './splitUtils.js';\nimport { MeshBVHNode } from '../MeshBVHNode.js';\nimport { BYTES_PER_NODE } from '../Constants.js';\n\nimport { partition } from './sortUtils.generated.js';\nimport { partition_indirect } from './sortUtils_indirect.generated.js';\nimport { countNodes, populateBuffer } from './buildUtils.js';\n\nexport function generateIndirectBuffer( geometry, useSharedArrayBuffer ) {\n\n\tconst triCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\tconst useUint32 = triCount > 2 ** 16;\n\tconst byteCount = useUint32 ? 4 : 2;\n\n\tconst buffer = useSharedArrayBuffer ? new SharedArrayBuffer( triCount * byteCount ) : new ArrayBuffer( triCount * byteCount );\n\tconst indirectBuffer = useUint32 ? new Uint32Array( buffer ) : new Uint16Array( buffer );\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tindirectBuffer[ i ] = i;\n\n\t}\n\n\treturn indirectBuffer;\n\n}\n\nexport function buildTree( bvh, triangleBounds, offset, count, options ) {\n\n\t// epxand variables\n\tconst {\n\t\tmaxDepth,\n\t\tverbose,\n\t\tmaxLeafTris,\n\t\tstrategy,\n\t\tonProgress,\n\t\tindirect,\n\t} = options;\n\tconst indirectBuffer = bvh._indirectBuffer;\n\tconst geometry = bvh.geometry;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tconst partionFunc = indirect ? partition_indirect : partition;\n\n\t// generate intermediate variables\n\tconst totalTriangles = getTriCount( geometry );\n\tconst cacheCentroidBoundingData = new Float32Array( 6 );\n\tlet reachedMaxDepth = false;\n\n\tconst root = new MeshBVHNode();\n\tgetBounds( triangleBounds, offset, count, root.boundingData, cacheCentroidBoundingData );\n\tsplitNode( root, offset, count, cacheCentroidBoundingData );\n\treturn root;\n\n\tfunction triggerProgress( trianglesProcessed ) {\n\n\t\tif ( onProgress ) {\n\n\t\t\tonProgress( trianglesProcessed / totalTriangles );\n\n\t\t}\n\n\t}\n\n\t// either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n\t// recording the offset and count of its triangles and writing them into the reordered geometry index.\n\tfunction splitNode( node, offset, count, centroidBoundingData = null, depth = 0 ) {\n\n\t\tif ( ! reachedMaxDepth && depth >= maxDepth ) {\n\n\t\t\treachedMaxDepth = true;\n\t\t\tif ( verbose ) {\n\n\t\t\t\tconsole.warn( `MeshBVH: Max depth of ${ maxDepth } reached when generating BVH. Consider increasing maxDepth.` );\n\t\t\t\tconsole.warn( geometry );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// early out if we've met our capacity\n\t\tif ( count <= maxLeafTris || depth >= maxDepth ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\t// Find where to split the volume\n\t\tconst split = getOptimalSplit( node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy );\n\t\tif ( split.axis === - 1 ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\t\t\treturn node;\n\n\t\t}\n\n\t\tconst splitOffset = partionFunc( indirectBuffer, indexArray, triangleBounds, offset, count, split );\n\n\t\t// create the two new child nodes\n\t\tif ( splitOffset === offset || splitOffset === offset + count ) {\n\n\t\t\ttriggerProgress( offset + count );\n\t\t\tnode.offset = offset;\n\t\t\tnode.count = count;\n\n\t\t} else {\n\n\t\t\tnode.splitAxis = split.axis;\n\n\t\t\t// create the left child and compute its bounding box\n\t\t\tconst left = new MeshBVHNode();\n\t\t\tconst lstart = offset;\n\t\t\tconst lcount = splitOffset - offset;\n\t\t\tnode.left = left;\n\n\t\t\tgetBounds( triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( left, lstart, lcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t\t// repeat for right\n\t\t\tconst right = new MeshBVHNode();\n\t\t\tconst rstart = splitOffset;\n\t\t\tconst rcount = count - lcount;\n\t\t\tnode.right = right;\n\n\t\t\tgetBounds( triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData );\n\t\t\tsplitNode( right, rstart, rcount, cacheCentroidBoundingData, depth + 1 );\n\n\t\t}\n\n\t\treturn node;\n\n\t}\n\n}\n\nexport function buildPackedTree( bvh, options ) {\n\n\tconst geometry = bvh.geometry;\n\tif ( options.indirect ) {\n\n\t\tbvh._indirectBuffer = generateIndirectBuffer( geometry, options.useSharedArrayBuffer );\n\n\t\tif ( hasGroupGaps( geometry ) && ! options.verbose ) {\n\n\t\t\tconsole.warn(\n\t\t\t\t'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' +\n\t\t\t\t'BVH may incorrectly report intersections on unrendered portions of the geometry.'\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tif ( ! bvh._indirectBuffer ) {\n\n\t\tensureIndex( geometry, options );\n\n\t}\n\n\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\n\tconst triangleBounds = computeTriangleBounds( geometry );\n\tconst geometryRanges = options.indirect ? getFullGeometryRange( geometry ) : getRootIndexRanges( geometry );\n\tbvh._roots = geometryRanges.map( range => {\n\n\t\tconst root = buildTree( bvh, triangleBounds, range.offset, range.count, options );\n\t\tconst nodeCount = countNodes( root );\n\t\tconst buffer = new BufferConstructor( BYTES_PER_NODE * nodeCount );\n\t\tpopulateBuffer( 0, root, buffer );\n\t\treturn buffer;\n\n\t} );\n\n}\n","import { BufferAttribute } from 'three';\n\nexport function getVertexCount( geo ) {\n\n\treturn geo.index ? geo.index.count : geo.attributes.position.count;\n\n}\n\nexport function getTriCount( geo ) {\n\n\treturn getVertexCount( geo ) / 3;\n\n}\n\nexport function getIndexArray( vertexCount, BufferConstructor = ArrayBuffer ) {\n\n\tif ( vertexCount > 65535 ) {\n\n\t\treturn new Uint32Array( new BufferConstructor( 4 * vertexCount ) );\n\n\t} else {\n\n\t\treturn new Uint16Array( new BufferConstructor( 2 * vertexCount ) );\n\n\t}\n\n}\n\n// ensures that an index is present on the geometry\nexport function ensureIndex( geo, options ) {\n\n\tif ( ! geo.index ) {\n\n\t\tconst vertexCount = geo.attributes.position.count;\n\t\tconst BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n\t\tconst index = getIndexArray( vertexCount, BufferConstructor );\n\t\tgeo.setIndex( new BufferAttribute( index, 1 ) );\n\n\t\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\t\tindex[ i ] = i;\n\n\t\t}\n\n\t}\n\n}\n\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nexport function getFullGeometryRange( geo ) {\n\n\tconst triCount = getTriCount( geo );\n\tconst drawRange = geo.drawRange;\n\tconst start = drawRange.start / 3;\n\tconst end = ( drawRange.start + drawRange.count ) / 3;\n\n\tconst offset = Math.max( 0, start );\n\tconst count = Math.min( triCount, end ) - offset;\n\treturn [ {\n\t\toffset: Math.floor( offset ),\n\t\tcount: Math.floor( count ),\n\t} ];\n\n}\n\nexport function getRootIndexRanges( geo ) {\n\n\tif ( ! geo.groups || ! geo.groups.length ) {\n\n\t\treturn getFullGeometryRange( geo );\n\n\t}\n\n\tconst ranges = [];\n\tconst rangeBoundaries = new Set();\n\n\tconst drawRange = geo.drawRange;\n\tconst drawRangeStart = drawRange.start / 3;\n\tconst drawRangeEnd = ( drawRange.start + drawRange.count ) / 3;\n\tfor ( const group of geo.groups ) {\n\n\t\tconst groupStart = group.start / 3;\n\t\tconst groupEnd = ( group.start + group.count ) / 3;\n\t\trangeBoundaries.add( Math.max( drawRangeStart, groupStart ) );\n\t\trangeBoundaries.add( Math.min( drawRangeEnd, groupEnd ) );\n\n\t}\n\n\n\t// note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n\tconst sortedBoundaries = Array.from( rangeBoundaries.values() ).sort( ( a, b ) => a - b );\n\tfor ( let i = 0; i < sortedBoundaries.length - 1; i ++ ) {\n\n\t\tconst start = sortedBoundaries[ i ];\n\t\tconst end = sortedBoundaries[ i + 1 ];\n\n\t\tranges.push( {\n\t\t\toffset: Math.floor( start ),\n\t\t\tcount: Math.floor( end - start ),\n\t\t} );\n\n\t}\n\n\treturn ranges;\n\n}\n\nexport function hasGroupGaps( geometry ) {\n\n\tif ( geometry.groups.length === 0 ) {\n\n\t\treturn false;\n\n\t}\n\n\tconst vertexCount = getTriCount( geometry );\n\tconst groups = getRootIndexRanges( geometry )\n\t\t.sort( ( a, b ) => a.offset - b.offset );\n\n\tconst finalGroup = groups[ groups.length - 1 ];\n\tfinalGroup.count = Math.min( vertexCount - finalGroup.offset, finalGroup.count );\n\n\tlet total = 0;\n\tgroups.forEach( ( { count } ) => total += count );\n\treturn vertexCount !== total;\n\n}\n","import { FLOAT32_EPSILON } from '../Constants.js';\nimport { getTriCount } from './geometryUtils.js';\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in \"target\".\n// A bounding box is computed for the centroids of the triangles, as well, and placed in \"centroidTarget\".\n// These are computed together to avoid redundant accesses to bounds array.\nexport function getBounds( triangleBounds, offset, count, target, centroidTarget ) {\n\n\tlet minx = Infinity;\n\tlet miny = Infinity;\n\tlet minz = Infinity;\n\tlet maxx = - Infinity;\n\tlet maxy = - Infinity;\n\tlet maxz = - Infinity;\n\n\tlet cminx = Infinity;\n\tlet cminy = Infinity;\n\tlet cminz = Infinity;\n\tlet cmaxx = - Infinity;\n\tlet cmaxy = - Infinity;\n\tlet cmaxz = - Infinity;\n\n\tfor ( let i = offset * 6, end = ( offset + count ) * 6; i < end; i += 6 ) {\n\n\t\tconst cx = triangleBounds[ i + 0 ];\n\t\tconst hx = triangleBounds[ i + 1 ];\n\t\tconst lx = cx - hx;\n\t\tconst rx = cx + hx;\n\t\tif ( lx < minx ) minx = lx;\n\t\tif ( rx > maxx ) maxx = rx;\n\t\tif ( cx < cminx ) cminx = cx;\n\t\tif ( cx > cmaxx ) cmaxx = cx;\n\n\t\tconst cy = triangleBounds[ i + 2 ];\n\t\tconst hy = triangleBounds[ i + 3 ];\n\t\tconst ly = cy - hy;\n\t\tconst ry = cy + hy;\n\t\tif ( ly < miny ) miny = ly;\n\t\tif ( ry > maxy ) maxy = ry;\n\t\tif ( cy < cminy ) cminy = cy;\n\t\tif ( cy > cmaxy ) cmaxy = cy;\n\n\t\tconst cz = triangleBounds[ i + 4 ];\n\t\tconst hz = triangleBounds[ i + 5 ];\n\t\tconst lz = cz - hz;\n\t\tconst rz = cz + hz;\n\t\tif ( lz < minz ) minz = lz;\n\t\tif ( rz > maxz ) maxz = rz;\n\t\tif ( cz < cminz ) cminz = cz;\n\t\tif ( cz > cmaxz ) cmaxz = cz;\n\n\t}\n\n\ttarget[ 0 ] = minx;\n\ttarget[ 1 ] = miny;\n\ttarget[ 2 ] = minz;\n\n\ttarget[ 3 ] = maxx;\n\ttarget[ 4 ] = maxy;\n\ttarget[ 5 ] = maxz;\n\n\tcentroidTarget[ 0 ] = cminx;\n\tcentroidTarget[ 1 ] = cminy;\n\tcentroidTarget[ 2 ] = cminz;\n\n\tcentroidTarget[ 3 ] = cmaxx;\n\tcentroidTarget[ 4 ] = cmaxy;\n\tcentroidTarget[ 5 ] = cmaxz;\n\n}\n\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nexport function computeTriangleBounds( geo, target = null, offset = null, count = null ) {\n\n\tconst posAttr = geo.attributes.position;\n\tconst index = geo.index ? geo.index.array : null;\n\tconst triCount = getTriCount( geo );\n\tconst normalized = posAttr.normalized;\n\tlet triangleBounds;\n\tif ( target === null ) {\n\n\t\ttriangleBounds = new Float32Array( triCount * 6 * 4 );\n\t\toffset = 0;\n\t\tcount = triCount;\n\n\t} else {\n\n\t\ttriangleBounds = target;\n\t\toffset = offset || 0;\n\t\tcount = count || triCount;\n\n\t}\n\n\t// used for non-normalized positions\n\tconst posArr = posAttr.array;\n\n\t// support for an interleaved position buffer\n\tconst bufferOffset = posAttr.offset || 0;\n\tlet stride = 3;\n\tif ( posAttr.isInterleavedBufferAttribute ) {\n\n\t\tstride = posAttr.data.stride;\n\n\t}\n\n\t// used for normalized positions\n\tconst getters = [ 'getX', 'getY', 'getZ' ];\n\n\tfor ( let tri = offset; tri < offset + count; tri ++ ) {\n\n\t\tconst tri3 = tri * 3;\n\t\tconst tri6 = tri * 6;\n\n\t\tlet ai = tri3 + 0;\n\t\tlet bi = tri3 + 1;\n\t\tlet ci = tri3 + 2;\n\n\t\tif ( index ) {\n\n\t\t\tai = index[ ai ];\n\t\t\tbi = index[ bi ];\n\t\t\tci = index[ ci ];\n\n\t\t}\n\n\t\t// we add the stride and offset here since we access the array directly\n\t\t// below for the sake of performance\n\t\tif ( ! normalized ) {\n\n\t\t\tai = ai * stride + bufferOffset;\n\t\t\tbi = bi * stride + bufferOffset;\n\t\t\tci = ci * stride + bufferOffset;\n\n\t\t}\n\n\t\tfor ( let el = 0; el < 3; el ++ ) {\n\n\t\t\tlet a, b, c;\n\n\t\t\tif ( normalized ) {\n\n\t\t\t\ta = posAttr[ getters[ el ] ]( ai );\n\t\t\t\tb = posAttr[ getters[ el ] ]( bi );\n\t\t\t\tc = posAttr[ getters[ el ] ]( ci );\n\n\t\t\t} else {\n\n\t\t\t\ta = posArr[ ai + el ];\n\t\t\t\tb = posArr[ bi + el ];\n\t\t\t\tc = posArr[ ci + el ];\n\n\t\t\t}\n\n\t\t\tlet min = a;\n\t\t\tif ( b < min ) min = b;\n\t\t\tif ( c < min ) min = c;\n\n\t\t\tlet max = a;\n\t\t\tif ( b > max ) max = b;\n\t\t\tif ( c > max ) max = c;\n\n\t\t\t// Increase the bounds size by float32 epsilon to avoid precision errors when\n\t\t\t// converting to 32 bit float. Scale the epsilon by the size of the numbers being\n\t\t\t// worked with.\n\t\t\tconst halfExtents = ( max - min ) / 2;\n\t\t\tconst el2 = el * 2;\n\t\t\ttriangleBounds[ tri6 + el2 + 0 ] = min + halfExtents;\n\t\t\ttriangleBounds[ tri6 + el2 + 1 ] = halfExtents + ( Math.abs( min ) + halfExtents ) * FLOAT32_EPSILON;\n\n\t\t}\n\n\t}\n\n\treturn triangleBounds;\n\n}\n","import { getLongestEdgeIndex, computeSurfaceArea, copyBounds, unionBounds, expandByTriangleBounds } from '../../utils/ArrayBoxUtilities.js';\nimport { CENTER, AVERAGE, SAH, TRIANGLE_INTERSECT_COST, TRAVERSAL_COST } from '../Constants.js';\n\nconst BIN_COUNT = 32;\nconst binsSort = ( a, b ) => a.candidate - b.candidate;\nconst sahBins = new Array( BIN_COUNT ).fill().map( () => {\n\n\treturn {\n\n\t\tcount: 0,\n\t\tbounds: new Float32Array( 6 ),\n\t\trightCacheBounds: new Float32Array( 6 ),\n\t\tleftCacheBounds: new Float32Array( 6 ),\n\t\tcandidate: 0,\n\n\t};\n\n} );\nconst leftBounds = new Float32Array( 6 );\n\nexport function getOptimalSplit( nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy ) {\n\n\tlet axis = - 1;\n\tlet pos = 0;\n\n\t// Center\n\tif ( strategy === CENTER ) {\n\n\t\taxis = getLongestEdgeIndex( centroidBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = ( centroidBoundingData[ axis ] + centroidBoundingData[ axis + 3 ] ) / 2;\n\n\t\t}\n\n\t} else if ( strategy === AVERAGE ) {\n\n\t\taxis = getLongestEdgeIndex( nodeBoundingData );\n\t\tif ( axis !== - 1 ) {\n\n\t\t\tpos = getAverage( triangleBounds, offset, count, axis );\n\n\t\t}\n\n\t} else if ( strategy === SAH ) {\n\n\t\tconst rootSurfaceArea = computeSurfaceArea( nodeBoundingData );\n\t\tlet bestCost = TRIANGLE_INTERSECT_COST * count;\n\n\t\t// iterate over all axes\n\t\tconst cStart = offset * 6;\n\t\tconst cEnd = ( offset + count ) * 6;\n\t\tfor ( let a = 0; a < 3; a ++ ) {\n\n\t\t\tconst axisLeft = centroidBoundingData[ a ];\n\t\t\tconst axisRight = centroidBoundingData[ a + 3 ];\n\t\t\tconst axisLength = axisRight - axisLeft;\n\t\t\tconst binWidth = axisLength / BIN_COUNT;\n\n\t\t\t// If we have fewer triangles than we're planning to split then just check all\n\t\t\t// the triangle positions because it will be faster.\n\t\t\tif ( count < BIN_COUNT / 4 ) {\n\n\t\t\t\t// initialize the bin candidates\n\t\t\t\tconst truncatedBins = [ ...sahBins ];\n\t\t\t\ttruncatedBins.length = count;\n\n\t\t\t\t// set the candidates\n\t\t\t\tlet b = 0;\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6, b ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ b ];\n\t\t\t\t\tbin.candidate = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tbin.count = 0;\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tbounds,\n\t\t\t\t\t\tleftCacheBounds,\n\t\t\t\t\t\trightCacheBounds,\n\t\t\t\t\t} = bin;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\trightCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\trightCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tleftCacheBounds[ d ] = Infinity;\n\t\t\t\t\t\tleftCacheBounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bounds );\n\n\t\t\t\t}\n\n\t\t\t\ttruncatedBins.sort( binsSort );\n\n\t\t\t\t// remove redundant splits\n\t\t\t\tlet splitCount = count;\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\twhile ( bi + 1 < splitCount && truncatedBins[ bi + 1 ].candidate === bin.candidate ) {\n\n\t\t\t\t\t\ttruncatedBins.splice( bi + 1, 1 );\n\t\t\t\t\t\tsplitCount --;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// find the appropriate bin for each triangle and expand the bounds.\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst center = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\t\tif ( center >= bin.candidate ) {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.rightCacheBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.leftCacheBounds );\n\t\t\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// expand all the bounds\n\t\t\t\tfor ( let bi = 0; bi < splitCount; bi ++ ) {\n\n\t\t\t\t\tconst bin = truncatedBins[ bi ];\n\t\t\t\t\tconst leftCount = bin.count;\n\t\t\t\t\tconst rightCount = count - bin.count;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tconst leftBounds = bin.leftCacheBounds;\n\t\t\t\t\tconst rightBounds = bin.rightCacheBounds;\n\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tlet rightProb = 0;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// reset the bins\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tbin.count = 0;\n\t\t\t\t\tbin.candidate = axisLeft + binWidth + i * binWidth;\n\n\t\t\t\t\tconst bounds = bin.bounds;\n\t\t\t\t\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\t\t\t\t\tbounds[ d ] = Infinity;\n\t\t\t\t\t\tbounds[ d + 3 ] = - Infinity;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// iterate over all center positions\n\t\t\t\tfor ( let c = cStart; c < cEnd; c += 6 ) {\n\n\t\t\t\t\tconst triCenter = triangleBounds[ c + 2 * a ];\n\t\t\t\t\tconst relativeCenter = triCenter - axisLeft;\n\n\t\t\t\t\t// in the partition function if the centroid lies on the split plane then it is\n\t\t\t\t\t// considered to be on the right side of the split\n\t\t\t\t\tlet binIndex = ~ ~ ( relativeCenter / binWidth );\n\t\t\t\t\tif ( binIndex >= BIN_COUNT ) binIndex = BIN_COUNT - 1;\n\n\t\t\t\t\tconst bin = sahBins[ binIndex ];\n\t\t\t\t\tbin.count ++;\n\n\t\t\t\t\texpandByTriangleBounds( c, triangleBounds, bin.bounds );\n\n\t\t\t\t}\n\n\t\t\t\t// cache the unioned bounds from right to left so we don't have to regenerate them each time\n\t\t\t\tconst lastBin = sahBins[ BIN_COUNT - 1 ];\n\t\t\t\tcopyBounds( lastBin.bounds, lastBin.rightCacheBounds );\n\t\t\t\tfor ( let i = BIN_COUNT - 2; i >= 0; i -- ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tunionBounds( bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds );\n\n\t\t\t\t}\n\n\t\t\t\tlet leftCount = 0;\n\t\t\t\tfor ( let i = 0; i < BIN_COUNT - 1; i ++ ) {\n\n\t\t\t\t\tconst bin = sahBins[ i ];\n\t\t\t\t\tconst binCount = bin.count;\n\t\t\t\t\tconst bounds = bin.bounds;\n\n\t\t\t\t\tconst nextBin = sahBins[ i + 1 ];\n\t\t\t\t\tconst rightBounds = nextBin.rightCacheBounds;\n\n\t\t\t\t\t// don't do anything with the bounds if the new bounds have no triangles\n\t\t\t\t\tif ( binCount !== 0 ) {\n\n\t\t\t\t\t\tif ( leftCount === 0 ) {\n\n\t\t\t\t\t\t\tcopyBounds( bounds, leftBounds );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tunionBounds( bounds, leftBounds, leftBounds );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tleftCount += binCount;\n\n\t\t\t\t\t// check the cost of this split\n\t\t\t\t\tlet leftProb = 0;\n\t\t\t\t\tlet rightProb = 0;\n\n\t\t\t\t\tif ( leftCount !== 0 ) {\n\n\t\t\t\t\t\tleftProb = computeSurfaceArea( leftBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rightCount = count - leftCount;\n\t\t\t\t\tif ( rightCount !== 0 ) {\n\n\t\t\t\t\t\trightProb = computeSurfaceArea( rightBounds ) / rootSurfaceArea;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (\n\t\t\t\t\t\tleftProb * leftCount + rightProb * rightCount\n\t\t\t\t\t);\n\n\t\t\t\t\tif ( cost < bestCost ) {\n\n\t\t\t\t\t\taxis = a;\n\t\t\t\t\t\tbestCost = cost;\n\t\t\t\t\t\tpos = bin.candidate;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\tconsole.warn( `MeshBVH: Invalid build strategy value ${ strategy } used.` );\n\n\t}\n\n\treturn { axis, pos };\n\n}\n\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage( triangleBounds, offset, count, axis ) {\n\n\tlet avg = 0;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tavg += triangleBounds[ i * 6 + axis * 2 ];\n\n\t}\n\n\treturn avg / count;\n\n}\n","export function arrayToBox( nodeIndex32, array, target ) {\n\n\ttarget.min.x = array[ nodeIndex32 ];\n\ttarget.min.y = array[ nodeIndex32 + 1 ];\n\ttarget.min.z = array[ nodeIndex32 + 2 ];\n\n\ttarget.max.x = array[ nodeIndex32 + 3 ];\n\ttarget.max.y = array[ nodeIndex32 + 4 ];\n\ttarget.max.z = array[ nodeIndex32 + 5 ];\n\n\treturn target;\n\n}\n\nexport function makeEmptyBounds( target ) {\n\n\ttarget[ 0 ] = target[ 1 ] = target[ 2 ] = Infinity;\n\ttarget[ 3 ] = target[ 4 ] = target[ 5 ] = - Infinity;\n\n}\n\nexport function getLongestEdgeIndex( bounds ) {\n\n\tlet splitDimIdx = - 1;\n\tlet splitDist = - Infinity;\n\n\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\tconst dist = bounds[ i + 3 ] - bounds[ i ];\n\t\tif ( dist > splitDist ) {\n\n\t\t\tsplitDist = dist;\n\t\t\tsplitDimIdx = i;\n\n\t\t}\n\n\t}\n\n\treturn splitDimIdx;\n\n}\n\n// copies bounds a into bounds b\nexport function copyBounds( source, target ) {\n\n\ttarget.set( source );\n\n}\n\n// sets bounds target to the union of bounds a and b\nexport function unionBounds( a, b, target ) {\n\n\tlet aVal, bVal;\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst d3 = d + 3;\n\n\t\t// set the minimum values\n\t\taVal = a[ d ];\n\t\tbVal = b[ d ];\n\t\ttarget[ d ] = aVal < bVal ? aVal : bVal;\n\n\t\t// set the max values\n\t\taVal = a[ d3 ];\n\t\tbVal = b[ d3 ];\n\t\ttarget[ d3 ] = aVal > bVal ? aVal : bVal;\n\n\t}\n\n}\n\n// expands the given bounds by the provided triangle bounds\nexport function expandByTriangleBounds( startIndex, triangleBounds, bounds ) {\n\n\tfor ( let d = 0; d < 3; d ++ ) {\n\n\t\tconst tCenter = triangleBounds[ startIndex + 2 * d ];\n\t\tconst tHalf = triangleBounds[ startIndex + 2 * d + 1 ];\n\n\t\tconst tMin = tCenter - tHalf;\n\t\tconst tMax = tCenter + tHalf;\n\n\t\tif ( tMin < bounds[ d ] ) {\n\n\t\t\tbounds[ d ] = tMin;\n\n\t\t}\n\n\t\tif ( tMax > bounds[ d + 3 ] ) {\n\n\t\t\tbounds[ d + 3 ] = tMax;\n\n\t\t}\n\n\t}\n\n}\n\n// compute bounds surface area\nexport function computeSurfaceArea( bounds ) {\n\n\tconst d0 = bounds[ 3 ] - bounds[ 0 ];\n\tconst d1 = bounds[ 4 ] - bounds[ 1 ];\n\tconst d2 = bounds[ 5 ] - bounds[ 2 ];\n\n\treturn 2 * ( d0 * d1 + d1 * d2 + d2 * d0 );\n\n}\n","export class MeshBVHNode {\n\n\tconstructor() {\n\n\t\t// internal nodes have boundingData, left, right, and splitAxis\n\t\t// leaf nodes have offset and count (referring to primitives in the mesh geometry)\n\n\t\tthis.boundingData = new Float32Array( 6 );\n\n\t}\n\n}\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tlet t0 = index[ left * 3 + i ];\n\t\t\t\tindex[ left * 3 + i ] = index[ right * 3 + i ];\n\t\t\t\tindex[ right * 3 + i ] = t0;\n\n\t\t\t}\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition };\n","/********************************************************/\n/* This file is generated from \"sortUtils.template.js\". */\n/********************************************************/\n// reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect( indirectBuffer, index, triangleBounds, offset, count, split ) {\n\n\tlet left = offset;\n\tlet right = offset + count - 1;\n\tconst pos = split.pos;\n\tconst axisOffset = split.axis * 2;\n\n\t// hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n\twhile ( true ) {\n\n\t\twhile ( left <= right && triangleBounds[ left * 6 + axisOffset ] < pos ) {\n\n\t\t\tleft ++;\n\n\t\t}\n\n\t\t// if a triangle center lies on the partition plane it is considered to be on the right side\n\t\twhile ( left <= right && triangleBounds[ right * 6 + axisOffset ] >= pos ) {\n\n\t\t\tright --;\n\n\t\t}\n\n\t\tif ( left < right ) {\n\n\t\t\t// we need to swap all of the information associated with the triangles at index\n\t\t\t// left and right; that's the verts in the geometry index, the bounds,\n\t\t\t// and perhaps the SAH planes\n\t\t\tlet t = indirectBuffer[ left ];\n\t\t\tindirectBuffer[ left ] = indirectBuffer[ right ];\n\t\t\tindirectBuffer[ right ] = t;\n\n\n\t\t\t// swap bounds\n\t\t\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\t\t\tlet tb = triangleBounds[ left * 6 + i ];\n\t\t\t\ttriangleBounds[ left * 6 + i ] = triangleBounds[ right * 6 + i ];\n\t\t\t\ttriangleBounds[ right * 6 + i ] = tb;\n\n\t\t\t}\n\n\t\t\tleft ++;\n\t\t\tright --;\n\n\t\t} else {\n\n\t\t\treturn left;\n\n\t\t}\n\n\t}\n\n}\n\nexport { partition_indirect };\n","import { BYTES_PER_NODE, IS_LEAFNODE_FLAG } from '../Constants.js';\nimport { IS_LEAF } from '../utils/nodeBufferUtils.js';\n\nlet float32Array, uint32Array, uint16Array, uint8Array;\nconst MAX_POINTER = Math.pow( 2, 32 );\n\nexport function countNodes( node ) {\n\n\tif ( 'count' in node ) {\n\n\t\treturn 1;\n\n\t} else {\n\n\t\treturn 1 + countNodes( node.left ) + countNodes( node.right );\n\n\t}\n\n}\n\nexport function populateBuffer( byteOffset, node, buffer ) {\n\n\tfloat32Array = new Float32Array( buffer );\n\tuint32Array = new Uint32Array( buffer );\n\tuint16Array = new Uint16Array( buffer );\n\tuint8Array = new Uint8Array( buffer );\n\n\treturn _populateBuffer( byteOffset, node );\n\n}\n\n// pack structure\n// boundingData  \t\t\t\t: 6 float32\n// right / offset \t\t\t\t: 1 uint32\n// splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\nfunction _populateBuffer( byteOffset, node ) {\n\n\tconst stride4Offset = byteOffset / 4;\n\tconst stride2Offset = byteOffset / 2;\n\tconst isLeaf = 'count' in node;\n\tconst boundingData = node.boundingData;\n\tfor ( let i = 0; i < 6; i ++ ) {\n\n\t\tfloat32Array[ stride4Offset + i ] = boundingData[ i ];\n\n\t}\n\n\tif ( isLeaf ) {\n\n\t\tif ( node.buffer ) {\n\n\t\t\tconst buffer = node.buffer;\n\t\t\tuint8Array.set( new Uint8Array( buffer ), byteOffset );\n\n\t\t\tfor ( let offset = byteOffset, l = byteOffset + buffer.byteLength; offset < l; offset += BYTES_PER_NODE ) {\n\n\t\t\t\tconst offset2 = offset / 2;\n\t\t\t\tif ( ! IS_LEAF( offset2, uint16Array ) ) {\n\n\t\t\t\t\tuint32Array[ ( offset / 4 ) + 6 ] += stride4Offset;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn byteOffset + buffer.byteLength;\n\n\t\t} else {\n\n\t\t\tconst offset = node.offset;\n\t\t\tconst count = node.count;\n\t\t\tuint32Array[ stride4Offset + 6 ] = offset;\n\t\t\tuint16Array[ stride2Offset + 14 ] = count;\n\t\t\tuint16Array[ stride2Offset + 15 ] = IS_LEAFNODE_FLAG;\n\t\t\treturn byteOffset + BYTES_PER_NODE;\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = node.left;\n\t\tconst right = node.right;\n\t\tconst splitAxis = node.splitAxis;\n\n\t\tlet nextUnusedPointer;\n\t\tnextUnusedPointer = _populateBuffer( byteOffset + BYTES_PER_NODE, left );\n\n\t\tif ( ( nextUnusedPointer / 4 ) > MAX_POINTER ) {\n\n\t\t\tthrow new Error( 'MeshBVH: Cannot store child pointer greater than 32 bits.' );\n\n\t\t}\n\n\t\tuint32Array[ stride4Offset + 6 ] = nextUnusedPointer / 4;\n\t\tnextUnusedPointer = _populateBuffer( nextUnusedPointer, right );\n\n\t\tuint32Array[ stride4Offset + 7 ] = splitAxis;\n\t\treturn nextUnusedPointer;\n\n\t}\n\n}\n","export function IS_LEAF( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 15 ] === 0xFFFF;\n\n}\n\nexport function OFFSET( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function COUNT( n16, uint16Array ) {\n\n\treturn uint16Array[ n16 + 14 ];\n\n}\n\nexport function LEFT_NODE( n32 ) {\n\n\treturn n32 + 8;\n\n}\n\nexport function RIGHT_NODE( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 6 ];\n\n}\n\nexport function SPLIT_AXIS( n32, uint32Array ) {\n\n\treturn uint32Array[ n32 + 7 ];\n\n}\n\nexport function BOUNDING_DATA_INDEX( n32 ) {\n\n\treturn n32;\n\n}\n","import { Vector3, Matrix4, Line3 } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { ExtendedTriangle } from './ExtendedTriangle.js';\nimport { closestPointsSegmentToSegment } from './MathUtilities.js';\n\nexport class OrientedBox {\n\n\tconstructor( min, max, matrix ) {\n\n\t\tthis.isOrientedBox = true;\n\t\tthis.min = new Vector3();\n\t\tthis.max = new Vector3();\n\t\tthis.matrix = new Matrix4();\n\t\tthis.invMatrix = new Matrix4();\n\t\tthis.points = new Array( 8 ).fill().map( () => new Vector3() );\n\t\tthis.satAxes = new Array( 3 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.alignedSatBounds = new Array( 3 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.needsUpdate = false;\n\n\t\tif ( min ) this.min.copy( min );\n\t\tif ( max ) this.max.copy( max );\n\t\tif ( matrix ) this.matrix.copy( matrix );\n\n\t}\n\n\tset( min, max, matrix ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\t\tthis.matrix.copy( matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tcopy( other ) {\n\n\t\tthis.min.copy( other.min );\n\t\tthis.max.copy( other.max );\n\t\tthis.matrix.copy( other.matrix );\n\t\tthis.needsUpdate = true;\n\n\t}\n\n}\n\nOrientedBox.prototype.update = ( function () {\n\n\treturn function update() {\n\n\t\tconst matrix = this.matrix;\n\t\tconst min = this.min;\n\t\tconst max = this.max;\n\n\t\tconst points = this.points;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tconst i = ( ( 1 << 0 ) * x ) | ( ( 1 << 1 ) * y ) | ( ( 1 << 2 ) * z );\n\t\t\t\t\tconst v = points[ i ];\n\t\t\t\t\tv.x = x ? max.x : min.x;\n\t\t\t\t\tv.y = y ? max.y : min.y;\n\t\t\t\t\tv.z = z ? max.z : min.z;\n\n\t\t\t\t\tv.applyMatrix4( matrix );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst minVec = points[ 0 ];\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst index = 1 << i;\n\t\t\tconst pi = points[ index ];\n\n\t\t\taxis.subVectors( minVec, pi );\n\t\t\tsb.setFromPoints( axis, points );\n\n\t\t}\n\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\t\talignedSatBounds[ 0 ].setFromPointsField( points, 'x' );\n\t\talignedSatBounds[ 1 ].setFromPointsField( points, 'y' );\n\t\talignedSatBounds[ 2 ].setFromPointsField( points, 'z' );\n\n\t\tthis.invMatrix.copy( this.matrix ).invert();\n\t\tthis.needsUpdate = false;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsBox = ( function () {\n\n\tconst aabbBounds = new SeparatingAxisBounds();\n\treturn function intersectsBox( box ) {\n\n\t\t// TODO: should this be doing SAT against the AABB?\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\t\tconst alignedSatBounds = this.alignedSatBounds;\n\n\t\taabbBounds.min = min.x;\n\t\taabbBounds.max = max.x;\n\t\tif ( alignedSatBounds[ 0 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.y;\n\t\taabbBounds.max = max.y;\n\t\tif ( alignedSatBounds[ 1 ].isSeparated( aabbBounds ) ) return false;\n\n\t\taabbBounds.min = min.z;\n\t\taabbBounds.max = max.z;\n\t\tif ( alignedSatBounds[ 2 ].isSeparated( aabbBounds ) ) return false;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst axis = satAxes[ i ];\n\t\t\tconst sb = satBounds[ i ];\n\t\t\taabbBounds.setFromBox( axis, box );\n\t\t\tif ( sb.isSeparated( aabbBounds ) ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri = new ExtendedTriangle();\n\tconst pointsArr = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\treturn function intersectsTriangle( triangle ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! triangle.isExtendedTriangle ) {\n\n\t\t\tsaTri.copy( triangle );\n\t\t\tsaTri.update();\n\t\t\ttriangle = saTri;\n\n\t\t} else if ( triangle.needsUpdate ) {\n\n\t\t\ttriangle.update();\n\n\t\t}\n\n\t\tconst satBounds = this.satBounds;\n\t\tconst satAxes = this.satAxes;\n\n\t\tpointsArr[ 0 ] = triangle.a;\n\t\tpointsArr[ 1 ] = triangle.b;\n\t\tpointsArr[ 2 ] = triangle.c;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds[ i ];\n\t\t\tconst sa = satAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, pointsArr );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\tconst triSatBounds = triangle.satBounds;\n\t\tconst triSatAxes = triangle.satAxes;\n\t\tconst points = this.points;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = triSatBounds[ i ];\n\t\t\tconst sa = triSatAxes[ i ];\n\t\t\tcachedSatBounds.setFromPoints( sa, points );\n\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check crossed axes\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sa1 = satAxes[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\tconst sa2 = triSatAxes[ i2 ];\n\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, pointsArr );\n\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, points );\n\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.closestPointToPoint = ( function () {\n\n\treturn function closestPointToPoint( point, target1 ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\ttarget1\n\t\t\t.copy( point )\n\t\t\t.applyMatrix4( this.invMatrix )\n\t\t\t.clamp( this.min, this.max )\n\t\t\t.applyMatrix4( this.matrix );\n\n\t\treturn target1;\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\nOrientedBox.prototype.distanceToBox = ( function () {\n\n\tconst xyzFields = [ 'x', 'y', 'z' ];\n\tconst segments1 = new Array( 12 ).fill().map( () => new Line3() );\n\tconst segments2 = new Array( 12 ).fill().map( () => new Line3() );\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\n\t// early out if we find a value below threshold\n\treturn function distanceToBox( box, threshold = 0, target1 = null, target2 = null ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( this.intersectsBox( box ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tbox.getCenter( point2 );\n\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\tbox.closestPointToPoint( point1, point2 );\n\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tconst threshold2 = threshold * threshold;\n\t\tconst min = box.min;\n\t\tconst max = box.max;\n\t\tconst points = this.points;\n\n\n\t\t// iterate over every edge and compare distances\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check over all these points\n\t\tfor ( let i = 0; i < 8; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tpoint2.copy( p ).clamp( min, max );\n\n\t\t\tconst dist = p.distanceToSquared( point2 );\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( p );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate and check all line segment distances\n\t\tlet count = 0;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tfor ( let i1 = 0; i1 <= 1; i1 ++ ) {\n\n\t\t\t\tfor ( let i2 = 0; i2 <= 1; i2 ++ ) {\n\n\t\t\t\t\tconst nextIndex = ( i + 1 ) % 3;\n\t\t\t\t\tconst nextIndex2 = ( i + 2 ) % 3;\n\n\t\t\t\t\t// get obb line segments\n\t\t\t\t\tconst index = i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n\t\t\t\t\tconst p1 = points[ index ];\n\t\t\t\t\tconst p2 = points[ index2 ];\n\t\t\t\t\tconst line1 = segments1[ count ];\n\t\t\t\t\tline1.set( p1, p2 );\n\n\n\t\t\t\t\t// get aabb line segments\n\t\t\t\t\tconst f1 = xyzFields[ i ];\n\t\t\t\t\tconst f2 = xyzFields[ nextIndex ];\n\t\t\t\t\tconst f3 = xyzFields[ nextIndex2 ];\n\t\t\t\t\tconst line2 = segments2[ count ];\n\t\t\t\t\tconst start = line2.start;\n\t\t\t\t\tconst end = line2.end;\n\n\t\t\t\t\tstart[ f1 ] = min[ f1 ];\n\t\t\t\t\tstart[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tstart[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tend[ f1 ] = max[ f1 ];\n\t\t\t\t\tend[ f2 ] = i1 ? min[ f2 ] : max[ f2 ];\n\t\t\t\t\tend[ f3 ] = i2 ? min[ f3 ] : max[ f2 ];\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check all the other boxes point\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tpoint2.x = x ? max.x : min.x;\n\t\t\t\t\tpoint2.y = y ? max.y : min.y;\n\t\t\t\t\tpoint2.z = z ? max.z : min.z;\n\n\t\t\t\t\tthis.closestPointToPoint( point2, point1 );\n\t\t\t\t\tconst dist = point2.distanceToSquared( point1 );\n\t\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 12; i ++ ) {\n\n\t\t\tconst l1 = segments1[ i ];\n\t\t\tfor ( let i2 = 0; i2 < 12; i2 ++ ) {\n\n\t\t\t\tconst l2 = segments2[ i2 ];\n\t\t\t\tclosestPointsSegmentToSegment( l1, l2, point1, point2 );\n\t\t\t\tconst dist = point1.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t\tif ( dist < threshold2 ) return Math.sqrt( dist );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3 } from 'three';\n\nexport class SeparatingAxisBounds {\n\n\tconstructor() {\n\n\t\tthis.min = Infinity;\n\t\tthis.max = - Infinity;\n\n\t}\n\n\tsetFromPointsField( points, field ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = p[ field ];\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tsetFromPoints( axis, points ) {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst p = points[ i ];\n\t\t\tconst val = axis.dot( p );\n\t\t\tmin = val < min ? val : min;\n\t\t\tmax = val > max ? val : max;\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tisSeparated( other ) {\n\n\t\treturn this.min > other.max || other.min > this.max;\n\n\t}\n\n}\n\nSeparatingAxisBounds.prototype.setFromBox = ( function () {\n\n\tconst p = new Vector3();\n\treturn function setFromBox( axis, box ) {\n\n\t\tconst boxMin = box.min;\n\t\tconst boxMax = box.max;\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\t\tfor ( let x = 0; x <= 1; x ++ ) {\n\n\t\t\tfor ( let y = 0; y <= 1; y ++ ) {\n\n\t\t\t\tfor ( let z = 0; z <= 1; z ++ ) {\n\n\t\t\t\t\tp.x = boxMin.x * x + boxMax.x * ( 1 - x );\n\t\t\t\t\tp.y = boxMin.y * y + boxMax.y * ( 1 - y );\n\t\t\t\t\tp.z = boxMin.z * z + boxMax.z * ( 1 - z );\n\n\t\t\t\t\tconst val = axis.dot( p );\n\t\t\t\t\tmin = Math.min( val, min );\n\t\t\t\t\tmax = Math.max( val, max );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t};\n\n} )();\n\nexport const areIntersecting = ( function () {\n\n\tconst cacheSatBounds = new SeparatingAxisBounds();\n\treturn function areIntersecting( shape1, shape2 ) {\n\n\t\tconst points1 = shape1.points;\n\t\tconst satAxes1 = shape1.satAxes;\n\t\tconst satBounds1 = shape1.satBounds;\n\n\t\tconst points2 = shape2.points;\n\t\tconst satAxes2 = shape2.satAxes;\n\t\tconst satBounds2 = shape2.satBounds;\n\n\t\t// check axes of the first shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds1[ i ];\n\t\t\tconst sa = satAxes1[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points2 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t\t// check axes of the second shape\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst sb = satBounds2[ i ];\n\t\t\tconst sa = satAxes2[ i ];\n\t\t\tcacheSatBounds.setFromPoints( sa, points1 );\n\t\t\tif ( sb.isSeparated( cacheSatBounds ) ) return false;\n\n\t\t}\n\n\t};\n\n} )();\n","import { Triangle, Vector3, Line3, Sphere, Plane } from 'three';\nimport { SeparatingAxisBounds } from './SeparatingAxisBounds.js';\nimport { closestPointsSegmentToSegment, sphereIntersectTriangle } from './MathUtilities.js';\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero( value ) {\n\n\treturn Math.abs( value ) < ZERO_EPSILON;\n\n}\n\nexport class ExtendedTriangle extends Triangle {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tthis.isExtendedTriangle = true;\n\t\tthis.satAxes = new Array( 4 ).fill().map( () => new Vector3() );\n\t\tthis.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );\n\t\tthis.points = [ this.a, this.b, this.c ];\n\t\tthis.sphere = new Sphere();\n\t\tthis.plane = new Plane();\n\t\tthis.needsUpdate = true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn sphereIntersectTriangle( sphere, this );\n\n\t}\n\n\tupdate() {\n\n\t\tconst a = this.a;\n\t\tconst b = this.b;\n\t\tconst c = this.c;\n\t\tconst points = this.points;\n\n\t\tconst satAxes = this.satAxes;\n\t\tconst satBounds = this.satBounds;\n\n\t\tconst axis0 = satAxes[ 0 ];\n\t\tconst sab0 = satBounds[ 0 ];\n\t\tthis.getNormal( axis0 );\n\t\tsab0.setFromPoints( axis0, points );\n\n\t\tconst axis1 = satAxes[ 1 ];\n\t\tconst sab1 = satBounds[ 1 ];\n\t\taxis1.subVectors( a, b );\n\t\tsab1.setFromPoints( axis1, points );\n\n\t\tconst axis2 = satAxes[ 2 ];\n\t\tconst sab2 = satBounds[ 2 ];\n\t\taxis2.subVectors( b, c );\n\t\tsab2.setFromPoints( axis2, points );\n\n\t\tconst axis3 = satAxes[ 3 ];\n\t\tconst sab3 = satBounds[ 3 ];\n\t\taxis3.subVectors( c, a );\n\t\tsab3.setFromPoints( axis3, points );\n\n\t\tthis.sphere.setFromPoints( this.points );\n\t\tthis.plane.setFromNormalAndCoplanarPoint( axis0, a );\n\t\tthis.needsUpdate = false;\n\n\t}\n\n}\n\nExtendedTriangle.prototype.closestPointToSegment = ( function () {\n\n\tconst point1 = new Vector3();\n\tconst point2 = new Vector3();\n\tconst edge = new Line3();\n\n\treturn function distanceToSegment( segment, target1 = null, target2 = null ) {\n\n\t\tconst { start, end } = segment;\n\t\tconst points = this.points;\n\t\tlet distSq;\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check the triangle edges\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst nexti = ( i + 1 ) % 3;\n\t\t\tedge.start.copy( points[ i ] );\n\t\t\tedge.end.copy( points[ nexti ] );\n\n\t\t\tclosestPointsSegmentToSegment( edge, segment, point1, point2 );\n\n\t\t\tdistSq = point1.distanceToSquared( point2 );\n\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check end points\n\t\tthis.closestPointToPoint( start, point1 );\n\t\tdistSq = start.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( start );\n\n\t\t}\n\n\t\tthis.closestPointToPoint( end, point1 );\n\t\tdistSq = end.distanceToSquared( point1 );\n\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\tclosestDistanceSq = distSq;\n\t\t\tif ( target1 ) target1.copy( point1 );\n\t\t\tif ( target2 ) target2.copy( end );\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n\nExtendedTriangle.prototype.intersectsTriangle = ( function () {\n\n\tconst saTri2 = new ExtendedTriangle();\n\tconst arr1 = new Array( 3 );\n\tconst arr2 = new Array( 3 );\n\tconst cachedSatBounds = new SeparatingAxisBounds();\n\tconst cachedSatBounds2 = new SeparatingAxisBounds();\n\tconst cachedAxis = new Vector3();\n\tconst dir = new Vector3();\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst tempDir = new Vector3();\n\tconst edge = new Line3();\n\tconst edge1 = new Line3();\n\tconst edge2 = new Line3();\n\tconst tempPoint = new Vector3();\n\n\tfunction triIntersectPlane( tri, plane, targetEdge ) {\n\n\t\t// find the edge that intersects the other triangle plane\n\t\tconst points = tri.points;\n\t\tlet count = 0;\n\t\tlet startPointIntersection = - 1;\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst { start, end } = edge;\n\t\t\tstart.copy( points[ i ] );\n\t\t\tend.copy( points[ ( i + 1 ) % 3 ] );\n\t\t\tedge.delta( dir );\n\n\t\t\tconst startIntersects = isNearZero( plane.distanceToPoint( start ) );\n\t\t\tif ( isNearZero( plane.normal.dot( dir ) ) && startIntersects ) {\n\n\t\t\t\t// if the edge lies on the plane then take the line\n\t\t\t\ttargetEdge.copy( edge );\n\t\t\t\tcount = 2;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\t// check if the start point is near the plane because \"intersectLine\" is not robust to that case\n\t\t\tconst doesIntersect = plane.intersectLine( edge, tempPoint );\n\t\t\tif ( ! doesIntersect && startIntersects ) {\n\n\t\t\t\ttempPoint.copy( start );\n\n\t\t\t}\n\n\t\t\t// ignore the end point\n\t\t\tif ( ( doesIntersect || startIntersects ) && ! isNearZero( tempPoint.distanceTo( end ) ) ) {\n\n\t\t\t\tif ( count <= 1 ) {\n\n\t\t\t\t\t// assign to the start or end point and save which index was snapped to\n\t\t\t\t\t// the start point if necessary\n\t\t\t\t\tconst point = count === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tif ( startIntersects ) {\n\n\t\t\t\t\t\tstartPointIntersection = count;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( count >= 2 ) {\n\n\t\t\t\t\t// if we're here that means that there must have been one point that had\n\t\t\t\t\t// snapped to the start point so replace it here\n\t\t\t\t\tconst point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n\t\t\t\t\tpoint.copy( tempPoint );\n\t\t\t\t\tcount = 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tcount ++;\n\t\t\t\tif ( count === 2 && startPointIntersection === - 1 ) {\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn count;\n\n\t}\n\n\t// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n\t// be a line contained by both triangles if not a different special case somehow represented in the return result.\n\treturn function intersectsTriangle( other, target = null, suppressLog = false ) {\n\n\t\tif ( this.needsUpdate ) {\n\n\t\t\tthis.update();\n\n\t\t}\n\n\t\tif ( ! other.isExtendedTriangle ) {\n\n\t\t\tsaTri2.copy( other );\n\t\t\tsaTri2.update();\n\t\t\tother = saTri2;\n\n\t\t} else if ( other.needsUpdate ) {\n\n\t\t\tother.update();\n\n\t\t}\n\n\t\tconst plane1 = this.plane;\n\t\tconst plane2 = other.plane;\n\n\t\tif ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {\n\n\t\t\t// perform separating axis intersection test only for coplanar triangles\n\t\t\tconst satBounds1 = this.satBounds;\n\t\t\tconst satAxes1 = this.satAxes;\n\t\t\tarr2[ 0 ] = other.a;\n\t\t\tarr2[ 1 ] = other.b;\n\t\t\tarr2[ 2 ] = other.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds1[ i ];\n\t\t\t\tconst sa = satAxes1[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr2 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\tconst satBounds2 = other.satBounds;\n\t\t\tconst satAxes2 = other.satAxes;\n\t\t\tarr1[ 0 ] = this.a;\n\t\t\tarr1[ 1 ] = this.b;\n\t\t\tarr1[ 2 ] = this.c;\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sb = satBounds2[ i ];\n\t\t\t\tconst sa = satAxes2[ i ];\n\t\t\t\tcachedSatBounds.setFromPoints( sa, arr1 );\n\t\t\t\tif ( sb.isSeparated( cachedSatBounds ) ) return false;\n\n\t\t\t}\n\n\t\t\t// check crossed axes\n\t\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\t\tconst sa1 = satAxes1[ i ];\n\t\t\t\tfor ( let i2 = 0; i2 < 4; i2 ++ ) {\n\n\t\t\t\t\tconst sa2 = satAxes2[ i2 ];\n\t\t\t\t\tcachedAxis.crossVectors( sa1, sa2 );\n\t\t\t\t\tcachedSatBounds.setFromPoints( cachedAxis, arr1 );\n\t\t\t\t\tcachedSatBounds2.setFromPoints( cachedAxis, arr2 );\n\t\t\t\t\tif ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( target ) {\n\n\t\t\t\t// TODO find two points that intersect on the edges and make that the result\n\t\t\t\tif ( ! suppressLog ) {\n\n\t\t\t\t\tconsole.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );\n\n\t\t\t\t}\n\n\t\t\t\ttarget.start.set( 0, 0, 0 );\n\t\t\t\ttarget.end.set( 0, 0, 0 );\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t} else {\n\n\t\t\t// find the edge that intersects the other triangle plane\n\t\t\tconst count1 = triIntersectPlane( this, plane2, edge1 );\n\t\t\tif ( count1 === 1 && other.containsPoint( edge1.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.end );\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count1 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find the other triangles edge that intersects this plane\n\t\t\tconst count2 = triIntersectPlane( other, plane1, edge2 );\n\t\t\tif ( count2 === 1 && this.containsPoint( edge2.end ) ) {\n\n\t\t\t\tif ( target ) {\n\n\t\t\t\t\ttarget.start.copy( edge2.end );\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t} else if ( count2 !== 2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// find swap the second edge so both lines are running the same direction\n\t\t\tedge1.delta( dir1 );\n\t\t\tedge2.delta( dir2 );\n\n\t\t\tif ( dir1.dot( dir2 ) < 0 ) {\n\n\t\t\t\tlet tmp = edge2.start;\n\t\t\t\tedge2.start = edge2.end;\n\t\t\t\tedge2.end = tmp;\n\n\t\t\t}\n\n\t\t\t// check if the edges are overlapping\n\t\t\tconst s1 = edge1.start.dot( dir1 );\n\t\t\tconst e1 = edge1.end.dot( dir1 );\n\t\t\tconst s2 = edge2.start.dot( dir1 );\n\t\t\tconst e2 = edge2.end.dot( dir1 );\n\t\t\tconst separated1 = e1 < s2;\n\t\t\tconst separated2 = s1 < e2;\n\n\t\t\tif ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\t// assign the target output\n\t\t\tif ( target ) {\n\n\t\t\t\ttempDir.subVectors( edge1.start, edge2.start );\n\t\t\t\tif ( tempDir.dot( dir1 ) > 0 ) {\n\n\t\t\t\t\ttarget.start.copy( edge1.start );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.start.copy( edge2.start );\n\n\t\t\t\t}\n\n\t\t\t\ttempDir.subVectors( edge1.end, edge2.end );\n\t\t\t\tif ( tempDir.dot( dir1 ) < 0 ) {\n\n\t\t\t\t\ttarget.end.copy( edge1.end );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttarget.end.copy( edge2.end );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToPoint = ( function () {\n\n\tconst target = new Vector3();\n\treturn function distanceToPoint( point ) {\n\n\t\tthis.closestPointToPoint( point, target );\n\t\treturn point.distanceTo( target );\n\n\t};\n\n} )();\n\n\nExtendedTriangle.prototype.distanceToTriangle = ( function () {\n\n\tconst point = new Vector3();\n\tconst point2 = new Vector3();\n\tconst cornerFields = [ 'a', 'b', 'c' ];\n\tconst line1 = new Line3();\n\tconst line2 = new Line3();\n\n\treturn function distanceToTriangle( other, target1 = null, target2 = null ) {\n\n\t\tconst lineTarget = target1 || target2 ? line1 : null;\n\t\tif ( this.intersectsTriangle( other, lineTarget ) ) {\n\n\t\t\tif ( target1 || target2 ) {\n\n\t\t\t\tif ( target1 ) lineTarget.getCenter( target1 );\n\t\t\t\tif ( target2 ) lineTarget.getCenter( target2 );\n\n\t\t\t}\n\n\t\t\treturn 0;\n\n\t\t}\n\n\t\tlet closestDistanceSq = Infinity;\n\n\t\t// check all point distances\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tlet dist;\n\t\t\tconst field = cornerFields[ i ];\n\t\t\tconst otherVec = other[ field ];\n\t\t\tthis.closestPointToPoint( otherVec, point );\n\n\t\t\tdist = otherVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\tif ( target2 ) target2.copy( otherVec );\n\n\t\t\t}\n\n\n\t\t\tconst thisVec = this[ field ];\n\t\t\tother.closestPointToPoint( thisVec, point );\n\n\t\t\tdist = thisVec.distanceToSquared( point );\n\n\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\tif ( target1 ) target1.copy( thisVec );\n\t\t\t\tif ( target2 ) target2.copy( point );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst f11 = cornerFields[ i ];\n\t\t\tconst f12 = cornerFields[ ( i + 1 ) % 3 ];\n\t\t\tline1.set( this[ f11 ], this[ f12 ] );\n\t\t\tfor ( let i2 = 0; i2 < 3; i2 ++ ) {\n\n\t\t\t\tconst f21 = cornerFields[ i2 ];\n\t\t\t\tconst f22 = cornerFields[ ( i2 + 1 ) % 3 ];\n\t\t\t\tline2.set( other[ f21 ], other[ f22 ] );\n\n\t\t\t\tclosestPointsSegmentToSegment( line1, line2, point, point2 );\n\n\t\t\t\tconst dist = point.distanceToSquared( point2 );\n\t\t\t\tif ( dist < closestDistanceSq ) {\n\n\t\t\t\t\tclosestDistanceSq = dist;\n\t\t\t\t\tif ( target1 ) target1.copy( point );\n\t\t\t\t\tif ( target2 ) target2.copy( point2 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Math.sqrt( closestDistanceSq );\n\n\t};\n\n} )();\n","import { Vector3, Vector2, Plane, Line3 } from 'three';\n\nexport const closestPointLineToLine = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n\tconst dir1 = new Vector3();\n\tconst dir2 = new Vector3();\n\tconst v02 = new Vector3();\n\treturn function closestPointLineToLine( l1, l2, result ) {\n\n\t\tconst v0 = l1.start;\n\t\tconst v10 = dir1;\n\t\tconst v2 = l2.start;\n\t\tconst v32 = dir2;\n\n\t\tv02.subVectors( v0, v2 );\n\t\tdir1.subVectors( l1.end, l1.start );\n\t\tdir2.subVectors( l2.end, l2.start );\n\n\t\t// float d0232 = v02.Dot(v32);\n\t\tconst d0232 = v02.dot( v32 );\n\n\t\t// float d3210 = v32.Dot(v10);\n\t\tconst d3210 = v32.dot( v10 );\n\n\t\t// float d3232 = v32.Dot(v32);\n\t\tconst d3232 = v32.dot( v32 );\n\n\t\t// float d0210 = v02.Dot(v10);\n\t\tconst d0210 = v02.dot( v10 );\n\n\t\t// float d1010 = v10.Dot(v10);\n\t\tconst d1010 = v10.dot( v10 );\n\n\t\t// float denom = d1010*d3232 - d3210*d3210;\n\t\tconst denom = d1010 * d3232 - d3210 * d3210;\n\n\t\tlet d, d2;\n\t\tif ( denom !== 0 ) {\n\n\t\t\td = ( d0232 * d3210 - d0210 * d3232 ) / denom;\n\n\t\t} else {\n\n\t\t\td = 0;\n\n\t\t}\n\n\t\td2 = ( d0232 + d * d3210 ) / d3232;\n\n\t\tresult.x = d;\n\t\tresult.y = d2;\n\n\t};\n\n} )();\n\nexport const closestPointsSegmentToSegment = ( function () {\n\n\t// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n\tconst paramResult = new Vector2();\n\tconst temp1 = new Vector3();\n\tconst temp2 = new Vector3();\n\treturn function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {\n\n\t\tclosestPointLineToLine( l1, l2, paramResult );\n\n\t\tlet d = paramResult.x;\n\t\tlet d2 = paramResult.y;\n\t\tif ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {\n\n\t\t\tl1.at( d, target1 );\n\t\t\tl2.at( d2, target2 );\n\n\t\t\treturn;\n\n\t\t} else if ( d >= 0 && d <= 1 ) {\n\n\t\t\t// Only d2 is out of bounds.\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tl2.at( 0, target2 );\n\n\t\t\t} else {\n\n\t\t\t\tl2.at( 1, target2 );\n\n\t\t\t}\n\n\t\t\tl1.closestPointToPoint( target2, true, target1 );\n\t\t\treturn;\n\n\t\t} else if ( d2 >= 0 && d2 <= 1 ) {\n\n\t\t\t// Only d is out of bounds.\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tl1.at( 0, target1 );\n\n\t\t\t} else {\n\n\t\t\t\tl1.at( 1, target1 );\n\n\t\t\t}\n\n\t\t\tl2.closestPointToPoint( target1, true, target2 );\n\t\t\treturn;\n\n\t\t} else {\n\n\t\t\t// Both u and u2 are out of bounds.\n\t\t\tlet p;\n\t\t\tif ( d < 0 ) {\n\n\t\t\t\tp = l1.start;\n\n\t\t\t} else {\n\n\t\t\t\tp = l1.end;\n\n\t\t\t}\n\n\t\t\tlet p2;\n\t\t\tif ( d2 < 0 ) {\n\n\t\t\t\tp2 = l2.start;\n\n\t\t\t} else {\n\n\t\t\t\tp2 = l2.end;\n\n\t\t\t}\n\n\t\t\tconst closestPoint = temp1;\n\t\t\tconst closestPoint2 = temp2;\n\t\t\tl1.closestPointToPoint( p2, true, temp1 );\n\t\t\tl2.closestPointToPoint( p, true, temp2 );\n\n\t\t\tif ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {\n\n\t\t\t\ttarget1.copy( closestPoint );\n\t\t\t\ttarget2.copy( p2 );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\ttarget1.copy( p );\n\t\t\t\ttarget2.copy( closestPoint2 );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n} )();\n\n\nexport const sphereIntersectTriangle = ( function () {\n\n\t// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n\tconst closestPointTemp = new Vector3();\n\tconst projectedPointTemp = new Vector3();\n\tconst planeTemp = new Plane();\n\tconst lineTemp = new Line3();\n\treturn function sphereIntersectTriangle( sphere, triangle ) {\n\n\t\tconst { radius, center } = sphere;\n\t\tconst { a, b, c } = triangle;\n\n\t\t// phase 1\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = b;\n\t\tconst closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint1.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = a;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint2.distanceTo( center ) <= radius ) return true;\n\n\t\tlineTemp.start = b;\n\t\tlineTemp.end = c;\n\t\tconst closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );\n\t\tif ( closestPoint3.distanceTo( center ) <= radius ) return true;\n\n\t\t// phase 2\n\t\tconst plane = triangle.getPlane( planeTemp );\n\t\tconst dp = Math.abs( plane.distanceToPoint( center ) );\n\t\tif ( dp <= radius ) {\n\n\t\t\tconst pp = plane.projectPoint( center, projectedPointTemp );\n\t\t\tconst cp = triangle.containsPoint( pp );\n\t\t\tif ( cp ) return true;\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n} )();\n","import { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from './PrimitivePool.js';\n\nclass ExtendedTrianglePoolBase extends PrimitivePool {\n\n\tconstructor() {\n\n\t\tsuper( () => new ExtendedTriangle() );\n\n\t}\n\n}\n\nexport const ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n","export class PrimitivePool {\n\n\tconstructor( getNewPrimitive ) {\n\n\t\tthis._getNewPrimitive = getNewPrimitive;\n\t\tthis._primitives = [];\n\n\t}\n\n\tgetPrimitive() {\n\n\t\tconst primitives = this._primitives;\n\t\tif ( primitives.length === 0 ) {\n\n\t\t\treturn this._getNewPrimitive();\n\n\t\t} else {\n\n\t\t\treturn primitives.pop();\n\n\t\t}\n\n\t}\n\n\treleasePrimitive( primitive ) {\n\n\t\tthis._primitives.push( primitive );\n\n\t}\n\n}\n","import { Box3 } from 'three';\nimport { CONTAINED } from '../Constants.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\nimport { COUNT, OFFSET, LEFT_NODE, RIGHT_NODE, IS_LEAF, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new PrimitivePool( () => new Box3() );\n\nexport function shapecast( bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset ) {\n\n\t// setup\n\t_box1 = boxPool.getPrimitive();\n\t_box2 = boxPool.getPrimitive();\n\tboxStack.push( _box1, _box2 );\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\n\tconst result = shapecastTraverse( 0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\n\n\t// cleanup\n\tBufferStack.clearBuffer();\n\tboxPool.releasePrimitive( _box1 );\n\tboxPool.releasePrimitive( _box2 );\n\tboxStack.pop();\n\tboxStack.pop();\n\n\tconst length = boxStack.length;\n\tif ( length > 0 ) {\n\n\t\t_box2 = boxStack[ length - 1 ];\n\t\t_box1 = boxStack[ length - 2 ];\n\n\t}\n\n\treturn result;\n\n}\n\nfunction shapecastTraverse(\n\tnodeIndex32,\n\tgeometry,\n\tintersectsBoundsFunc,\n\tintersectsRangeFunc,\n\tnodeScoreFunc = null,\n\tnodeIndexByteOffset = 0, // offset for unique node identifier\n\tdepth = 0\n) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, _box1 );\n\t\treturn intersectsRangeFunc( offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1 );\n\n\t} else {\n\n\t\tconst left = LEFT_NODE( nodeIndex32 );\n\t\tconst right = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tlet c1 = left;\n\t\tlet c2 = right;\n\n\t\tlet score1, score2;\n\t\tlet box1, box2;\n\t\tif ( nodeScoreFunc ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tbox2 = _box2;\n\n\t\t\t// bounding data is not offset\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\t\tscore1 = nodeScoreFunc( box1 );\n\t\t\tscore2 = nodeScoreFunc( box2 );\n\n\t\t\tif ( score2 < score1 ) {\n\n\t\t\t\tc1 = right;\n\t\t\t\tc2 = left;\n\n\t\t\t\tconst temp = score1;\n\t\t\t\tscore1 = score2;\n\t\t\t\tscore2 = temp;\n\n\t\t\t\tbox1 = box2;\n\t\t\t\t// box2 is always set before use below\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Check box 1 intersection\n\t\tif ( ! box1 ) {\n\n\t\t\tbox1 = _box1;\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( c1 ), float32Array, box1 );\n\n\t\t}\n\n\t\tconst isC1Leaf = IS_LEAF( c1 * 2, uint16Array );\n\t\tconst c1Intersection = intersectsBoundsFunc( box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1 );\n\n\t\tlet c1StopTraversal;\n\t\tif ( c1Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c1 );\n\t\t\tconst end = getRightEndOffset( c1 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc1StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1 );\n\n\t\t} else {\n\n\t\t\tc1StopTraversal =\n\t\t\t\tc1Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc1,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c1StopTraversal ) return true;\n\n\t\t// Check box 2 intersection\n\t\t// cached box2 will have been overwritten by previous traversal\n\t\tbox2 = _box2;\n\t\tarrayToBox( BOUNDING_DATA_INDEX( c2 ), float32Array, box2 );\n\n\t\tconst isC2Leaf = IS_LEAF( c2 * 2, uint16Array );\n\t\tconst c2Intersection = intersectsBoundsFunc( box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2 );\n\n\t\tlet c2StopTraversal;\n\t\tif ( c2Intersection === CONTAINED ) {\n\n\t\t\tconst offset = getLeftOffset( c2 );\n\t\t\tconst end = getRightEndOffset( c2 );\n\t\t\tconst count = end - offset;\n\n\t\t\tc2StopTraversal = intersectsRangeFunc( offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2 );\n\n\t\t} else {\n\n\t\t\tc2StopTraversal =\n\t\t\t\tc2Intersection &&\n\t\t\t\tshapecastTraverse(\n\t\t\t\t\tc2,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tintersectsBoundsFunc,\n\t\t\t\t\tintersectsRangeFunc,\n\t\t\t\t\tnodeScoreFunc,\n\t\t\t\t\tnodeIndexByteOffset,\n\t\t\t\t\tdepth + 1\n\t\t\t\t);\n\n\t\t}\n\n\t\tif ( c2StopTraversal ) return true;\n\n\t\treturn false;\n\n\t\t// Define these inside the function so it has access to the local variables needed\n\t\t// when converting to the buffer equivalents\n\t\tfunction getLeftOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\tnodeIndex32 = LEFT_NODE( nodeIndex32 );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\treturn OFFSET( nodeIndex32, uint32Array );\n\n\t\t}\n\n\t\tfunction getRightEndOffset( nodeIndex32 ) {\n\n\t\t\tconst { uint16Array, uint32Array } = BufferStack;\n\t\t\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t// traverse until we find a leaf\n\t\t\twhile ( ! IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\t\t// adjust offset to point to the right node\n\t\t\t\tnodeIndex32 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\t\tnodeIndex16 = nodeIndex32 * 2;\n\n\t\t\t}\n\n\t\t\t// return the end offset of the triangle range\n\t\t\treturn OFFSET( nodeIndex32, uint32Array ) + COUNT( nodeIndex16, uint16Array );\n\n\t\t}\n\n\t}\n\n}\n","class _BufferStack {\n\n\tconstructor() {\n\n\t\tthis.float32Array = null;\n\t\tthis.uint16Array = null;\n\t\tthis.uint32Array = null;\n\n\t\tconst stack = [];\n\t\tlet prevBuffer = null;\n\t\tthis.setBuffer = buffer => {\n\n\t\t\tif ( prevBuffer ) {\n\n\t\t\t\tstack.push( prevBuffer );\n\n\t\t\t}\n\n\t\t\tprevBuffer = buffer;\n\t\t\tthis.float32Array = new Float32Array( buffer );\n\t\t\tthis.uint16Array = new Uint16Array( buffer );\n\t\t\tthis.uint32Array = new Uint32Array( buffer );\n\n\t\t};\n\n\t\tthis.clearBuffer = () => {\n\n\t\t\tprevBuffer = null;\n\t\t\tthis.float32Array = null;\n\t\t\tthis.uint16Array = null;\n\t\t\tthis.uint32Array = null;\n\n\t\t\tif ( stack.length !== 0 ) {\n\n\t\t\t\tthis.setBuffer( stack.pop() );\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n}\n\nexport const BufferStack = new _BufferStack();\n","import { Vector3 } from 'three';\n\nconst temp = /* @__PURE__ */ new Vector3();\nconst temp1 = /* @__PURE__ */ new Vector3();\n\nexport function closestPointToPoint(\n\tbvh,\n\tpoint,\n\ttarget = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\t// early out if under minThreshold\n\t// skip checking if over maxThreshold\n\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\n\t// returns Infinity if no value found\n\tconst minThresholdSq = minThreshold * minThreshold;\n\tconst maxThresholdSq = maxThreshold * maxThreshold;\n\tlet closestDistanceSq = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tbvh.shapecast(\n\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\n\t\t\t\treturn temp.distanceToSquared( point );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\n\n\t\t\t},\n\n\t\t\tintersectsTriangle: ( tri, triIndex ) => {\n\n\t\t\t\ttri.closestPointToPoint( point, temp );\n\t\t\t\tconst distSq = point.distanceToSquared( temp );\n\t\t\t\tif ( distSq < closestDistanceSq ) {\n\n\t\t\t\t\ttemp1.copy( temp );\n\t\t\t\t\tclosestDistanceSq = distSq;\n\t\t\t\t\tclosestDistanceTriIndex = triIndex;\n\n\t\t\t\t}\n\n\t\t\t\tif ( distSq < minThresholdSq ) {\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tif ( closestDistanceSq === Infinity ) return null;\n\n\tconst closestDistance = Math.sqrt( closestDistanceSq );\n\n\tif ( ! target.point ) target.point = temp1.clone();\n\telse target.point.copy( temp1 );\n\ttarget.distance = closestDistance,\n\ttarget.faceIndex = closestDistanceTriIndex;\n\n\treturn target;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\n\t\tintersectTri( geometry, side, ray, i, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\n\t\tintersection = intersectTri( geometry, side, ray, i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\n\t\ttri = i;\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri, intersectTris, iterateOverTriangles };\n","import { Vector3, Vector2, Triangle, DoubleSide, BackSide } from 'three';\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\n\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\n\nconst _normalA = /* @__PURE__ */ new Vector3();\nconst _normalB = /* @__PURE__ */ new Vector3();\nconst _normalC = /* @__PURE__ */ new Vector3();\n\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nfunction checkIntersection( ray, pA, pB, pC, point, side ) {\n\n\tlet intersect;\n\tif ( side === BackSide ) {\n\n\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\n\n\t} else {\n\n\t\tintersect = ray.intersectTriangle( pA, pB, pC, side !== DoubleSide, point );\n\n\t}\n\n\tif ( intersect === null ) return null;\n\n\tconst distance = ray.origin.distanceTo( point );\n\n\treturn {\n\n\t\tdistance: distance,\n\t\tpoint: point.clone(),\n\n\t};\n\n}\n\nfunction checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side ) {\n\n\t_vA.fromBufferAttribute( position, a );\n\t_vB.fromBufferAttribute( position, b );\n\t_vC.fromBufferAttribute( position, c );\n\n\tconst intersection = checkIntersection( ray, _vA, _vB, _vC, _intersectionPoint, side );\n\n\tif ( intersection ) {\n\n\t\tif ( uv ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv, a );\n\t\t\t_uvB.fromBufferAttribute( uv, b );\n\t\t\t_uvC.fromBufferAttribute( uv, c );\n\n\t\t\tintersection.uv = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( uv1 ) {\n\n\t\t\t_uvA.fromBufferAttribute( uv1, a );\n\t\t\t_uvB.fromBufferAttribute( uv1, b );\n\t\t\t_uvC.fromBufferAttribute( uv1, c );\n\n\t\t\tintersection.uv1 = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );\n\n\t\t}\n\n\t\tif ( normal ) {\n\n\t\t\t_normalA.fromBufferAttribute( normal, a );\n\t\t\t_normalB.fromBufferAttribute( normal, b );\n\t\t\t_normalC.fromBufferAttribute( normal, c );\n\n\t\t\tintersection.normal = Triangle.getInterpolation( _intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3() );\n\t\t\tif ( intersection.normal.dot( ray.direction ) > 0 ) {\n\n\t\t\t\tintersection.normal.multiplyScalar( - 1 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst face = {\n\t\t\ta: a,\n\t\t\tb: b,\n\t\t\tc: c,\n\t\t\tnormal: new Vector3(),\n\t\t\tmaterialIndex: 0\n\t\t};\n\n\t\tTriangle.getNormal( _vA, _vB, _vC, face.normal );\n\n\t\tintersection.face = face;\n\t\tintersection.faceIndex = a;\n\n\t}\n\n\treturn intersection;\n\n}\n\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri( geo, side, ray, tri, intersections ) {\n\n\tconst triOffset = tri * 3;\n\tlet a = triOffset + 0;\n\tlet b = triOffset + 1;\n\tlet c = triOffset + 2;\n\n\tconst index = geo.index;\n\tif ( geo.index ) {\n\n\t\ta = index.getX( a );\n\t\tb = index.getX( b );\n\t\tc = index.getX( c );\n\n\t}\n\n\tconst { position, normal, uv, uv1 } = geo.attributes;\n\tconst intersection = checkBufferGeometryIntersection( ray, position, normal, uv, uv1, a, b, c, side );\n\n\tif ( intersection ) {\n\n\t\tintersection.faceIndex = tri;\n\t\tif ( intersections ) intersections.push( intersection );\n\t\treturn intersection;\n\n\t}\n\n\treturn null;\n\n}\n\nexport { intersectTri };\n","\nimport { Vector2, Vector3, Triangle } from 'three';\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nexport function setTriangle( tri, i, index, pos ) {\n\n\tconst ta = tri.a;\n\tconst tb = tri.b;\n\tconst tc = tri.c;\n\n\tlet i0 = i;\n\tlet i1 = i + 1;\n\tlet i2 = i + 2;\n\tif ( index ) {\n\n\t\ti0 = index.getX( i0 );\n\t\ti1 = index.getX( i1 );\n\t\ti2 = index.getX( i2 );\n\n\t}\n\n\tta.x = pos.getX( i0 );\n\tta.y = pos.getY( i0 );\n\tta.z = pos.getZ( i0 );\n\n\ttb.x = pos.getX( i1 );\n\ttb.y = pos.getY( i1 );\n\ttb.z = pos.getZ( i1 );\n\n\ttc.x = pos.getX( i2 );\n\ttc.y = pos.getY( i2 );\n\ttc.z = pos.getZ( i2 );\n\n}\n\nconst tempV1 = /* @__PURE__ */ new Vector3();\nconst tempV2 = /* @__PURE__ */ new Vector3();\nconst tempV3 = /* @__PURE__ */ new Vector3();\nconst tempUV1 = /* @__PURE__ */ new Vector2();\nconst tempUV2 = /* @__PURE__ */ new Vector2();\nconst tempUV3 = /* @__PURE__ */ new Vector2();\n\nexport function getTriangleHitPointInfo( point, geometry, triangleIndex, target ) {\n\n\tconst indices = geometry.getIndex().array;\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst uvs = geometry.getAttribute( 'uv' );\n\n\tconst a = indices[ triangleIndex * 3 ];\n\tconst b = indices[ triangleIndex * 3 + 1 ];\n\tconst c = indices[ triangleIndex * 3 + 2 ];\n\n\ttempV1.fromBufferAttribute( positions, a );\n\ttempV2.fromBufferAttribute( positions, b );\n\ttempV3.fromBufferAttribute( positions, c );\n\n\t// find the associated material index\n\tlet materialIndex = 0;\n\tconst groups = geometry.groups;\n\tconst firstVertexIndex = triangleIndex * 3;\n\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\t\tconst { start, count } = group;\n\t\tif ( firstVertexIndex >= start && firstVertexIndex < start + count ) {\n\n\t\t\tmaterialIndex = group.materialIndex;\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t// extract uvs\n\tlet uv = null;\n\tif ( uvs ) {\n\n\t\ttempUV1.fromBufferAttribute( uvs, a );\n\t\ttempUV2.fromBufferAttribute( uvs, b );\n\t\ttempUV3.fromBufferAttribute( uvs, c );\n\n\t\tif ( target && target.uv ) uv = target.uv;\n\t\telse uv = new Vector2();\n\n\t\tTriangle.getInterpolation( point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv );\n\n\t}\n\n\t// adjust the provided target or create a new one\n\tif ( target ) {\n\n\t\tif ( ! target.face ) target.face = { };\n\t\ttarget.face.a = a;\n\t\ttarget.face.b = b;\n\t\ttarget.face.c = c;\n\t\ttarget.face.materialIndex = materialIndex;\n\t\tif ( ! target.face.normal ) target.face.normal = new Vector3();\n\t\tTriangle.getNormal( tempV1, tempV2, tempV3, target.face.normal );\n\n\t\tif ( uv ) target.uv = uv;\n\n\t\treturn target;\n\n\t} else {\n\n\t\treturn {\n\t\t\tface: {\n\t\t\t\ta: a,\n\t\t\t\tb: b,\n\t\t\t\tc: c,\n\t\t\t\tmaterialIndex: materialIndex,\n\t\t\t\tnormal: Triangle.getNormal( tempV1, tempV2, tempV3, new Vector3() )\n\t\t\t},\n\t\t\tuv: uv\n\t\t};\n\n\t}\n\n}\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\n\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\n\n\t\t\t\tlet index = indexArr[ i ];\n\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\tif ( z > maxz ) maxz = z;\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectTris } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\tintersectTris( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast };\n","/**\n * This function performs intersection tests similar to Ray.intersectBox in three.js,\n * with the difference that the box values are read from an array to improve performance.\n */\nexport function intersectRay( nodeIndex32, array, ray ) {\n\n\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\tconst invdirx = 1 / ray.direction.x,\n\t\tinvdiry = 1 / ray.direction.y,\n\t\tinvdirz = 1 / ray.direction.z;\n\n\tconst ox = ray.origin.x;\n\tconst oy = ray.origin.y;\n\tconst oz = ray.origin.z;\n\n\tlet minx = array[ nodeIndex32 ];\n\tlet maxx = array[ nodeIndex32 + 3 ];\n\n\tlet miny = array[ nodeIndex32 + 1 ];\n\tlet maxy = array[ nodeIndex32 + 3 + 1 ];\n\n\tlet minz = array[ nodeIndex32 + 2 ];\n\tlet maxz = array[ nodeIndex32 + 3 + 2 ];\n\n\tif ( invdirx >= 0 ) {\n\n\t\ttmin = ( minx - ox ) * invdirx;\n\t\ttmax = ( maxx - ox ) * invdirx;\n\n\t} else {\n\n\t\ttmin = ( maxx - ox ) * invdirx;\n\t\ttmax = ( minx - ox ) * invdirx;\n\n\t}\n\n\tif ( invdiry >= 0 ) {\n\n\t\ttymin = ( miny - oy ) * invdiry;\n\t\ttymax = ( maxy - oy ) * invdiry;\n\n\t} else {\n\n\t\ttymin = ( maxy - oy ) * invdiry;\n\t\ttymax = ( miny - oy ) * invdiry;\n\n\t}\n\n\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return false;\n\n\tif ( tymin > tmin || isNaN( tmin ) ) tmin = tymin;\n\n\tif ( tymax < tmax || isNaN( tmax ) ) tmax = tymax;\n\n\tif ( invdirz >= 0 ) {\n\n\t\ttzmin = ( minz - oz ) * invdirz;\n\t\ttzmax = ( maxz - oz ) * invdirz;\n\n\t} else {\n\n\t\ttzmin = ( maxz - oz ) * invdirz;\n\t\ttzmax = ( minz - oz ) * invdirz;\n\n\t}\n\n\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return false;\n\n\t// if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin; // Uncomment this line if add the distance check\n\n\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t//return point closest to the ray (positive side)\n\n\tif ( tmax < 0 ) return false;\n\n\treturn true;\n\n}\n","import { intersectTri } from '../../utils/ThreeRayIntersectUtilities.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\n\n/*************************************************************/\n/* This file is generated from \"iterationUtils.template.js\". */\n/*************************************************************/\n/* eslint-disable indent */\n\nfunction intersectTris_indirect( bvh, side, ray, offset, count, intersections ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet vi = _indirectBuffer ? _indirectBuffer[ i ] : i;\n\t\tintersectTri( geometry, side, ray, vi, intersections );\n\n\n\t}\n\n}\n\nfunction intersectClosestTri_indirect( bvh, side, ray, offset, count ) {\n\n\tconst { geometry, _indirectBuffer } = bvh;\n\tlet dist = Infinity;\n\tlet res = null;\n\tfor ( let i = offset, end = offset + count; i < end; i ++ ) {\n\n\t\tlet intersection;\n\t\tintersection = intersectTri( geometry, side, ray, _indirectBuffer ? _indirectBuffer[ i ] : i );\n\n\n\t\tif ( intersection && intersection.distance < dist ) {\n\n\t\t\tres = intersection;\n\t\t\tdist = intersection.distance;\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\nfunction iterateOverTriangles_indirect(\n\toffset,\n\tcount,\n\tbvh,\n\tintersectsTriangleFunc,\n\tcontained,\n\tdepth,\n\ttriangle\n) {\n\n\tconst { geometry } = bvh;\n\tconst { index } = geometry;\n\tconst pos = geometry.attributes.position;\n\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\tlet tri;\n\t\ttri = bvh.resolveTriangleIndex( i );\n\n\t\tsetTriangle( triangle, tri * 3, index, pos );\n\t\ttriangle.needsUpdate = true;\n\n\t\tif ( intersectsTriangleFunc( triangle, tri, contained, depth ) ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t}\n\n\treturn false;\n\n}\n\nexport { intersectClosestTri_indirect, intersectTris_indirect, iterateOverTriangles_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport { intersectClosestTri } from '../utils/iterationUtils.generated.js';\nimport '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\n\t\treturn intersectClosestTri( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\n\t\t\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, i, thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\n\t\t\tfor ( let i = offset * 3, l = ( count + offset ) * 3; i < l; i += 3 ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tsetTriangle( triangle, i, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * i, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry };\n","import { IS_LEAFNODE_FLAG } from '../Constants.js';\n\n/****************************************************/\n/* This file is generated from \"refit.template.js\". */\n/****************************************************/\n\nfunction refit_indirect( bvh, nodeIndices = null ) {\n\n\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\n\n\t\tnodeIndices = new Set( nodeIndices );\n\n\t}\n\n\tconst geometry = bvh.geometry;\n\tconst indexArr = geometry.index ? geometry.index.array : null;\n\tconst posAttr = geometry.attributes.position;\n\n\tlet buffer, uint32Array, uint16Array, float32Array;\n\tlet byteOffset = 0;\n\tconst roots = bvh._roots;\n\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\n\n\t\tbuffer = roots[ i ];\n\t\tuint32Array = new Uint32Array( buffer );\n\t\tuint16Array = new Uint16Array( buffer );\n\t\tfloat32Array = new Float32Array( buffer );\n\n\t\t_traverse( 0, byteOffset );\n\t\tbyteOffset += buffer.byteLength;\n\n\t}\n\n\tfunction _traverse( node32Index, byteOffset, force = false ) {\n\n\t\tconst node16Index = node32Index * 2;\n\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\n\t\tif ( isLeaf ) {\n\n\t\t\tconst offset = uint32Array[ node32Index + 6 ];\n\t\t\tconst count = uint16Array[ node16Index + 14 ];\n\n\t\t\tlet minx = Infinity;\n\t\t\tlet miny = Infinity;\n\t\t\tlet minz = Infinity;\n\t\t\tlet maxx = - Infinity;\n\t\t\tlet maxy = - Infinity;\n\t\t\tlet maxz = - Infinity;\n\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst t = 3 * bvh.resolveTriangleIndex( i );\n\t\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tlet index = t + j;\n\t\t\t\t\tindex = indexArr ? indexArr[ index ] : index;\n\n\t\t\t\t\tconst x = posAttr.getX( index );\n\t\t\t\t\tconst y = posAttr.getY( index );\n\t\t\t\t\tconst z = posAttr.getZ( index );\n\n\t\t\t\t\tif ( x < minx ) minx = x;\n\t\t\t\t\tif ( x > maxx ) maxx = x;\n\n\t\t\t\t\tif ( y < miny ) miny = y;\n\t\t\t\t\tif ( y > maxy ) maxy = y;\n\n\t\t\t\t\tif ( z < minz ) minz = z;\n\t\t\t\t\tif ( z > maxz ) maxz = z;\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tif (\n\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\n\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\n\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\n\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\n\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\n\t\t\t) {\n\n\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\n\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\n\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\n\n\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\n\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\n\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\n\n\t\t\t\treturn true;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst left = node32Index + 8;\n\t\t\tconst right = uint32Array[ node32Index + 6 ];\n\n\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\n\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\n\t\t\tconst offsetLeft = left + byteOffset;\n\t\t\tconst offsetRight = right + byteOffset;\n\t\t\tlet forceChildren = force;\n\t\t\tlet includesLeft = false;\n\t\t\tlet includesRight = false;\n\n\t\t\tif ( nodeIndices ) {\n\n\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\n\t\t\t\t// then we assume that all children need to be updated.\n\t\t\t\tif ( ! forceChildren ) {\n\n\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\n\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\n\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tincludesLeft = true;\n\t\t\t\tincludesRight = true;\n\n\t\t\t}\n\n\t\t\tconst traverseLeft = forceChildren || includesLeft;\n\t\t\tconst traverseRight = forceChildren || includesRight;\n\n\t\t\tlet leftChange = false;\n\t\t\tif ( traverseLeft ) {\n\n\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tlet rightChange = false;\n\t\t\tif ( traverseRight ) {\n\n\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\n\n\t\t\t}\n\n\t\t\tconst didChange = leftChange || rightChange;\n\t\t\tif ( didChange ) {\n\n\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tconst lefti = left + i;\n\t\t\t\t\tconst righti = right + i;\n\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\n\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\n\t\t\t\t\tconst minRightValue = float32Array[ righti ];\n\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\n\n\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn didChange;\n\n\t\t}\n\n\t}\n\n}\n\nexport { refit_indirect };\n","import { intersectRay } from '../utils/intersectUtils.js';\nimport { IS_LEAF, OFFSET, COUNT, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectTris_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/******************************************************/\n/* This file is generated from \"raycast.template.js\". */\n/******************************************************/\n\nfunction raycast_indirect( bvh, root, side, ray, intersects ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\t_raycast( 0, bvh, side, ray, intersects );\n\tBufferStack.clearBuffer();\n\n}\n\nfunction _raycast( nodeIndex32, bvh, side, ray, intersects ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tconst nodeIndex16 = nodeIndex32 * 2;\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\tintersectTris_indirect( bvh, side, ray, offset, count, intersects );\n\n\n\t} else {\n\n\t\tconst leftIndex = LEFT_NODE( nodeIndex32 );\n\t\tif ( intersectRay( leftIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( leftIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t\tconst rightIndex = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\tif ( intersectRay( rightIndex, float32Array, ray ) ) {\n\n\t\t\t_raycast( rightIndex, bvh, side, ray, intersects );\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycast_indirect };\n","import { IS_LEAF, OFFSET, COUNT, SPLIT_AXIS, LEFT_NODE, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { intersectRay } from '../utils/intersectUtils.js';\nimport '../utils/iterationUtils.generated.js';\nimport { intersectClosestTri_indirect } from '../utils/iterationUtils_indirect.generated.js';\n\n/***********************************************************/\n/* This file is generated from \"raycastFirst.template.js\". */\n/***********************************************************/\n\nconst _xyzFields = [ 'x', 'y', 'z' ];\n\nfunction raycastFirst_indirect( bvh, root, side, ray ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _raycastFirst( 0, bvh, side, ray );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _raycastFirst( nodeIndex32, bvh, side, ray ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\treturn intersectClosestTri_indirect( bvh, side, ray, offset, count );\n\n\n\t} else {\n\n\t\t// consider the position of the split plane with respect to the oncoming ray; whichever direction\n\t\t// the ray is coming from, look for an intersection among that side of the tree first\n\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\t\tconst xyzAxis = _xyzFields[ splitAxis ];\n\t\tconst rayDir = ray.direction[ xyzAxis ];\n\t\tconst leftToRight = rayDir >= 0;\n\n\t\t// c1 is the child to check first\n\t\tlet c1, c2;\n\t\tif ( leftToRight ) {\n\n\t\t\tc1 = LEFT_NODE( nodeIndex32 );\n\t\t\tc2 = RIGHT_NODE( nodeIndex32, uint32Array );\n\n\t\t} else {\n\n\t\t\tc1 = RIGHT_NODE( nodeIndex32, uint32Array );\n\t\t\tc2 = LEFT_NODE( nodeIndex32 );\n\n\t\t}\n\n\t\tconst c1Intersection = intersectRay( c1, float32Array, ray );\n\t\tconst c1Result = c1Intersection ? _raycastFirst( c1, bvh, side, ray ) : null;\n\n\t\t// if we got an intersection in the first node and it's closer than the second node's bounding\n\t\t// box, we don't need to consider the second node because it couldn't possibly be a better result\n\t\tif ( c1Result ) {\n\n\t\t\t// check if the point is within the second bounds\n\t\t\t// \"point\" is in the local frame of the bvh\n\t\t\tconst point = c1Result.point[ xyzAxis ];\n\t\t\tconst isOutside = leftToRight ?\n\t\t\t\tpoint <= float32Array[ c2 + splitAxis ] : // min bounding data\n\t\t\t\tpoint >= float32Array[ c2 + splitAxis + 3 ]; // max bounding data\n\n\t\t\tif ( isOutside ) {\n\n\t\t\t\treturn c1Result;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// either there was no intersection in the first node, or there could still be a closer\n\t\t// intersection in the second, so check the second node and then take the better of the two\n\t\tconst c2Intersection = intersectRay( c2, float32Array, ray );\n\t\tconst c2Result = c2Intersection ? _raycastFirst( c2, bvh, side, ray ) : null;\n\n\t\tif ( c1Result && c2Result ) {\n\n\t\t\treturn c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n\n\t\t} else {\n\n\t\t\treturn c1Result || c2Result || null;\n\n\t\t}\n\n\t}\n\n}\n\nexport { raycastFirst_indirect };\n","import { Box3, Matrix4 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../../math/ExtendedTriangle.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { IS_LEAF, OFFSET, COUNT, BOUNDING_DATA_INDEX } from '../utils/nodeBufferUtils.js';\nimport { BufferStack } from '../utils/BufferStack.js';\n\n/*****************************************************************/\n/* This file is generated from \"intersectsGeometry.template.js\". */\n/*****************************************************************/\n/* eslint-disable indent */\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst triangle = /* @__PURE__ */ new ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new Matrix4();\n\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\n\nfunction intersectsGeometry_indirect( bvh, root, otherGeometry, geometryToBvh ) {\n\n\tBufferStack.setBuffer( bvh._roots[ root ] );\n\tconst result = _intersectsGeometry( 0, bvh, otherGeometry, geometryToBvh );\n\tBufferStack.clearBuffer();\n\n\treturn result;\n\n}\n\nfunction _intersectsGeometry( nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null ) {\n\n\tconst { float32Array, uint16Array, uint32Array } = BufferStack;\n\tlet nodeIndex16 = nodeIndex32 * 2;\n\n\tif ( cachedObb === null ) {\n\n\t\tif ( ! otherGeometry.boundingBox ) {\n\n\t\t\totherGeometry.computeBoundingBox();\n\n\t\t}\n\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\t\tcachedObb = obb;\n\n\t}\n\n\tconst isLeaf = IS_LEAF( nodeIndex16, uint16Array );\n\tif ( isLeaf ) {\n\n\t\tconst thisGeometry = bvh.geometry;\n\t\tconst thisIndex = thisGeometry.index;\n\t\tconst thisPos = thisGeometry.attributes.position;\n\n\t\tconst index = otherGeometry.index;\n\t\tconst pos = otherGeometry.attributes.position;\n\n\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\n\t\t// get the inverse of the geometry matrix so we can transform our triangles into the\n\t\t// geometry space we're trying to test. We assume there are fewer triangles being checked\n\t\t// here.\n\t\tinvertedMat.copy( geometryToBvh ).invert();\n\n\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t// if there's a bounds tree\n\t\t\tarrayToBox( BOUNDING_DATA_INDEX( nodeIndex32 ), float32Array, obb2 );\n\t\t\tobb2.matrix.copy( invertedMat );\n\t\t\tobb2.needsUpdate = true;\n\n\t\t\t// TODO: use a triangle iteration function here\n\t\t\tconst res = otherGeometry.boundsTree.shapecast( {\n\n\t\t\t\tintersectsBounds: box => obb2.intersectsBox( box ),\n\n\t\t\t\tintersectsTriangle: tri => {\n\n\t\t\t\t\ttri.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\ttri.needsUpdate = true;\n\n\t\t\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * bvh.resolveTriangleIndex( i ), thisIndex, thisPos );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\t\t\t\t\t\tif ( tri.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn res;\n\n\t\t} else {\n\n\t\t\t// if we're just dealing with raw geometry\n\t\t\tfor ( let i = offset, l = count + offset; i < l; i ++ ) {\n\n\t\t\t\t// this triangle needs to be transformed into the current BVH coordinate frame\n\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\tsetTriangle( triangle, 3 * ti, thisIndex, thisPos );\n\n\n\t\t\t\ttriangle.a.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.b.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.c.applyMatrix4( invertedMat );\n\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\tfor ( let i2 = 0, l2 = index.count; i2 < l2; i2 += 3 ) {\n\n\t\t\t\t\tsetTriangle( triangle2, i2, index, pos );\n\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\tif ( triangle.intersectsTriangle( triangle2 ) ) {\n\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t}\n\n\t} else {\n\n\t\tconst left = nodeIndex32 + 8;\n\t\tconst right = uint32Array[ nodeIndex32 + 6 ];\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( left ), float32Array, boundingBox );\n\t\tconst leftIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( left, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( leftIntersection ) return true;\n\n\t\tarrayToBox( BOUNDING_DATA_INDEX( right ), float32Array, boundingBox );\n\t\tconst rightIntersection =\n\t\t\tcachedObb.intersectsBox( boundingBox ) &&\n\t\t\t_intersectsGeometry( right, bvh, otherGeometry, geometryToBvh, cachedObb );\n\n\t\tif ( rightIntersection ) return true;\n\n\t\treturn false;\n\n\t}\n\n}\n\nexport { intersectsGeometry_indirect };\n","import { Matrix4, Vector3 } from 'three';\nimport { OrientedBox } from '../../math/OrientedBox.js';\nimport { setTriangle } from '../../utils/TriangleUtilities.js';\nimport { getTriCount } from '../build/geometryUtils.js';\nimport { ExtendedTrianglePool } from '../../utils/ExtendedTrianglePool.js';\n\n/*********************************************************************/\n/* This file is generated from \"closestPointToGeometry.template.js\". */\n/*********************************************************************/\n\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\nconst obb = /* @__PURE__ */ new OrientedBox();\nconst obb2 = /* @__PURE__ */ new OrientedBox();\nconst temp1 = /* @__PURE__ */ new Vector3();\nconst temp2 = /* @__PURE__ */ new Vector3();\nconst temp3 = /* @__PURE__ */ new Vector3();\nconst temp4 = /* @__PURE__ */ new Vector3();\n\nfunction closestPointToGeometry_indirect(\n\tbvh,\n\totherGeometry,\n\tgeometryToBvh,\n\ttarget1 = { },\n\ttarget2 = { },\n\tminThreshold = 0,\n\tmaxThreshold = Infinity,\n) {\n\n\tif ( ! otherGeometry.boundingBox ) {\n\n\t\totherGeometry.computeBoundingBox();\n\n\t}\n\n\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\n\tobb.needsUpdate = true;\n\n\tconst geometry = bvh.geometry;\n\tconst pos = geometry.attributes.position;\n\tconst index = geometry.index;\n\tconst otherPos = otherGeometry.attributes.position;\n\tconst otherIndex = otherGeometry.index;\n\tconst triangle = ExtendedTrianglePool.getPrimitive();\n\tconst triangle2 = ExtendedTrianglePool.getPrimitive();\n\n\tlet tempTarget1 = temp1;\n\tlet tempTargetDest1 = temp2;\n\tlet tempTarget2 = null;\n\tlet tempTargetDest2 = null;\n\n\tif ( target2 ) {\n\n\t\ttempTarget2 = temp3;\n\t\ttempTargetDest2 = temp4;\n\n\t}\n\n\tlet closestDistance = Infinity;\n\tlet closestDistanceTriIndex = null;\n\tlet closestDistanceOtherTriIndex = null;\n\ttempMatrix.copy( geometryToBvh ).invert();\n\tobb2.matrix.copy( tempMatrix );\n\tbvh.shapecast(\n\t\t{\n\n\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\treturn obb.distanceToBox( box );\n\n\t\t\t},\n\n\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\n\n\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\n\t\t\t\t\t// save the bounds to use during triangle checks.\n\t\t\t\t\tif ( isLeaf ) {\n\n\t\t\t\t\t\tobb2.min.copy( box.min );\n\t\t\t\t\t\tobb2.max.copy( box.max );\n\t\t\t\t\t\tobb2.needsUpdate = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn true;\n\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\n\t\t\t},\n\n\t\t\tintersectsRange: ( offset, count ) => {\n\n\t\t\t\tif ( otherGeometry.boundsTree ) {\n\n\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n\t\t\t\t\t// the closest bounds in the other geometry to check.\n\t\t\t\t\tconst otherBvh = otherGeometry.boundsTree;\n\t\t\t\t\treturn otherBvh.shapecast( {\n\t\t\t\t\t\tboundsTraverseOrder: box => {\n\n\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\n\n\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\n\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\n\n\t\t\t\t\t\t\tfor ( let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\t\t\tconst ti2 = otherBvh.resolveTriangleIndex( i2 );\n\t\t\t\t\t\t\t\tsetTriangle( triangle2, 3 * ti2, otherIndex, otherPos );\n\n\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t},\n\t\t\t\t\t} );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\n\t\t\t\t\tconst triCount = getTriCount( otherGeometry );\n\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 ++ ) {\n\n\t\t\t\t\t\tsetTriangle( triangle2, 3 * i2, otherIndex, otherPos );\n\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\n\t\t\t\t\t\ttriangle2.needsUpdate = true;\n\n\t\t\t\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tconst ti = bvh.resolveTriangleIndex( i );\n\t\t\t\t\t\t\tsetTriangle( triangle, 3 * ti, index, pos );\n\n\t\t\t\t\t\t\ttriangle.needsUpdate = true;\n\n\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\n\t\t\t\t\t\t\tif ( dist < closestDistance ) {\n\n\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\n\n\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\n\n\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tclosestDistance = dist;\n\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i;\n\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\n\t\t\t\t\t\t\tif ( dist < minThreshold ) {\n\n\t\t\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t}\n\n\t);\n\n\tExtendedTrianglePool.releasePrimitive( triangle );\n\tExtendedTrianglePool.releasePrimitive( triangle2 );\n\n\tif ( closestDistance === Infinity ) {\n\n\t\treturn null;\n\n\t}\n\n\tif ( ! target1.point ) {\n\n\t\ttarget1.point = tempTargetDest1.clone();\n\n\t} else {\n\n\t\ttarget1.point.copy( tempTargetDest1 );\n\n\t}\n\n\ttarget1.distance = closestDistance,\n\ttarget1.faceIndex = closestDistanceTriIndex;\n\n\tif ( target2 ) {\n\n\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\n\t\telse target2.point.copy( tempTargetDest2 );\n\t\ttarget2.point.applyMatrix4( tempMatrix );\n\t\ttempTargetDest1.applyMatrix4( tempMatrix );\n\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\n\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\n\n\t}\n\n\treturn target1;\n\n}\n\nexport { closestPointToGeometry_indirect };\n","export function isSharedArrayBufferSupported() {\n\n\treturn typeof SharedArrayBuffer !== 'undefined';\n\n}\n\nexport function convertToBufferType( array, BufferConstructor ) {\n\n\tif ( array === null ) {\n\n\t\treturn array;\n\n\t} else if ( array.buffer ) {\n\n\t\tconst buffer = array.buffer;\n\t\tif ( buffer.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst ArrayConstructor = array.constructor;\n\t\tconst result = new ArrayConstructor( new BufferConstructor( buffer.byteLength ) );\n\t\tresult.set( array );\n\t\treturn result;\n\n\t} else {\n\n\t\tif ( array.constructor === BufferConstructor ) {\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tconst result = new BufferConstructor( array.byteLength );\n\t\tnew Uint8Array( result ).set( new Uint8Array( array ) );\n\t\treturn result;\n\n\t}\n\n}\n","import { Box3, Matrix4 } from 'three';\nimport { BufferStack } from '../utils/BufferStack.js';\nimport { BOUNDING_DATA_INDEX, COUNT, IS_LEAF, LEFT_NODE, OFFSET, RIGHT_NODE } from '../utils/nodeBufferUtils.js';\nimport { arrayToBox } from '../../utils/ArrayBoxUtilities.js';\nimport { PrimitivePool } from '../../utils/PrimitivePool.js';\n\nconst _bufferStack1 = new BufferStack.constructor();\nconst _bufferStack2 = new BufferStack.constructor();\nconst _boxPool = new PrimitivePool( () => new Box3() );\nconst _leftBox1 = new Box3();\nconst _rightBox1 = new Box3();\n\nconst _leftBox2 = new Box3();\nconst _rightBox2 = new Box3();\n\nlet _active = false;\n\nexport function bvhcast( bvh, otherBvh, matrixToLocal, intersectsRanges ) {\n\n\tif ( _active ) {\n\n\t\tthrow new Error( 'MeshBVH: Recursive calls to bvhcast not supported.' );\n\n\t}\n\n\t_active = true;\n\n\tconst roots = bvh._roots;\n\tconst otherRoots = otherBvh._roots;\n\tlet result;\n\tlet offset1 = 0;\n\tlet offset2 = 0;\n\tconst invMat = new Matrix4().copy( matrixToLocal ).invert();\n\n\t// iterate over the first set of roots\n\tfor ( let i = 0, il = roots.length; i < il; i ++ ) {\n\n\t\t_bufferStack1.setBuffer( roots[ i ] );\n\t\toffset2 = 0;\n\n\t\t// prep the initial root box\n\t\tconst localBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( 0 ), _bufferStack1.float32Array, localBox );\n\t\tlocalBox.applyMatrix4( invMat );\n\n\t\t// iterate over the second set of roots\n\t\tfor ( let j = 0, jl = otherRoots.length; j < jl; j ++ ) {\n\n\t\t\t_bufferStack2.setBuffer( otherRoots[ i ] );\n\n\t\t\tresult = _traverse(\n\t\t\t\t0, 0, matrixToLocal, invMat, intersectsRanges,\n\t\t\t\toffset1, offset2, 0, 0,\n\t\t\t\tlocalBox,\n\t\t\t);\n\n\t\t\t_bufferStack2.clearBuffer();\n\t\t\toffset2 += otherRoots[ j ].length;\n\n\t\t\tif ( result ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// release stack info\n\t\t_boxPool.releasePrimitive( localBox );\n\t\t_bufferStack1.clearBuffer();\n\t\toffset1 += roots[ i ].length;\n\n\t\tif ( result ) {\n\n\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\t_active = false;\n\treturn result;\n\n}\n\nfunction _traverse(\n\tnode1Index32,\n\tnode2Index32,\n\tmatrix2to1,\n\tmatrix1to2,\n\tintersectsRangesFunc,\n\n\t// offsets for ids\n\tnode1IndexByteOffset = 0,\n\tnode2IndexByteOffset = 0,\n\n\t// tree depth\n\tdepth1 = 0,\n\tdepth2 = 0,\n\n\tcurrBox = null,\n\treversed = false,\n\n) {\n\n\t// get the buffer stacks associated with the current indices\n\tlet bufferStack1, bufferStack2;\n\tif ( reversed ) {\n\n\t\tbufferStack1 = _bufferStack2;\n\t\tbufferStack2 = _bufferStack1;\n\n\t} else {\n\n\t\tbufferStack1 = _bufferStack1;\n\t\tbufferStack2 = _bufferStack2;\n\n\t}\n\n\t// get the local instances of the typed buffers\n\tconst\n\t\tfloat32Array1 = bufferStack1.float32Array,\n\t\tuint32Array1 = bufferStack1.uint32Array,\n\t\tuint16Array1 = bufferStack1.uint16Array,\n\t\tfloat32Array2 = bufferStack2.float32Array,\n\t\tuint32Array2 = bufferStack2.uint32Array,\n\t\tuint16Array2 = bufferStack2.uint16Array;\n\n\tconst node1Index16 = node1Index32 * 2;\n\tconst node2Index16 = node2Index32 * 2;\n\tconst isLeaf1 = IS_LEAF( node1Index16, uint16Array1 );\n\tconst isLeaf2 = IS_LEAF( node2Index16, uint16Array2 );\n\tlet result = false;\n\tif ( isLeaf2 && isLeaf1 ) {\n\n\t\t// if both bounds are leaf nodes then fire the callback if the boxes intersect\n\t\tif ( reversed ) {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tresult = intersectsRangesFunc(\n\t\t\t\tOFFSET( node1Index32, uint32Array1 ), COUNT( node1Index32 * 2, uint16Array1 ),\n\t\t\t\tOFFSET( node2Index32, uint32Array2 ), COUNT( node2Index32 * 2, uint16Array2 ),\n\t\t\t\tdepth1, node1IndexByteOffset + node1Index32,\n\t\t\t\tdepth2, node2IndexByteOffset + node2Index32,\n\t\t\t);\n\n\t\t}\n\n\t} else if ( isLeaf2 ) {\n\n\t\t// SWAP\n\t\t// If we've traversed to the leaf node on the other bvh then we need to swap over\n\t\t// to traverse down the first one\n\n\t\t// get the new box to use\n\t\tconst newBox = _boxPool.getPrimitive();\n\t\tarrayToBox( BOUNDING_DATA_INDEX( node2Index32 ), float32Array2, newBox );\n\t\tnewBox.applyMatrix4( matrix2to1 );\n\n\t\t// get the child bounds to check before traversal\n\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\tresult = (\n\t\t\tintersectCl1 && _traverse(\n\t\t\t\tnode2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t) || (\n\t\t\tintersectCr1 && _traverse(\n\t\t\t\tnode2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\tnewBox, ! reversed,\n\t\t\t)\n\t\t);\n\n\t\t_boxPool.releasePrimitive( newBox );\n\n\t} else {\n\n\t\t// if neither are leaves then we should swap if one of the children does not\n\t\t// intersect with the current bounds\n\n\t\t// get the child bounds to check\n\t\tconst cl2 = LEFT_NODE( node2Index32 );\n\t\tconst cr2 = RIGHT_NODE( node2Index32, uint32Array2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cl2 ), float32Array2, _leftBox2 );\n\t\tarrayToBox( BOUNDING_DATA_INDEX( cr2 ), float32Array2, _rightBox2 );\n\n\t\tconst leftIntersects = currBox.intersectsBox( _leftBox2 );\n\t\tconst rightIntersects = currBox.intersectsBox( _rightBox2 );\n\t\tif ( leftIntersects && rightIntersects ) {\n\n\t\t\t// continue to traverse both children if they both intersect\n\t\t\tresult = _traverse(\n\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t) || _traverse(\n\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\tcurrBox, reversed,\n\t\t\t);\n\n\t\t} else if ( leftIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _leftBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t} else if ( rightIntersects ) {\n\n\t\t\tif ( isLeaf1 ) {\n\n\t\t\t\t// if the current box is a leaf then just continue\n\t\t\t\tresult = _traverse(\n\t\t\t\t\tnode1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc,\n\t\t\t\t\tnode1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1,\n\t\t\t\t\tcurrBox, reversed,\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\t// SWAP\n\t\t\t\t// if only one box intersects then we have to swap to the other bvh to continue\n\t\t\t\tconst newBox = _boxPool.getPrimitive();\n\t\t\t\tnewBox.copy( _rightBox2 ).applyMatrix4( matrix2to1 );\n\n\t\t\t\tconst cl1 = LEFT_NODE( node1Index32 );\n\t\t\t\tconst cr1 = RIGHT_NODE( node1Index32, uint32Array1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cl1 ), float32Array1, _leftBox1 );\n\t\t\t\tarrayToBox( BOUNDING_DATA_INDEX( cr1 ), float32Array1, _rightBox1 );\n\n\t\t\t\t// precompute the intersections otherwise the global boxes will be modified during traversal\n\t\t\t\tconst intersectCl1 = newBox.intersectsBox( _leftBox1 );\n\t\t\t\tconst intersectCr1 = newBox.intersectsBox( _rightBox1 );\n\t\t\t\tresult = (\n\t\t\t\t\tintersectCl1 && _traverse(\n\t\t\t\t\t\tcr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t) || (\n\t\t\t\t\tintersectCr1 && _traverse(\n\t\t\t\t\t\tcr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc,\n\t\t\t\t\t\tnode2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1,\n\t\t\t\t\t\tnewBox, ! reversed,\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\t_boxPool.releasePrimitive( newBox );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn result;\n\n}\n\n","import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tRIGHT_NODE,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\t\tthis._cachedIndexAttr = null;\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t// dereference a new index attribute if we're using indirect storage\n\t\tif ( bvh.indirect ) {\n\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tif (\n\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t) {\n\n\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t} else {\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\tconst unpacked = target.array;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t}\n\n\t}\n\n}\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n","export * from './glsl/common_functions.glsl.js';\nexport * from './glsl/bvh_distance_functions.glsl.js';\nexport * from './glsl/bvh_ray_functions.glsl.js';\nexport * from './glsl/bvh_struct_definitions.glsl.js';\n","export const common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n","// Distance to Point\nexport const bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = pow( 100000.0, 2.0 );\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n","export const bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n","// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n","import { BufferAttribute, BufferGeometry, Mesh, MeshBasicMaterial } from 'three';\r\nimport { mergeGeometries } from './mergeGeometries.js';\r\nimport { setCommonAttributes } from './GeometryPreparationUtils.js';\r\nimport { BakedGeometry } from './BakedGeometry.js';\r\n\r\nexport const NO_CHANGE = 0;\r\nexport const GEOMETRY_ADJUSTED = 1;\r\nexport const GEOMETRY_REBUILT = 2;\r\n\r\n// iterate over only the meshes in the provided objects\r\nfunction flatTraverseMeshes( objects, cb ) {\r\n\r\n\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\tconst object = objects[ i ];\r\n\t\tobject.traverseVisible( o => {\r\n\r\n\t\t\tif ( o.isMesh ) {\r\n\r\n\t\t\t\tcb( o );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// return the set of materials used by the provided meshes\r\nfunction getMaterials( meshes ) {\r\n\r\n\tconst materials = [];\r\n\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\tconst mesh = meshes[ i ];\r\n\t\tif ( Array.isArray( mesh.material ) ) {\r\n\r\n\t\t\tmaterials.push( ...mesh.material );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmaterials.push( mesh.material );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn materials;\r\n\r\n}\r\n\r\nfunction mergeGeometryList( geometries, target, options ) {\r\n\r\n\t// If we have no geometry to merge then provide an empty geometry.\r\n\tif ( geometries.length === 0 ) {\r\n\r\n\t\t// if there are no geometries then just create a fake empty geometry to provide\r\n\t\ttarget.setIndex( null );\r\n\r\n\t\t// remove all geometry\r\n\t\tconst attrs = target.attributes;\r\n\t\tfor ( const key in attrs ) {\r\n\r\n\t\t\ttarget.deleteAttribute( key );\r\n\r\n\t\t}\r\n\r\n\t\t// create dummy attributes\r\n\t\tfor ( const key in options.attributes ) {\r\n\r\n\t\t\ttarget.setAttribute( options.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tmergeGeometries( geometries, options, target );\r\n\r\n\t}\r\n\r\n\t// Mark all attributes as needing an update\r\n\tfor ( const key in target.attributes ) {\r\n\r\n\t\ttarget.attributes[ key ].needsUpdate = true;\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport class StaticGeometryGenerator {\r\n\r\n\tconstructor( objects ) {\r\n\r\n\t\tthis.objects = null;\r\n\t\tthis.useGroups = true;\r\n\t\tthis.applyWorldTransforms = true;\r\n\t\tthis.generateMissingAttributes = true;\r\n\t\tthis.overwriteIndex = true;\r\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\r\n\t\tthis._intermediateGeometry = new Map();\r\n\t\tthis._geometryMergeSets = new WeakMap();\r\n\t\tthis._mergeOrder = [];\r\n\t\tthis._dummyMesh = null;\r\n\r\n\t\tthis.setObjects( objects || [] );\r\n\r\n\t}\r\n\r\n\t_getDummyMesh() {\r\n\r\n\t\t// return a consistent dummy mesh\r\n\t\tif ( ! this._dummyMesh ) {\r\n\r\n\t\t\tconst dummyMaterial = new MeshBasicMaterial();\r\n\t\t\tconst emptyGeometry = new BufferGeometry();\r\n\t\t\temptyGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( 9 ), 3 ) );\r\n\t\t\tthis._dummyMesh = new Mesh( emptyGeometry, dummyMaterial );\r\n\r\n\t\t}\r\n\r\n\t\treturn this._dummyMesh;\r\n\r\n\t}\r\n\r\n\t_getMeshes() {\r\n\r\n\t\t// iterate over only the meshes in the provided objects\r\n\t\tconst meshes = [];\r\n\t\tflatTraverseMeshes( this.objects, mesh => {\r\n\r\n\t\t\tmeshes.push( mesh );\r\n\r\n\t\t} );\r\n\r\n\t\t// Sort the geometry so it's in a reliable order\r\n\t\tmeshes.sort( ( a, b ) => {\r\n\r\n\t\t\tif ( a.uuid > b.uuid ) return 1;\r\n\t\t\tif ( a.uuid < b.uuid ) return - 1;\r\n\t\t\treturn 0;\r\n\r\n\t\t} );\r\n\r\n\t\tif ( meshes.length === 0 ) {\r\n\r\n\t\t\tmeshes.push( this._getDummyMesh() );\r\n\r\n\t\t}\r\n\r\n\t\treturn meshes;\r\n\r\n\t}\r\n\r\n\t_updateIntermediateGeometries() {\r\n\r\n\t\tconst { _intermediateGeometry } = this;\r\n\r\n\t\tconst meshes = this._getMeshes();\r\n\t\tconst unusedMeshKeys = new Set( _intermediateGeometry.keys() );\r\n\t\tconst convertOptions = {\r\n\t\t\tattributes: this.attributes,\r\n\t\t\tapplyWorldTransforms: this.applyWorldTransforms,\r\n\t\t};\r\n\r\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst mesh = meshes[ i ];\r\n\t\t\tconst meshKey = mesh.uuid;\r\n\t\t\tunusedMeshKeys.delete( meshKey );\r\n\r\n\t\t\t// initialize the intermediate geometry\r\n\t\t\t// if the mesh and source geometry have changed in such a way that they are no longer\r\n\t\t\t// compatible then regenerate the baked geometry from scratch\r\n\t\t\tlet geom = _intermediateGeometry.get( meshKey );\r\n\t\t\tif ( ! geom || ! geom.isCompatible( mesh, this.attributes ) ) {\r\n\r\n\t\t\t\tif ( geom ) {\r\n\r\n\t\t\t\t\tgeom.dispose();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeom = new BakedGeometry();\r\n\t\t\t\t_intermediateGeometry.set( meshKey, geom );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// transform the geometry into the intermediate buffer geometry, saving whether\r\n\t\t\t// or not it changed.\r\n\t\t\tif ( geom.updateFrom( mesh, convertOptions ) ) {\r\n\r\n\t\t\t\t// TODO: provide option for only generating the set of attributes that are present\r\n\t\t\t\t// and are in the attributes array\r\n\t\t\t\tif ( this.generateMissingAttributes ) {\r\n\r\n\t\t\t\t\tsetCommonAttributes( geom, this.attributes );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tunusedMeshKeys.forEach( key => {\r\n\r\n\t\t\t_intermediateGeometry.delete( key );\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tsetObjects( objects ) {\r\n\r\n\t\tif ( Array.isArray( objects ) ) {\r\n\r\n\t\t\tthis.objects = [ ...objects ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.objects = [ objects ];\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgenerate( targetGeometry = new BufferGeometry() ) {\r\n\r\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\r\n\t\tconst { useGroups, overwriteIndex, _intermediateGeometry, _geometryMergeSets } = this;\r\n\r\n\t\tconst meshes = this._getMeshes();\r\n\t\tconst skipAssigningAttributes = [];\r\n\t\tconst mergeGeometry = [];\r\n\t\tconst previousMergeInfo = _geometryMergeSets.get( targetGeometry ) || [];\r\n\r\n\t\t// update all the intermediate static geometry representations\r\n\t\tthis._updateIntermediateGeometries();\r\n\r\n\t\t// get the list of geometries to merge\r\n\t\tlet forceUpdate = false;\r\n\t\tif ( meshes.length !== previousMergeInfo.length ) {\r\n\r\n\t\t\tforceUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst mesh = meshes[ i ];\r\n\t\t\tconst geom = _intermediateGeometry.get( mesh.uuid );\r\n\t\t\tmergeGeometry.push( geom );\r\n\r\n\t\t\tconst info = previousMergeInfo[ i ];\r\n\t\t\tif ( ! info || info.uuid !== geom.uuid ) {\r\n\r\n\t\t\t\tskipAssigningAttributes.push( false );\r\n\t\t\t\tforceUpdate = true;\r\n\r\n\t\t\t} else if ( info.version !== geom.version ) {\r\n\r\n\t\t\t\tskipAssigningAttributes.push( false );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tskipAssigningAttributes.push( true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// If we have no geometry to merge then provide an empty geometry.\r\n\t\tmergeGeometryList( mergeGeometry, targetGeometry, { useGroups, forceUpdate, skipAssigningAttributes, overwriteIndex } );\r\n\r\n\t\t// force update means the attribute buffer lengths have changed\r\n\t\tif ( forceUpdate ) {\r\n\r\n\t\t\ttargetGeometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t\t_geometryMergeSets.set( targetGeometry, mergeGeometry.map( g => ( {\r\n\t\t\tversion: g.version,\r\n\t\t\tuuid: g.uuid,\r\n\t\t} ) ) );\r\n\r\n\t\tlet changeType = NO_CHANGE;\r\n\t\tif ( forceUpdate ) changeType = GEOMETRY_REBUILT;\r\n\t\telse if ( skipAssigningAttributes.includes( false ) ) changeType = GEOMETRY_ADJUSTED;\r\n\r\n\t\treturn {\r\n\t\t\tchangeType,\r\n\t\t\tmaterials: getMaterials( meshes ),\r\n\t\t\tgeometry: targetGeometry,\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferAttribute, BufferGeometry } from 'three';\r\nimport { copyAttributeContents, createAttributeClone } from './BufferAttributeUtils.js';\r\n\r\nfunction validateMergeability( geometries ) {\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\r\n\tif ( ! geometries[ 0 ].getAttribute( 'position' ) ) {\r\n\r\n\t\tthrow new Error( 'StaticGeometryGenerator: position attribute is required.' );\r\n\r\n\t}\r\n\r\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\r\n\r\n\t\tconst geometry = geometries[ i ];\r\n\t\tlet attributesCount = 0;\r\n\r\n\t\t// ensure that all geometries are indexed, or none\r\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t}\r\n\r\n\t\t// gather attributes, exit early if they're different\r\n\t\tfor ( const name in geometry.attributes ) {\r\n\r\n\t\t\tif ( ! attributesUsed.has( name ) ) {\r\n\r\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tattributesCount ++;\r\n\r\n\t\t}\r\n\r\n\t\t// ensure geometries have the same number of attributes\r\n\t\tif ( attributesCount !== attributesUsed.size ) {\r\n\r\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have the same number of attributes.' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nfunction getTotalIndexCount( geometries ) {\r\n\r\n\tlet result = 0;\r\n\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\tresult += geometries[ i ].getIndex().count;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction getTotalAttributeCount( geometries ) {\r\n\r\n\tlet result = 0;\r\n\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\tresult += geometries[ i ].getAttribute( 'position' ).count;\r\n\r\n\t}\r\n\r\n\treturn result;\r\n\r\n}\r\n\r\nfunction trimMismatchedAttributes( target, indexCount, attrCount ) {\r\n\r\n\tif ( target.index && target.index.count !== indexCount ) {\r\n\r\n\t\ttarget.setIndex( null );\r\n\r\n\t}\r\n\r\n\tconst attributes = target.attributes;\r\n\tfor ( const key in attributes ) {\r\n\r\n\t\tconst attr = attributes[ key ];\r\n\t\tif ( attr.count !== attrCount ) {\r\n\r\n\t\t\ttarget.deleteAttribute( key );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\r\nexport function mergeGeometries( geometries, options = {}, targetGeometry = new BufferGeometry() ) {\r\n\r\n\tconst {\r\n\t\tuseGroups = false,\r\n\t\tforceUpdate = false,\r\n\t\tskipAssigningAttributes = [],\r\n\t\toverwriteIndex = true,\r\n\t} = options;\r\n\r\n\t// check if we can merge these geometries\r\n\tvalidateMergeability( geometries );\r\n\r\n\tconst isIndexed = geometries[ 0 ].index !== null;\r\n\tconst totalIndexCount = isIndexed ? getTotalIndexCount( geometries ) : - 1;\r\n\tconst totalAttributeCount = getTotalAttributeCount( geometries );\r\n\ttrimMismatchedAttributes( targetGeometry, totalIndexCount, totalAttributeCount );\r\n\r\n\t// set up groups\r\n\tif ( useGroups ) {\r\n\r\n\t\tlet offset = 0;\r\n\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst geometry = geometries[ i ];\r\n\r\n\t\t\tlet primitiveCount;\r\n\t\t\tif ( isIndexed ) {\r\n\r\n\t\t\t\tprimitiveCount = geometry.getIndex().count;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tprimitiveCount = geometry.getAttribute( 'position' ).count;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetGeometry.addGroup( offset, primitiveCount, i );\r\n\t\t\toffset += primitiveCount;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate the final geometry\r\n\t// skip the assigning any attributes for items in the above array\r\n\tif ( isIndexed ) {\r\n\r\n\t\t// set up the index if it doesn't exist\r\n\t\tlet forceUpdateIndex = false;\r\n\t\tif ( ! targetGeometry.index ) {\r\n\r\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( totalIndexCount ), 1, false ) );\r\n\t\t\tforceUpdateIndex = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( forceUpdateIndex || overwriteIndex ) {\r\n\r\n\t\t\t// copy the index data to the target geometry\r\n\t\t\tlet targetOffset = 0;\r\n\t\t\tlet indexOffset = 0;\r\n\t\t\tconst targetIndex = targetGeometry.getIndex();\r\n\t\t\tfor ( let i = 0, l = geometries.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tconst geometry = geometries[ i ];\r\n\t\t\t\tconst index = geometry.getIndex();\r\n\t\t\t\tconst skip = ! forceUpdate && ! forceUpdateIndex && skipAssigningAttributes[ i ];\r\n\t\t\t\tif ( ! skip ) {\r\n\r\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\r\n\r\n\t\t\t\t\t\ttargetIndex.setX( targetOffset + j, index.getX( j ) + indexOffset );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetOffset += index.count;\r\n\t\t\t\tindexOffset += geometry.getAttribute( 'position' ).count;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// copy all the attribute data over\r\n\tconst attributes = Object.keys( geometries[ 0 ].attributes );\r\n\tfor ( let i = 0, l = attributes.length; i < l; i ++ ) {\r\n\r\n\t\tlet forceUpdateAttr = false;\r\n\t\tconst key = attributes[ i ];\r\n\t\tif ( ! targetGeometry.getAttribute( key ) ) {\r\n\r\n\t\t\tconst firstAttr = geometries[ 0 ].getAttribute( key );\r\n\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( firstAttr, totalAttributeCount ) );\r\n\t\t\tforceUpdateAttr = true;\r\n\r\n\t\t}\r\n\r\n\t\tlet offset = 0;\r\n\t\tconst targetAttribute = targetGeometry.getAttribute( key );\r\n\t\tfor ( let g = 0, l = geometries.length; g < l; g ++ ) {\r\n\r\n\t\t\tconst geometry = geometries[ g ];\r\n\t\t\tconst skip = ! forceUpdate && ! forceUpdateAttr && skipAssigningAttributes[ g ];\r\n\t\t\tconst attr = geometry.getAttribute( key );\r\n \t\t\tif ( ! skip ) {\r\n\r\n\t\t\t\tif ( key === 'color' && targetAttribute.itemSize !== attr.itemSize ) {\r\n\r\n\t\t\t\t\t// make sure the color attribute is aligned with itemSize 3 to 4\r\n\t\t\t\t\tfor ( let index = offset, l = attr.count; index < l; index ++ ) {\r\n\r\n\t\t\t\t\t\tattr.setXYZW( index, targetAttribute.getX( index ), targetAttribute.getY( index ), targetAttribute.getZ( index ), 1.0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset += attr.count;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferAttribute } from 'three';\r\n\r\n// target offset is the number of elements in the target buffer stride to skip before copying the\r\n// attributes contents in to.\r\nexport function copyAttributeContents( attr, target, targetOffset = 0 ) {\r\n\r\n\tif ( attr.isInterleavedBufferAttribute ) {\r\n\r\n\t\tconst itemSize = attr.itemSize;\r\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\r\n\r\n\t\t\tconst io = i + targetOffset;\r\n\t\t\ttarget.setX( io, attr.getX( i ) );\r\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\r\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\r\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tconst array = target.array;\r\n\t\tconst cons = array.constructor;\r\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\r\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\r\n\t\ttemp.set( attr.array );\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Clones the given attribute with a new compatible buffer attribute but no data\r\nexport function createAttributeClone( attr, countOverride = null ) {\r\n\r\n\tconst cons = attr.array.constructor;\r\n\tconst normalized = attr.normalized;\r\n\tconst itemSize = attr.itemSize;\r\n\tconst count = countOverride === null ? attr.count : countOverride;\r\n\r\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\r\n\r\n}\r\n\r\n// Confirms that the two provided attributes are compatible. Returns false if they are not.\r\nexport function validateAttributes( attr1, attr2 ) {\r\n\r\n\tif ( ! attr1 && ! attr2 ) {\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tif ( Boolean( attr1 ) !== Boolean( attr2 ) ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tconst sameCount = attr1.count === attr2.count;\r\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\r\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\r\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\r\n\r\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n","import { BufferAttribute } from 'three';\r\n\r\nexport function updateMaterialIndexAttribute( geometry, materials, allMaterials ) {\r\n\r\n\tconst indexAttr = geometry.index;\r\n\tconst posAttr = geometry.attributes.position;\r\n\tconst vertCount = posAttr.count;\r\n\tconst totalCount = indexAttr ? indexAttr.count : vertCount;\r\n\tlet groups = geometry.groups;\r\n\tif ( groups.length === 0 ) {\r\n\r\n\t\tgroups = [ { count: totalCount, start: 0, materialIndex: 0 } ];\r\n\r\n\t}\r\n\r\n\tlet materialIndexAttribute = geometry.getAttribute( 'materialIndex' );\r\n\tif ( ! materialIndexAttribute || materialIndexAttribute.count !== vertCount ) {\r\n\r\n\t\t// use an array with the minimum precision required to store all material id references.\r\n\t\tlet array;\r\n\t\tif ( allMaterials.length <= 255 ) {\r\n\r\n\t\t\tarray = new Uint8Array( vertCount );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray = new Uint16Array( vertCount );\r\n\r\n\t\t}\r\n\r\n\t\tmaterialIndexAttribute = new BufferAttribute( array, 1, false );\r\n\t\tgeometry.deleteAttribute( 'materialIndex' );\r\n\t\tgeometry.setAttribute( 'materialIndex', materialIndexAttribute );\r\n\r\n\t}\r\n\r\n\tconst materialArray = materialIndexAttribute.array;\r\n\tfor ( let i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\tconst group = groups[ i ];\r\n\t\tconst start = group.start;\r\n\t\tconst count = group.count;\r\n\t\tconst endCount = Math.min( count, totalCount - start );\r\n\r\n\t\tconst mat = Array.isArray( materials ) ? materials[ group.materialIndex ] : materials;\r\n\t\tconst materialIndex = allMaterials.indexOf( mat );\r\n\r\n\t\tfor ( let j = 0; j < endCount; j ++ ) {\r\n\r\n\t\t\tlet index = start + j;\r\n\t\t\tif ( indexAttr ) {\r\n\r\n\t\t\t\tindex = indexAttr.getX( index );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterialArray[ index ] = materialIndex;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport function setCommonAttributes( geometry, attributes ) {\r\n\r\n\tif ( ! geometry.index ) {\r\n\r\n\t\t// TODO: compute a typed array\r\n\t\tconst indexCount = geometry.attributes.position.count;\r\n\t\tconst array = new Array( indexCount );\r\n\t\tfor ( let i = 0; i < indexCount; i ++ ) {\r\n\r\n\t\t\tarray[ i ] = i;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.setIndex( array );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.normal && ( attributes && attributes.includes( 'normal' ) ) ) {\r\n\r\n\t\tgeometry.computeVertexNormals();\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.uv && ( attributes && attributes.includes( 'uv' ) ) ) {\r\n\r\n\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\tgeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.uv2 && ( attributes && attributes.includes( 'uv2' ) ) ) {\r\n\r\n\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\tgeometry.setAttribute( 'uv2', new BufferAttribute( new Float32Array( vertCount * 2 ), 2, false ) );\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.tangent && ( attributes && attributes.includes( 'tangent' ) ) ) {\r\n\r\n\t\t// compute tangents requires a uv and normal buffer\r\n\t\tif ( geometry.attributes.uv && geometry.attributes.normal ) {\r\n\r\n\t\t\tgeometry.computeTangents();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\t\tgeometry.setAttribute( 'tangent', new BufferAttribute( new Float32Array( vertCount * 4 ), 4, false ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tif ( ! geometry.attributes.color && ( attributes && attributes.includes( 'color' ) ) ) {\r\n\r\n\t\tconst vertCount = geometry.attributes.position.count;\r\n\t\tconst array = new Float32Array( vertCount * 4 );\r\n\t\tarray.fill( 1.0 );\r\n\t\tgeometry.setAttribute( 'color', new BufferAttribute( array, 4 ) );\r\n\r\n\t}\r\n\r\n}\r\n","import { BufferGeometry } from 'three';\r\nimport { MeshDiff } from './MeshDiff.js';\r\nimport { convertToStaticGeometry } from './convertToStaticGeometry.js';\r\nimport { validateAttributes } from './BufferAttributeUtils.js';\r\n\r\nexport class BakedGeometry extends BufferGeometry {\r\n\r\n\tconstructor() {\r\n\r\n\t\tsuper();\r\n\t\tthis.version = 0;\r\n\t\tthis.hash = null;\r\n\t\tthis._diff = new MeshDiff();\r\n\r\n\t}\r\n\r\n\t// returns whether the passed mesh is compatible with this baked geometry\r\n\t// such that it can be updated without resizing attributes\r\n\tisCompatible( mesh, attributes ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tfor ( let i = 0; i < attributes.length; i ++ ) {\r\n\r\n\t\t\tconst key = attributes[ i ];\r\n\t\t\tconst attr1 = geometry.attributes[ key ];\r\n\t\t\tconst attr2 = this.attributes[ key ];\r\n\t\t\tif ( attr1 && ! validateAttributes( attr1, attr2 ) ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tupdateFrom( mesh, options ) {\r\n\r\n\t\tconst diff = this._diff;\r\n\t\tif ( diff.didChange( mesh ) ) {\r\n\r\n\t\t\tconvertToStaticGeometry( mesh, options, this );\r\n\t\t\tdiff.updateFrom( mesh );\r\n\t\t\tthis.version ++;\r\n\t\t\tthis.hash = `${ this.uuid }_${ this.version }`;\r\n\t\t\treturn true;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n","import { Matrix4 } from 'three';\r\nimport { bufferToHash } from '../../utils/bufferToHash.js';\r\n\r\nfunction getGeometryHash( geometry ) {\r\n\r\n\tlet hash = geometry.uuid;\r\n\tconst attributes = Object.values( geometry.attributes );\r\n\tif ( geometry.index ) {\r\n\r\n\t\tattributes.push( geometry.index );\r\n\t\thash += `index|${ geometry.index.version }`;\r\n\r\n\t}\r\n\r\n\tconst keys = Object.keys( attributes ).sort();\r\n\tfor ( const key of keys ) {\r\n\r\n\t\tconst attr = attributes[ key ];\r\n\t\thash += `${ key }_${ attr.version }|`;\r\n\r\n\t}\r\n\r\n\treturn hash;\r\n\r\n}\r\n\r\nfunction getSkeletonHash( mesh ) {\r\n\r\n\tconst skeleton = mesh.skeleton;\r\n\tif ( skeleton ) {\r\n\r\n\t\tif ( ! skeleton.boneTexture ) {\r\n\r\n\t\t\tskeleton.computeBoneTexture();\r\n\r\n\t\t}\r\n\r\n\t\t// we can't use the texture version here because it will change even\r\n\t\t// when the bones haven't\r\n\t\tconst dataHash = bufferToHash( skeleton.boneTexture.image.data.buffer );\r\n\t\treturn `${ dataHash }_${ skeleton.boneTexture.uuid }`;\r\n\r\n\t} else {\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Checks whether the geometry changed between this and last evaluation\r\nexport class MeshDiff {\r\n\r\n\tconstructor( mesh = null ) {\r\n\r\n\t\tthis.matrixWorld = new Matrix4();\r\n\t\tthis.geometryHash = null;\r\n\t\tthis.skeletonHash = null;\r\n\t\tthis.primitiveCount = - 1;\r\n\r\n\t\tif ( mesh !== null ) {\r\n\r\n\t\t\tthis.updateFrom( mesh );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateFrom( mesh ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\r\n\t\tthis.geometryHash = getGeometryHash( geometry );\r\n\t\tthis.primitiveCount = primitiveCount;\r\n\t\tthis.skeletonHash = getSkeletonHash( mesh );\r\n\r\n\t}\r\n\r\n\tdidChange( mesh ) {\r\n\r\n\t\tconst geometry = mesh.geometry;\r\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\r\n\r\n\t\tconst identical =\r\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\r\n\t\t\tthis.geometryHash === getGeometryHash( geometry ) &&\r\n\t\t\tthis.skeletonHash === getSkeletonHash( mesh ) &&\r\n\t\t\tthis.primitiveCount === primitiveCount;\r\n\r\n\t\treturn ! identical;\r\n\r\n\t}\r\n\r\n}\r\n","// https://www.geeksforgeeks.org/how-to-create-hash-from-string-in-javascript/\r\n// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\r\nexport function bufferToHash( buffer ) {\r\n\r\n\tlet hash = 0;\r\n\r\n\tif ( buffer.byteLength !== 0 ) {\r\n\r\n\t\tconst uintArray = new Uint8Array( buffer );\r\n\t\tfor ( let i = 0; i < buffer.byteLength; i ++ ) {\r\n\r\n\t\t\tconst byte = uintArray[ i ];\r\n\t\t\thash = ( ( hash << 5 ) - hash ) + byte;\r\n\t\t\thash |= 0;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn hash;\r\n\r\n}\r\n","import { BufferGeometry, Matrix3, Matrix4, Vector3, Vector4 } from 'three';\r\nimport { copyAttributeContents, createAttributeClone, validateAttributes } from './BufferAttributeUtils.js';\r\n\r\nconst _positionVector = /*@__PURE__*/ new Vector3();\r\nconst _normalVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector = /*@__PURE__*/ new Vector3();\r\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\r\n\r\nconst _morphVector = /*@__PURE__*/ new Vector3();\r\nconst _temp = /*@__PURE__*/ new Vector3();\r\n\r\nconst _skinIndex = /*@__PURE__*/ new Vector4();\r\nconst _skinWeight = /*@__PURE__*/ new Vector4();\r\nconst _matrix = /*@__PURE__*/ new Matrix4();\r\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\r\n\r\n// A version of \"SkinnedMesh.boneTransform\" for normals\r\nfunction boneNormalTransform( mesh, index, target ) {\r\n\r\n\tconst skeleton = mesh.skeleton;\r\n\tconst geometry = mesh.geometry;\r\n\tconst bones = skeleton.bones;\r\n\tconst boneInverses = skeleton.boneInverses;\r\n\r\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\r\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\r\n\r\n\t_matrix.elements.fill( 0 );\r\n\r\n\tfor ( let i = 0; i < 4; i ++ ) {\r\n\r\n\t\tconst weight = _skinWeight.getComponent( i );\r\n\r\n\t\tif ( weight !== 0 ) {\r\n\r\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\r\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\r\n\r\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\r\n\ttarget.transformDirection( _matrix );\r\n\r\n\treturn target;\r\n\r\n}\r\n\r\n// Applies the morph target data to the target vector\r\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\r\n\r\n\t_morphVector.set( 0, 0, 0 );\r\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\r\n\r\n\t\tconst influence = morphInfluences[ j ];\r\n\t\tconst morphAttribute = morphData[ j ];\r\n\r\n\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\r\n\r\n\t\tif ( morphTargetsRelative ) {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp, influence );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttarget.add( _morphVector );\r\n\r\n}\r\n\r\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\r\nfunction addScaledMatrix( target, matrix, scale ) {\r\n\r\n\tconst targetArray = target.elements;\r\n\tconst matrixArray = matrix.elements;\r\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\r\n\r\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// inverts the geometry in place\r\nfunction invertGeometry( geometry ) {\r\n\r\n\tconst { index, attributes } = geometry;\r\n\tif ( index ) {\r\n\r\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\r\n\r\n\t\t\tconst v0 = index.getX( i );\r\n\t\t\tconst v2 = index.getX( i + 2 );\r\n\t\t\tindex.setX( i, v2 );\r\n\t\t\tindex.setX( i + 2, v0 );\r\n\r\n\t\t}\r\n\r\n\t} else {\r\n\r\n\t\tfor ( const key in attributes ) {\r\n\r\n\t\t\tconst attr = attributes[ key ];\r\n\t\t\tconst itemSize = attr.itemSize;\r\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\r\n\r\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\r\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\r\n\t\t\t\t\tattr.setComponent( i, j, v2 );\r\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn geometry;\r\n\r\n}\r\n\r\nexport function convertToStaticGeometry( mesh, options = {}, targetGeometry = new BufferGeometry() ) {\r\n\r\n\toptions = {\r\n\t\tapplyWorldTransforms: true,\r\n\t\tattributes: [],\r\n\t\t...options\r\n\t};\r\n\r\n\tconst geometry = mesh.geometry;\r\n\tconst applyWorldTransforms = options.applyWorldTransforms;\r\n\tconst includeNormal = options.attributes.includes( 'normal' );\r\n\tconst includeTangent = options.attributes.includes( 'tangent' );\r\n\tconst attributes = geometry.attributes;\r\n\tconst targetAttributes = targetGeometry.attributes;\r\n\r\n\t// strip any unused and unneeded attributes\r\n\tfor ( const key in targetGeometry.attributes ) {\r\n\r\n\t\tif ( ! options.attributes.includes( key ) || ! ( key in geometry.attributes ) ) {\r\n\r\n\t\t\ttargetGeometry.deleteAttribute( key );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// initialize the attributes if they don't exist\r\n\tif ( ! targetGeometry.index && geometry.index ) {\r\n\r\n\t\ttargetGeometry.index = geometry.index.clone();\r\n\r\n\t}\r\n\r\n\tif ( ! targetAttributes.position ) {\r\n\r\n\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\r\n\r\n\t}\r\n\r\n\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\r\n\r\n\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\r\n\r\n\t}\r\n\r\n\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\r\n\r\n\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\r\n\r\n\t}\r\n\r\n\t// ensure the attributes are consistent\r\n\tvalidateAttributes( geometry.index, targetGeometry.index );\r\n\tvalidateAttributes( attributes.position, targetAttributes.position );\r\n\r\n\tif ( includeNormal ) {\r\n\r\n\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\r\n\r\n\t}\r\n\r\n\tif ( includeTangent ) {\r\n\r\n\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\r\n\r\n\t}\r\n\r\n\t// generate transformed vertex attribute data\r\n\tconst position = attributes.position;\r\n\tconst normal = includeNormal ? attributes.normal : null;\r\n\tconst tangent = includeTangent ? attributes.tangent : null;\r\n\tconst morphPosition = geometry.morphAttributes.position;\r\n\tconst morphNormal = geometry.morphAttributes.normal;\r\n\tconst morphTangent = geometry.morphAttributes.tangent;\r\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\r\n\tconst morphInfluences = mesh.morphTargetInfluences;\r\n\tconst normalMatrix = new Matrix3();\r\n\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\r\n\r\n\t// copy the index\r\n\tif ( geometry.index ) {\r\n\r\n\t\ttargetGeometry.index.array.set( geometry.index.array );\r\n\r\n\t}\r\n\r\n\t// copy and apply other attributes\r\n\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\r\n\r\n\t\t_positionVector.fromBufferAttribute( position, i );\r\n\t\tif ( normal ) {\r\n\r\n\t\t\t_normalVector.fromBufferAttribute( normal, i );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tangent ) {\r\n\r\n\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\r\n\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\r\n\r\n\t\t}\r\n\r\n\t\t// apply morph target transform\r\n\t\tif ( morphInfluences ) {\r\n\r\n\t\t\tif ( morphPosition ) {\r\n\r\n\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( morphNormal ) {\r\n\r\n\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( morphTangent ) {\r\n\r\n\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// apply bone transform\r\n\t\tif ( mesh.isSkinnedMesh ) {\r\n\r\n\t\t\tmesh.applyBoneTransform( i, _positionVector );\r\n\t\t\tif ( normal ) {\r\n\r\n\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( tangent ) {\r\n\r\n\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// update the vectors of the attributes\r\n\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\r\n\r\n\t\tif ( normal ) {\r\n\r\n\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tangent ) {\r\n\r\n\t\t\tif ( applyWorldTransforms ) {\r\n\r\n\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// copy other attributes over\r\n\tfor ( const i in options.attributes ) {\r\n\r\n\t\tconst key = options.attributes[ i ];\r\n\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\r\n\r\n\t\t\tcontinue;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! targetAttributes[ key ] ) {\r\n\r\n\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\r\n\r\n\t\t}\r\n\r\n\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\r\n\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\r\n\r\n\t}\r\n\r\n\tif ( mesh.matrixWorld.determinant() < 0 ) {\r\n\r\n\t\tinvertGeometry( targetGeometry );\r\n\r\n\t}\r\n\r\n\treturn targetGeometry;\r\n\r\n}\r\n","export * from './camera_struct.glsl.js';\r\nexport * from './equirect_struct.glsl.js';\r\nexport * from './lights_struct.glsl.js';\r\nexport * from './material_struct.glsl.js';\r\nexport * from './surface_record_struct.glsl.js';\r\n","export const camera_struct = /* glsl */`\r\n\r\n\tstruct PhysicalCamera {\r\n\r\n\t\tfloat focusDistance;\r\n\t\tfloat anamorphicRatio;\r\n\t\tfloat bokehSize;\r\n\t\tint apertureBlades;\r\n\t\tfloat apertureRotation;\r\n\r\n\t};\r\n\r\n`;\r\n","export const equirect_struct = /* glsl */`\r\n\r\n\tstruct EquirectHdrInfo {\r\n\r\n\t\tsampler2D marginalWeights;\r\n\t\tsampler2D conditionalWeights;\r\n\t\tsampler2D map;\r\n\r\n\t\tfloat totalSum;\r\n\r\n\t};\r\n\r\n`;\r\n","export const lights_struct = /* glsl */`\r\n\r\n\t#define RECT_AREA_LIGHT_TYPE 0\r\n\t#define CIRC_AREA_LIGHT_TYPE 1\r\n\t#define SPOT_LIGHT_TYPE 2\r\n\t#define DIR_LIGHT_TYPE 3\r\n\t#define POINT_LIGHT_TYPE 4\r\n\r\n\tstruct LightsInfo {\r\n\r\n\t\tsampler2D tex;\r\n\t\tuint count;\r\n\r\n\t};\r\n\r\n\tstruct Light {\r\n\r\n\t\tvec3 position;\r\n\t\tint type;\r\n\r\n\t\tvec3 color;\r\n\t\tfloat intensity;\r\n\r\n\t\tvec3 u;\r\n\t\tvec3 v;\r\n\t\tfloat area;\r\n\r\n\t\t// spot light fields\r\n\t\tfloat radius;\r\n\t\tfloat near;\r\n\t\tfloat decay;\r\n\t\tfloat distance;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\t\tint iesProfile;\r\n\r\n\t};\r\n\r\n\tLight readLightInfo( sampler2D tex, uint index ) {\r\n\r\n\t\tuint i = index * 6u;\r\n\r\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\r\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\r\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\r\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\r\n\r\n\t\tLight l;\r\n\t\tl.position = s0.rgb;\r\n\t\tl.type = int( round( s0.a ) );\r\n\r\n\t\tl.color = s1.rgb;\r\n\t\tl.intensity = s1.a;\r\n\r\n\t\tl.u = s2.rgb;\r\n\t\tl.v = s3.rgb;\r\n\t\tl.area = s3.a;\r\n\r\n\t\tif ( l.type == SPOT_LIGHT_TYPE || l.type == POINT_LIGHT_TYPE ) {\r\n\r\n\t\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\r\n\t\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\r\n\t\t\tl.radius = s4.r;\r\n\t\t\tl.decay = s4.g;\r\n\t\t\tl.distance = s4.b;\r\n\t\t\tl.coneCos = s4.a;\r\n\r\n\t\t\tl.penumbraCos = s5.r;\r\n\t\t\tl.iesProfile = int( round( s5.g ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl.radius = 0.0;\r\n\t\t\tl.decay = 0.0;\r\n\t\t\tl.distance = 0.0;\r\n\r\n\t\t\tl.coneCos = 0.0;\r\n\t\t\tl.penumbraCos = 0.0;\r\n\t\t\tl.iesProfile = - 1;\r\n\r\n\t\t}\r\n\r\n\t\treturn l;\r\n\r\n\t}\r\n\r\n`;\r\n","export const material_struct = /* glsl */ `\r\n\r\n\tstruct Material {\r\n\r\n\t\tvec3 color;\r\n\t\tint map;\r\n\r\n\t\tfloat metalness;\r\n\t\tint metalnessMap;\r\n\r\n\t\tfloat roughness;\r\n\t\tint roughnessMap;\r\n\r\n\t\tfloat ior;\r\n\t\tfloat transmission;\r\n\t\tint transmissionMap;\r\n\r\n\t\tfloat emissiveIntensity;\r\n\t\tvec3 emissive;\r\n\t\tint emissiveMap;\r\n\r\n\t\tint normalMap;\r\n\t\tvec2 normalScale;\r\n\r\n\t\tfloat clearcoat;\r\n\t\tint clearcoatMap;\r\n\t\tint clearcoatNormalMap;\r\n\t\tvec2 clearcoatNormalScale;\r\n\t\tfloat clearcoatRoughness;\r\n\t\tint clearcoatRoughnessMap;\r\n\r\n\t\tint iridescenceMap;\r\n\t\tint iridescenceThicknessMap;\r\n\t\tfloat iridescence;\r\n\t\tfloat iridescenceIor;\r\n\t\tfloat iridescenceThicknessMinimum;\r\n\t\tfloat iridescenceThicknessMaximum;\r\n\r\n\t\tvec3 specularColor;\r\n\t\tint specularColorMap;\r\n\r\n\t\tfloat specularIntensity;\r\n\t\tint specularIntensityMap;\r\n\t\tbool thinFilm;\r\n\r\n\t\tvec3 attenuationColor;\r\n\t\tfloat attenuationDistance;\r\n\r\n\t\tint alphaMap;\r\n\r\n\t\tbool castShadow;\r\n\t\tfloat opacity;\r\n\t\tfloat alphaTest;\r\n\r\n\t\tfloat side;\r\n\t\tbool matte;\r\n\r\n\t\tfloat sheen;\r\n\t\tvec3 sheenColor;\r\n\t\tint sheenColorMap;\r\n\t\tfloat sheenRoughness;\r\n\t\tint sheenRoughnessMap;\r\n\r\n\t\tbool vertexColors;\r\n\t\tbool flatShading;\r\n\t\tbool transparent;\r\n\t\tbool fogVolume;\r\n\r\n\t\tmat3 mapTransform;\r\n\t\tmat3 metalnessMapTransform;\r\n\t\tmat3 roughnessMapTransform;\r\n\t\tmat3 transmissionMapTransform;\r\n\t\tmat3 emissiveMapTransform;\r\n\t\tmat3 normalMapTransform;\r\n\t\tmat3 clearcoatMapTransform;\r\n\t\tmat3 clearcoatNormalMapTransform;\r\n\t\tmat3 clearcoatRoughnessMapTransform;\r\n\t\tmat3 sheenColorMapTransform;\r\n\t\tmat3 sheenRoughnessMapTransform;\r\n\t\tmat3 iridescenceMapTransform;\r\n\t\tmat3 iridescenceThicknessMapTransform;\r\n\t\tmat3 specularColorMapTransform;\r\n\t\tmat3 specularIntensityMapTransform;\r\n\t\tmat3 alphaMapTransform;\r\n\r\n\t};\r\n\r\n\tmat3 readTextureTransform( sampler2D tex, uint index ) {\r\n\r\n\t\tmat3 textureTransform;\r\n\r\n\t\tvec4 row1 = texelFetch1D( tex, index );\r\n\t\tvec4 row2 = texelFetch1D( tex, index + 1u );\r\n\r\n\t\ttextureTransform[0] = vec3(row1.r, row2.r, 0.0);\r\n\t\ttextureTransform[1] = vec3(row1.g, row2.g, 0.0);\r\n\t\ttextureTransform[2] = vec3(row1.b, row2.b, 1.0);\r\n\r\n\t\treturn textureTransform;\r\n\r\n\t}\r\n\r\n\tMaterial readMaterialInfo( sampler2D tex, uint index ) {\r\n\r\n\t\tuint i = index * uint( MATERIAL_PIXELS );\r\n\r\n\t\tvec4 s0 = texelFetch1D( tex, i + 0u );\r\n\t\tvec4 s1 = texelFetch1D( tex, i + 1u );\r\n\t\tvec4 s2 = texelFetch1D( tex, i + 2u );\r\n\t\tvec4 s3 = texelFetch1D( tex, i + 3u );\r\n\t\tvec4 s4 = texelFetch1D( tex, i + 4u );\r\n\t\tvec4 s5 = texelFetch1D( tex, i + 5u );\r\n\t\tvec4 s6 = texelFetch1D( tex, i + 6u );\r\n\t\tvec4 s7 = texelFetch1D( tex, i + 7u );\r\n\t\tvec4 s8 = texelFetch1D( tex, i + 8u );\r\n\t\tvec4 s9 = texelFetch1D( tex, i + 9u );\r\n\t\tvec4 s10 = texelFetch1D( tex, i + 10u );\r\n\t\tvec4 s11 = texelFetch1D( tex, i + 11u );\r\n\t\tvec4 s12 = texelFetch1D( tex, i + 12u );\r\n\t\tvec4 s13 = texelFetch1D( tex, i + 13u );\r\n\t\tvec4 s14 = texelFetch1D( tex, i + 14u );\r\n\r\n\t\tMaterial m;\r\n\t\tm.color = s0.rgb;\r\n\t\tm.map = int( round( s0.a ) );\r\n\r\n\t\tm.metalness = s1.r;\r\n\t\tm.metalnessMap = int( round( s1.g ) );\r\n\t\tm.roughness = s1.b;\r\n\t\tm.roughnessMap = int( round( s1.a ) );\r\n\r\n\t\tm.ior = s2.r;\r\n\t\tm.transmission = s2.g;\r\n\t\tm.transmissionMap = int( round( s2.b ) );\r\n\t\tm.emissiveIntensity = s2.a;\r\n\r\n\t\tm.emissive = s3.rgb;\r\n\t\tm.emissiveMap = int( round( s3.a ) );\r\n\r\n\t\tm.normalMap = int( round( s4.r ) );\r\n\t\tm.normalScale = s4.gb;\r\n\r\n\t\tm.clearcoat = s4.a;\r\n\t\tm.clearcoatMap = int( round( s5.r ) );\r\n\t\tm.clearcoatRoughness = s5.g;\r\n\t\tm.clearcoatRoughnessMap = int( round( s5.b ) );\r\n\t\tm.clearcoatNormalMap = int( round( s5.a ) );\r\n\t\tm.clearcoatNormalScale = s6.rg;\r\n\r\n\t\tm.sheen = s6.a;\r\n\t\tm.sheenColor = s7.rgb;\r\n\t\tm.sheenColorMap = int( round( s7.a ) );\r\n\t\tm.sheenRoughness = s8.r;\r\n\t\tm.sheenRoughnessMap = int( round( s8.g ) );\r\n\r\n\t\tm.iridescenceMap = int( round( s8.b ) );\r\n\t\tm.iridescenceThicknessMap = int( round( s8.a ) );\r\n\t\tm.iridescence = s9.r;\r\n\t\tm.iridescenceIor = s9.g;\r\n\t\tm.iridescenceThicknessMinimum = s9.b;\r\n\t\tm.iridescenceThicknessMaximum = s9.a;\r\n\r\n\t\tm.specularColor = s10.rgb;\r\n\t\tm.specularColorMap = int( round( s10.a ) );\r\n\r\n\t\tm.specularIntensity = s11.r;\r\n\t\tm.specularIntensityMap = int( round( s11.g ) );\r\n\t\tm.thinFilm = bool( s11.b );\r\n\r\n\t\tm.attenuationColor = s12.rgb;\r\n\t\tm.attenuationDistance = s12.a;\r\n\r\n\t\tm.alphaMap = int( round( s13.r ) );\r\n\r\n\t\tm.opacity = s13.g;\r\n\t\tm.alphaTest = s13.b;\r\n\t\tm.side = s13.a;\r\n\r\n\t\tm.matte = bool( s14.r );\r\n\t\tm.castShadow = bool( s14.g );\r\n\t\tm.vertexColors = bool( int( s14.b ) & 1 );\r\n\t\tm.flatShading = bool( int( s14.b ) & 2 );\r\n\t\tm.fogVolume = bool( int( s14.b ) & 4 );\r\n\t\tm.transparent = bool( s14.a );\r\n\r\n\t\tuint firstTextureTransformIdx = i + 15u;\r\n\r\n\t\t// mat3( 1.0 ) is an identity matrix\r\n\t\tm.mapTransform = m.map == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx );\r\n\t\tm.metalnessMapTransform = m.metalnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 2u );\r\n\t\tm.roughnessMapTransform = m.roughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 4u );\r\n\t\tm.transmissionMapTransform = m.transmissionMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 6u );\r\n\t\tm.emissiveMapTransform = m.emissiveMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 8u );\r\n\t\tm.normalMapTransform = m.normalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 10u );\r\n\t\tm.clearcoatMapTransform = m.clearcoatMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 12u );\r\n\t\tm.clearcoatNormalMapTransform = m.clearcoatNormalMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 14u );\r\n\t\tm.clearcoatRoughnessMapTransform = m.clearcoatRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 16u );\r\n\t\tm.sheenColorMapTransform = m.sheenColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 18u );\r\n\t\tm.sheenRoughnessMapTransform = m.sheenRoughnessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 20u );\r\n\t\tm.iridescenceMapTransform = m.iridescenceMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 22u );\r\n\t\tm.iridescenceThicknessMapTransform = m.iridescenceThicknessMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 24u );\r\n\t\tm.specularColorMapTransform = m.specularColorMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 26u );\r\n\t\tm.specularIntensityMapTransform = m.specularIntensityMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 28u );\r\n\t\tm.alphaMapTransform = m.alphaMap == - 1 ? mat3( 1.0 ) : readTextureTransform( tex, firstTextureTransformIdx + 30u );\r\n\r\n\t\treturn m;\r\n\r\n\t}\r\n\r\n`;\r\n","export const surface_record_struct = /* glsl */`\r\n\r\n\tstruct SurfaceRecord {\r\n\r\n\t\t// surface type\r\n\t\tbool volumeParticle;\r\n\r\n\t\t// geometry\r\n\t\tvec3 faceNormal;\r\n\t\tbool frontFace;\r\n\t\tvec3 normal;\r\n\t\tmat3 normalBasis;\r\n\t\tmat3 normalInvBasis;\r\n\r\n\t\t// cached properties\r\n\t\tfloat eta;\r\n\t\tfloat f0;\r\n\r\n\t\t// material\r\n\t\tfloat roughness;\r\n\t\tfloat filteredRoughness;\r\n\t\tfloat metalness;\r\n\t\tvec3 color;\r\n\t\tvec3 emission;\r\n\r\n\t\t// transmission\r\n\t\tfloat ior;\r\n\t\tfloat transmission;\r\n\t\tbool thinFilm;\r\n\t\tvec3 attenuationColor;\r\n\t\tfloat attenuationDistance;\r\n\r\n\t\t// clearcoat\r\n\t\tvec3 clearcoatNormal;\r\n\t\tmat3 clearcoatBasis;\r\n\t\tmat3 clearcoatInvBasis;\r\n\t\tfloat clearcoat;\r\n\t\tfloat clearcoatRoughness;\r\n\t\tfloat filteredClearcoatRoughness;\r\n\r\n\t\t// sheen\r\n\t\tfloat sheen;\r\n\t\tvec3 sheenColor;\r\n\t\tfloat sheenRoughness;\r\n\r\n\t\t// iridescence\r\n\t\tfloat iridescence;\r\n\t\tfloat iridescenceIor;\r\n\t\tfloat iridescenceThickness;\r\n\r\n\t\t// specular\r\n\t\tvec3 specularColor;\r\n\t\tfloat specularIntensity;\r\n\t};\r\n\r\n\tstruct ScatterRecord {\r\n\t\tfloat specularPdf;\r\n\t\tfloat pdf;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t};\r\n\r\n`;\r\n","export * from './equirect_sampling_functions.glsl.js';\r\nexport * from './light_sampling_functions.glsl.js';\r\nexport * from './shape_sampling_functions.glsl.js';\r\n","export const equirect_functions = /* glsl */`\r\n\r\n\t// samples the the given environment map in the given direction\r\n\tvec3 sampleEquirectColor( sampler2D envMap, vec3 direction ) {\r\n\r\n\t\treturn texture2D( envMap, equirectDirectionToUv( direction ) ).rgb;\r\n\r\n\t}\r\n\r\n\t// gets the pdf of the given direction to sample\r\n\tfloat equirectDirectionPdf( vec3 direction ) {\r\n\r\n\t\tvec2 uv = equirectDirectionToUv( direction );\r\n\t\tfloat theta = uv.y * PI;\r\n\t\tfloat sinTheta = sin( theta );\r\n\t\tif ( sinTheta == 0.0 ) {\r\n\r\n\t\t\treturn 0.0;\r\n\r\n\t\t}\r\n\r\n\t\treturn 1.0 / ( 2.0 * PI * PI * sinTheta );\r\n\r\n\t}\r\n\r\n\t// samples the color given env map with CDF and returns the pdf of the direction\r\n\tfloat sampleEquirect( vec3 direction, inout vec3 color ) {\r\n\r\n\t\tfloat totalSum = envMapInfo.totalSum;\r\n\t\tif ( totalSum == 0.0 ) {\r\n\r\n\t\t\tcolor = vec3( 0.0 );\r\n\t\t\treturn 1.0;\r\n\r\n\t\t}\r\n\r\n\t\tvec2 uv = equirectDirectionToUv( direction );\r\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\r\n\r\n\t\tfloat lum = luminance( color );\r\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\r\n\t\tfloat pdf = lum / totalSum;\r\n\r\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\r\n\r\n\t}\r\n\r\n\t// samples a direction of the envmap with color and retrieves pdf\r\n\tfloat sampleEquirectProbability( vec2 r, inout vec3 color, inout vec3 direction ) {\r\n\r\n\t\t// sample env map cdf\r\n\t\tfloat v = texture2D( envMapInfo.marginalWeights, vec2( r.x, 0.0 ) ).x;\r\n\t\tfloat u = texture2D( envMapInfo.conditionalWeights, vec2( r.y, v ) ).x;\r\n\t\tvec2 uv = vec2( u, v );\r\n\r\n\t\tvec3 derivedDirection = equirectUvToDirection( uv );\r\n\t\tdirection = derivedDirection;\r\n\t\tcolor = texture2D( envMapInfo.map, uv ).rgb;\r\n\r\n\t\tfloat totalSum = envMapInfo.totalSum;\r\n\t\tfloat lum = luminance( color );\r\n\t\tivec2 resolution = textureSize( envMapInfo.map, 0 );\r\n\t\tfloat pdf = lum / totalSum;\r\n\r\n\t\treturn float( resolution.x * resolution.y ) * pdf * equirectDirectionPdf( direction );\r\n\r\n\t}\r\n`;\r\n","export const light_sampling_functions = /* glsl */`\r\n\r\n\tfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\r\n\r\n\t\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\r\n\r\n\t}\r\n\r\n\tfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\r\n\r\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\r\n\t\t// page 32, equation 26: E[window1]\r\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), EPSILON );\r\n\r\n\t\tif ( cutoffDistance > 0.0 ) {\r\n\r\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn distanceFalloff;\r\n\r\n\t}\r\n\r\n\tfloat getPhotometricAttenuation( sampler2DArray iesProfiles, int iesProfile, vec3 posToLight, vec3 lightDir, vec3 u, vec3 v ) {\r\n\r\n\t\tfloat cosTheta = dot( posToLight, lightDir );\r\n\t\tfloat angle = acos( cosTheta ) / PI;\r\n\r\n\t\treturn texture2D( iesProfiles, vec3( angle, 0.0, iesProfile ) ).r;\r\n\r\n\t}\r\n\r\n\tstruct LightRecord {\r\n\r\n\t\tfloat dist;\r\n\t\tvec3 direction;\r\n\t\tfloat pdf;\r\n\t\tvec3 emission;\r\n\t\tint type;\r\n\r\n\t};\r\n\r\n\tbool intersectLightAtIndex( sampler2D lights, vec3 rayOrigin, vec3 rayDirection, uint l, inout LightRecord lightRec ) {\r\n\r\n\t\tbool didHit = false;\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\r\n\t\t// check for backface\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\t\tif ( dot( normal, rayDirection ) > 0.0 ) {\r\n\r\n\t\t\tu *= 1.0 / dot( u, u );\r\n\t\t\tv *= 1.0 / dot( v, v );\r\n\r\n\t\t\tfloat dist;\r\n\r\n\t\t\t// MIS / light intersection is not supported for punctual lights.\r\n\t\t\tif(\r\n\t\t\t\t( light.type == RECT_AREA_LIGHT_TYPE && intersectsRectangle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) ) ||\r\n\t\t\t\t( light.type == CIRC_AREA_LIGHT_TYPE && intersectsCircle( light.position, normal, u, v, rayOrigin, rayDirection, dist ) )\r\n\t\t\t) {\r\n\r\n\t\t\t\tfloat cosTheta = dot( rayDirection, normal );\r\n\t\t\t\tdidHit = true;\r\n\t\t\t\tlightRec.dist = dist;\r\n\t\t\t\tlightRec.pdf = ( dist * dist ) / ( light.area * cosTheta );\r\n\t\t\t\tlightRec.emission = light.color * light.intensity;\r\n\t\t\t\tlightRec.direction = rayDirection;\r\n\t\t\t\tlightRec.type = light.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn didHit;\r\n\r\n\t}\r\n\r\n\tLightRecord randomAreaLightSample( Light light, vec3 rayOrigin, vec2 ruv ) {\r\n\r\n\t\tvec3 randomPos;\r\n\t\tif( light.type == RECT_AREA_LIGHT_TYPE ) {\r\n\r\n\t\t\t// rectangular area light\r\n\t\t\trandomPos = light.position + light.u * ( ruv.x - 0.5 ) + light.v * ( ruv.y - 0.5 );\r\n\r\n\t\t} else if( light.type == CIRC_AREA_LIGHT_TYPE ) {\r\n\r\n\t\t\t// circular area light\r\n\t\t\tfloat r = 0.5 * sqrt( ruv.x );\r\n\t\t\tfloat theta = ruv.y * 2.0 * PI;\r\n\t\t\tfloat x = r * cos( theta );\r\n\t\t\tfloat y = r * sin( theta );\r\n\r\n\t\t\trandomPos = light.position + light.u * x + light.v * y;\r\n\r\n\t\t}\r\n\r\n\t\tvec3 toLight = randomPos - rayOrigin;\r\n\t\tfloat lightDistSq = dot( toLight, toLight );\r\n\t\tfloat dist = sqrt( lightDistSq );\r\n\t\tvec3 direction = toLight / dist;\r\n\t\tvec3 lightNormal = normalize( cross( light.u, light.v ) );\r\n\r\n\t\tLightRecord lightRec;\r\n\t\tlightRec.type = light.type;\r\n\t\tlightRec.emission = light.color * light.intensity;\r\n\t\tlightRec.dist = dist;\r\n\t\tlightRec.direction = direction;\r\n\r\n\t\t// TODO: the denominator is potentially zero\r\n\t\tlightRec.pdf = lightDistSq / ( light.area * dot( direction, lightNormal ) );\r\n\r\n\t\treturn lightRec;\r\n\r\n\t}\r\n\r\n\tLightRecord randomSpotLightSample( Light light, sampler2DArray iesProfiles, vec3 rayOrigin, vec2 ruv ) {\r\n\r\n\t\tfloat radius = light.radius * sqrt( ruv.x );\r\n\t\tfloat theta = ruv.y * 2.0 * PI;\r\n\t\tfloat x = radius * cos( theta );\r\n\t\tfloat y = radius * sin( theta );\r\n\r\n\t\tvec3 u = light.u;\r\n\t\tvec3 v = light.v;\r\n\t\tvec3 normal = normalize( cross( u, v ) );\r\n\r\n\t\tfloat angle = acos( light.coneCos );\r\n\t\tfloat angleTan = tan( angle );\r\n\t\tfloat startDistance = light.radius / max( angleTan, EPSILON );\r\n\r\n\t\tvec3 randomPos = light.position - normal * startDistance + u * x + v * y;\r\n\t\tvec3 toLight = randomPos - rayOrigin;\r\n\t\tfloat lightDistSq = dot( toLight, toLight );\r\n\t\tfloat dist = sqrt( lightDistSq );\r\n\r\n\t\tvec3 direction = toLight / max( dist, EPSILON );\r\n\t\tfloat cosTheta = dot( direction, normal );\r\n\r\n\t\tfloat spotAttenuation = light.iesProfile != - 1 ?\r\n\t\t\tgetPhotometricAttenuation( iesProfiles, light.iesProfile, direction, normal, u, v ) :\r\n\t\t\tgetSpotAttenuation( light.coneCos, light.penumbraCos, cosTheta );\r\n\r\n\t\tfloat distanceAttenuation = getDistanceAttenuation( dist, light.distance, light.decay );\r\n\t\tLightRecord lightRec;\r\n\t\tlightRec.type = light.type;\r\n\t\tlightRec.dist = dist;\r\n\t\tlightRec.direction = direction;\r\n\t\tlightRec.emission = light.color * light.intensity * distanceAttenuation * spotAttenuation;\r\n\t\tlightRec.pdf = 1.0;\r\n\r\n\t\treturn lightRec;\r\n\r\n\t}\r\n\r\n\tLightRecord randomLightSample( sampler2D lights, sampler2DArray iesProfiles, uint lightCount, vec3 rayOrigin, vec3 ruv ) {\r\n\r\n\t\tLightRecord result;\r\n\r\n\t\t// pick a random light\r\n\t\tuint l = uint( ruv.x * float( lightCount ) );\r\n\t\tLight light = readLightInfo( lights, l );\r\n\r\n\t\tif ( light.type == SPOT_LIGHT_TYPE ) {\r\n\r\n\t\t\tresult = randomSpotLightSample( light, iesProfiles, rayOrigin, ruv.yz );\r\n\r\n\t\t} else if ( light.type == POINT_LIGHT_TYPE ) {\r\n\r\n\t\t\tvec3 lightRay = light.u - rayOrigin;\r\n\t\t\tfloat lightDist = length( lightRay );\r\n\t\t\tfloat cutoffDistance = light.distance;\r\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDist, light.decay ), 0.01 );\r\n\t\t\tif ( cutoffDistance > 0.0 ) {\r\n\r\n\t\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDist / cutoffDistance ) ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tLightRecord rec;\r\n\t\t\trec.direction = normalize( lightRay );\r\n\t\t\trec.dist = length( lightRay );\r\n\t\t\trec.pdf = 1.0;\r\n\t\t\trec.emission = light.color * light.intensity * distanceFalloff;\r\n\t\t\trec.type = light.type;\r\n\t\t\tresult = rec;\r\n\r\n\t\t} else if ( light.type == DIR_LIGHT_TYPE ) {\r\n\r\n\t\t\tLightRecord rec;\r\n\t\t\trec.dist = 1e10;\r\n\t\t\trec.direction = light.u;\r\n\t\t\trec.pdf = 1.0;\r\n\t\t\trec.emission = light.color * light.intensity;\r\n\t\t\trec.type = light.type;\r\n\r\n\t\t\tresult = rec;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// sample the light\r\n\t\t\tresult = randomAreaLightSample( light, rayOrigin, ruv.yz );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n`;\r\n","export const shape_sampling_functions = /* glsl */`\r\n\r\n\tvec3 sampleHemisphere( vec3 n, vec2 uv ) {\r\n\r\n\t\t// https://www.rorydriscoll.com/2009/01/07/better-sampling/\r\n\t\t// https://graphics.pixar.com/library/OrthonormalB/paper.pdf\r\n\t\tfloat sign = n.z == 0.0 ? 1.0 : sign( n.z );\r\n\t\tfloat a = - 1.0 / ( sign + n.z );\r\n\t\tfloat b = n.x * n.y * a;\r\n\t\tvec3 b1 = vec3( 1.0 + sign * n.x * n.x * a, sign * b, - sign * n.x );\r\n\t\tvec3 b2 = vec3( b, sign + n.y * n.y * a, - n.y );\r\n\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat theta = 2.0 * PI * uv.y;\r\n\t\tfloat x = r * cos( theta );\r\n\t\tfloat y = r * sin( theta );\r\n\t\treturn x * b1 + y * b2 + sqrt( 1.0 - uv.x ) * n;\r\n\r\n\t}\r\n\r\n\tvec2 sampleTriangle( vec2 a, vec2 b, vec2 c, vec2 r ) {\r\n\r\n\t\t// get the edges of the triangle and the diagonal across the\r\n\t\t// center of the parallelogram\r\n\t\tvec2 e1 = a - b;\r\n\t\tvec2 e2 = c - b;\r\n\t\tvec2 diag = normalize( e1 + e2 );\r\n\r\n\t\t// pick the point in the parallelogram\r\n\t\tif ( r.x + r.y > 1.0 ) {\r\n\r\n\t\t\tr = vec2( 1.0 ) - r;\r\n\r\n\t\t}\r\n\r\n\t\treturn e1 * r.x + e2 * r.y;\r\n\r\n\t}\r\n\r\n\tvec2 sampleCircle( vec2 uv ) {\r\n\r\n\t\tfloat angle = 2.0 * PI * uv.x;\r\n\t\tfloat radius = sqrt( uv.y );\r\n\t\treturn vec2( cos( angle ), sin( angle ) ) * radius;\r\n\r\n\t}\r\n\r\n\tvec3 sampleSphere( vec2 uv ) {\r\n\r\n\t\tfloat u = ( uv.x - 0.5 ) * 2.0;\r\n\t\tfloat t = uv.y * PI * 2.0;\r\n\t\tfloat f = sqrt( 1.0 - u * u );\r\n\r\n\t\treturn vec3( f * cos( t ), f * sin( t ), u );\r\n\r\n\t}\r\n\r\n\tvec2 sampleRegularPolygon( int sides, vec3 uvw ) {\r\n\r\n\t\tsides = max( sides, 3 );\r\n\r\n\t\tvec3 r = uvw;\r\n\t\tfloat anglePerSegment = 2.0 * PI / float( sides );\r\n\t\tfloat segment = floor( float( sides ) * r.x );\r\n\r\n\t\tfloat angle1 = anglePerSegment * segment;\r\n\t\tfloat angle2 = angle1 + anglePerSegment;\r\n\t\tvec2 a = vec2( sin( angle1 ), cos( angle1 ) );\r\n\t\tvec2 b = vec2( 0.0, 0.0 );\r\n\t\tvec2 c = vec2( sin( angle2 ), cos( angle2 ) );\r\n\r\n\t\treturn sampleTriangle( a, b, c, r.yz );\r\n\r\n\t}\r\n\r\n\t// samples an aperture shape with the given number of sides. 0 means circle\r\n\tvec2 sampleAperture( int blades, vec3 uvw ) {\r\n\r\n\t\treturn blades == 0 ?\r\n\t\t\tsampleCircle( uvw.xy ) :\r\n\t\t\tsampleRegularPolygon( blades, uvw );\r\n\r\n\t}\r\n\r\n\r\n`;\r\n","export * from './pcg.glsl.js';\r\nexport * from './sobol.glsl.js';\r\nexport * from './stratified.glsl.js';\r\n","export const pcg_functions = /* glsl */`\r\n\r\n\t// https://www.shadertoy.com/view/wltcRS\r\n\tuvec4 WHITE_NOISE_SEED;\r\n\r\n\tvoid rng_initialize( vec2 p, int frame ) {\r\n\r\n\t\t// white noise seed\r\n\t\tWHITE_NOISE_SEED = uvec4( p, uint( frame ), uint( p.x ) + uint( p.y ) );\r\n\r\n\t}\r\n\r\n\t// https://www.pcg-random.org/\r\n\tvoid pcg4d( inout uvec4 v ) {\r\n\r\n\t\tv = v * 1664525u + 1013904223u;\r\n\t\tv.x += v.y * v.w;\r\n\t\tv.y += v.z * v.x;\r\n\t\tv.z += v.x * v.y;\r\n\t\tv.w += v.y * v.z;\r\n\t\tv = v ^ ( v >> 16u );\r\n\t\tv.x += v.y*v.w;\r\n\t\tv.y += v.z*v.x;\r\n\t\tv.z += v.x*v.y;\r\n\t\tv.w += v.y*v.z;\r\n\r\n\t}\r\n\r\n\t// returns [ 0, 1 ]\r\n\tfloat pcgRand() {\r\n\r\n\t\tpcg4d( WHITE_NOISE_SEED );\r\n\t\treturn float( WHITE_NOISE_SEED.x ) / float( 0xffffffffu );\r\n\r\n\t}\r\n\r\n\tvec2 pcgRand2() {\r\n\r\n\t\tpcg4d( WHITE_NOISE_SEED );\r\n\t\treturn vec2( WHITE_NOISE_SEED.xy ) / float(0xffffffffu);\r\n\r\n\t}\r\n\r\n\tvec3 pcgRand3() {\r\n\r\n\t\tpcg4d( WHITE_NOISE_SEED );\r\n\t\treturn vec3( WHITE_NOISE_SEED.xyz ) / float( 0xffffffffu );\r\n\r\n\t}\r\n\r\n\tvec4 pcgRand4() {\r\n\r\n\t\tpcg4d( WHITE_NOISE_SEED );\r\n\t\treturn vec4( WHITE_NOISE_SEED ) / float( 0xffffffffu );\r\n\r\n\t}\r\n`;\r\n","// References\r\n// - https://jcgt.org/published/0009/04/01/\r\n// - Code from https://www.shadertoy.com/view/WtGyDm\r\n\r\n// functions to generate multi-dimensions variables of the same functions\r\n// to support 1, 2, 3, and 4 dimensional sobol sampling.\r\nfunction generateSobolFunctionVariants( dim = 1 ) {\r\n\r\n\tlet type = 'uint';\r\n\tif ( dim > 1 ) {\r\n\r\n\t\ttype = 'uvec' + dim;\r\n\r\n\t}\r\n\r\n\treturn /* glsl */`\r\n\t\t${ type } sobolReverseBits( ${ type } x ) {\r\n\r\n\t\t\tx = ( ( ( x & 0xaaaaaaaau ) >> 1 ) | ( ( x & 0x55555555u ) << 1 ) );\r\n\t\t\tx = ( ( ( x & 0xccccccccu ) >> 2 ) | ( ( x & 0x33333333u ) << 2 ) );\r\n\t\t\tx = ( ( ( x & 0xf0f0f0f0u ) >> 4 ) | ( ( x & 0x0f0f0f0fu ) << 4 ) );\r\n\t\t\tx = ( ( ( x & 0xff00ff00u ) >> 8 ) | ( ( x & 0x00ff00ffu ) << 8 ) );\r\n\t\t\treturn ( ( x >> 16 ) | ( x << 16 ) );\r\n\r\n\t\t}\r\n\r\n\t\t${ type } sobolHashCombine( uint seed, ${ type } v ) {\r\n\r\n\t\t\treturn seed ^ ( v + ${ type }( ( seed << 6 ) + ( seed >> 2 ) ) );\r\n\r\n\t\t}\r\n\r\n\t\t${ type } sobolLaineKarrasPermutation( ${ type } x, ${ type } seed ) {\r\n\r\n\t\t\tx += seed;\r\n\t\t\tx ^= x * 0x6c50b47cu;\r\n\t\t\tx ^= x * 0xb82f1e52u;\r\n\t\t\tx ^= x * 0xc7afe638u;\r\n\t\t\tx ^= x * 0x8d22f6e6u;\r\n\t\t\treturn x;\r\n\r\n\t\t}\r\n\r\n\t\t${ type } nestedUniformScrambleBase2( ${ type } x, ${ type } seed ) {\r\n\r\n\t\t\tx = sobolLaineKarrasPermutation( x, seed );\r\n\t\t\tx = sobolReverseBits( x );\r\n\t\t\treturn x;\r\n\r\n\t\t}\r\n\t`;\r\n\r\n}\r\n\r\nfunction generateSobolSampleFunctions( dim = 1 ) {\r\n\r\n\tlet utype = 'uint';\r\n\tlet vtype = 'float';\r\n\tlet num = '';\r\n\tlet components = '.r';\r\n\tlet combineValues = '1u';\r\n\tif ( dim > 1 ) {\r\n\r\n\t\tutype = 'uvec' + dim;\r\n\t\tvtype = 'vec' + dim;\r\n\t\tnum = dim + '';\r\n\t\tif ( dim === 2 ) {\r\n\r\n\t\t\tcomponents = '.rg';\r\n\t\t\tcombineValues = 'uvec2( 1u, 2u )';\r\n\r\n\t\t} else if ( dim === 3 ) {\r\n\r\n\t\t\tcomponents = '.rgb';\r\n\t\t\tcombineValues = 'uvec3( 1u, 2u, 3u )';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcomponents = '';\r\n\t\t\tcombineValues = 'uvec4( 1u, 2u, 3u, 4u )';\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn /* glsl */`\r\n\r\n\t\t${ vtype } sobol${ num }( int effect ) {\r\n\r\n\t\t\tuint seed = sobolGetSeed( sobolBounceIndex, uint( effect ) );\r\n\t\t\tuint index = sobolPathIndex;\r\n\r\n\t\t\tuint shuffle_seed = sobolHashCombine( seed, 0u );\r\n\t\t\tuint shuffled_index = nestedUniformScrambleBase2( sobolReverseBits( index ), shuffle_seed );\r\n\t\t\t${ vtype } sobol_pt = sobolGetTexturePoint( shuffled_index )${ components };\r\n\t\t\t${ utype } result = ${ utype }( sobol_pt * 16777216.0 );\r\n\r\n\t\t\t${ utype } seed2 = sobolHashCombine( seed, ${ combineValues } );\r\n\t\t\tresult = nestedUniformScrambleBase2( result, seed2 );\r\n\r\n\t\t\treturn SOBOL_FACTOR * ${ vtype }( result >> 8 );\r\n\r\n\t\t}\r\n\t`;\r\n\r\n}\r\n\r\nexport const sobol_common = /* glsl */`\r\n\r\n\t// Utils\r\n\tconst float SOBOL_FACTOR = 1.0 / 16777216.0;\r\n\tconst uint SOBOL_MAX_POINTS = 256u * 256u;\r\n\r\n\t${ generateSobolFunctionVariants( 1 ) }\r\n\t${ generateSobolFunctionVariants( 2 ) }\r\n\t${ generateSobolFunctionVariants( 3 ) }\r\n\t${ generateSobolFunctionVariants( 4 ) }\r\n\r\n\tuint sobolHash( uint x ) {\r\n\r\n\t\t// finalizer from murmurhash3\r\n\t\tx ^= x >> 16;\r\n\t\tx *= 0x85ebca6bu;\r\n\t\tx ^= x >> 13;\r\n\t\tx *= 0xc2b2ae35u;\r\n\t\tx ^= x >> 16;\r\n\t\treturn x;\r\n\r\n\t}\r\n\r\n`;\r\n\r\nexport const sobol_point_generation = /* glsl */`\r\n\r\n\tconst uint SOBOL_DIRECTIONS_1[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0xa0000000u, 0xf0000000u,\r\n\t\t0x88000000u, 0xcc000000u, 0xaa000000u, 0xff000000u,\r\n\t\t0x80800000u, 0xc0c00000u, 0xa0a00000u, 0xf0f00000u,\r\n\t\t0x88880000u, 0xcccc0000u, 0xaaaa0000u, 0xffff0000u,\r\n\t\t0x80008000u, 0xc000c000u, 0xa000a000u, 0xf000f000u,\r\n\t\t0x88008800u, 0xcc00cc00u, 0xaa00aa00u, 0xff00ff00u,\r\n\t\t0x80808080u, 0xc0c0c0c0u, 0xa0a0a0a0u, 0xf0f0f0f0u,\r\n\t\t0x88888888u, 0xccccccccu, 0xaaaaaaaau, 0xffffffffu\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_2[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0x60000000u, 0x90000000u,\r\n\t\t0xe8000000u, 0x5c000000u, 0x8e000000u, 0xc5000000u,\r\n\t\t0x68800000u, 0x9cc00000u, 0xee600000u, 0x55900000u,\r\n\t\t0x80680000u, 0xc09c0000u, 0x60ee0000u, 0x90550000u,\r\n\t\t0xe8808000u, 0x5cc0c000u, 0x8e606000u, 0xc5909000u,\r\n\t\t0x6868e800u, 0x9c9c5c00u, 0xeeee8e00u, 0x5555c500u,\r\n\t\t0x8000e880u, 0xc0005cc0u, 0x60008e60u, 0x9000c590u,\r\n\t\t0xe8006868u, 0x5c009c9cu, 0x8e00eeeeu, 0xc5005555u\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_3[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0xc0000000u, 0x20000000u, 0x50000000u,\r\n\t\t0xf8000000u, 0x74000000u, 0xa2000000u, 0x93000000u,\r\n\t\t0xd8800000u, 0x25400000u, 0x59e00000u, 0xe6d00000u,\r\n\t\t0x78080000u, 0xb40c0000u, 0x82020000u, 0xc3050000u,\r\n\t\t0x208f8000u, 0x51474000u, 0xfbea2000u, 0x75d93000u,\r\n\t\t0xa0858800u, 0x914e5400u, 0xdbe79e00u, 0x25db6d00u,\r\n\t\t0x58800080u, 0xe54000c0u, 0x79e00020u, 0xb6d00050u,\r\n\t\t0x800800f8u, 0xc00c0074u, 0x200200a2u, 0x50050093u\r\n\t);\r\n\r\n\tconst uint SOBOL_DIRECTIONS_4[ 32 ] = uint[ 32 ](\r\n\t\t0x80000000u, 0x40000000u, 0x20000000u, 0xb0000000u,\r\n\t\t0xf8000000u, 0xdc000000u, 0x7a000000u, 0x9d000000u,\r\n\t\t0x5a800000u, 0x2fc00000u, 0xa1600000u, 0xf0b00000u,\r\n\t\t0xda880000u, 0x6fc40000u, 0x81620000u, 0x40bb0000u,\r\n\t\t0x22878000u, 0xb3c9c000u, 0xfb65a000u, 0xddb2d000u,\r\n\t\t0x78022800u, 0x9c0b3c00u, 0x5a0fb600u, 0x2d0ddb00u,\r\n\t\t0xa2878080u, 0xf3c9c040u, 0xdb65a020u, 0x6db2d0b0u,\r\n\t\t0x800228f8u, 0x400b3cdcu, 0x200fb67au, 0xb00ddb9du\r\n\t);\r\n\r\n\tuint getMaskedSobol( uint index, uint directions[ 32 ] ) {\r\n\r\n\t\tuint X = 0u;\r\n\t\tfor ( int bit = 0; bit < 32; bit ++ ) {\r\n\r\n\t\t\tuint mask = ( index >> bit ) & 1u;\r\n\t\t\tX ^= mask * directions[ bit ];\r\n\r\n\t\t}\r\n\t\treturn X;\r\n\r\n\t}\r\n\r\n\tvec4 generateSobolPoint( uint index ) {\r\n\r\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\r\n\r\n\t\t\treturn vec4( 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\t// NOTE: this sobol \"direction\" is also available but we can't write out 5 components\r\n\t\t// uint x = index & 0x00ffffffu;\r\n\t\tuint x = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_1 ) ) & 0x00ffffffu;\r\n\t\tuint y = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_2 ) ) & 0x00ffffffu;\r\n\t\tuint z = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_3 ) ) & 0x00ffffffu;\r\n\t\tuint w = sobolReverseBits( getMaskedSobol( index, SOBOL_DIRECTIONS_4 ) ) & 0x00ffffffu;\r\n\r\n\t\treturn vec4( x, y, z, w ) * SOBOL_FACTOR;\r\n\r\n\t}\r\n\r\n`;\r\n\r\nexport const sobol_functions = /* glsl */`\r\n\r\n\t// Seeds\r\n\tuniform sampler2D sobolTexture;\r\n\tuint sobolPixelIndex = 0u;\r\n\tuint sobolPathIndex = 0u;\r\n\tuint sobolBounceIndex = 0u;\r\n\r\n\tuint sobolGetSeed( uint bounce, uint effect ) {\r\n\r\n\t\treturn sobolHash(\r\n\t\t\tsobolHashCombine(\r\n\t\t\t\tsobolHashCombine(\r\n\t\t\t\t\tsobolHash( bounce ),\r\n\t\t\t\t\tsobolPixelIndex\r\n\t\t\t\t),\r\n\t\t\t\teffect\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tvec4 sobolGetTexturePoint( uint index ) {\r\n\r\n\t\tif ( index >= SOBOL_MAX_POINTS ) {\r\n\r\n\t\t\tindex = index % SOBOL_MAX_POINTS;\r\n\r\n\t\t}\r\n\r\n\t\tuvec2 dim = uvec2( textureSize( sobolTexture, 0 ).xy );\r\n\t\tuint y = index / dim.x;\r\n\t\tuint x = index - y * dim.x;\r\n\t\tvec2 uv = vec2( x, y ) / vec2( dim );\r\n\t\treturn texture( sobolTexture, uv );\r\n\r\n\t}\r\n\r\n\t${ generateSobolSampleFunctions( 1 ) }\r\n\t${ generateSobolSampleFunctions( 2 ) }\r\n\t${ generateSobolSampleFunctions( 3 ) }\r\n\t${ generateSobolSampleFunctions( 4 ) }\r\n\r\n`;\r\n","export const stratified_functions = /* glsl */`\r\n\r\n\tuniform sampler2D stratifiedTexture;\r\n\tuniform sampler2D stratifiedOffsetTexture;\r\n\r\n\tuint sobolPixelIndex = 0u;\r\n\tuint sobolPathIndex = 0u;\r\n\tuint sobolBounceIndex = 0u;\r\n\tvec4 pixelSeed = vec4( 0 );\r\n\r\n\tvec4 rand4( int v ) {\r\n\r\n\t\tivec2 uv = ivec2( v, sobolBounceIndex );\r\n\t\tvec4 stratifiedSample = texelFetch( stratifiedTexture, uv, 0 );\r\n\t\treturn fract( stratifiedSample + pixelSeed.r ); // blue noise + stratified samples\r\n\r\n\t}\r\n\r\n\tvec3 rand3( int v ) {\r\n\r\n\t\treturn rand4( v ).xyz;\r\n\r\n\t}\r\n\r\n\tvec2 rand2( int v ) {\r\n\r\n\t\treturn rand4( v ).xy;\r\n\r\n\t}\r\n\r\n\tfloat rand( int v ) {\r\n\r\n\t\treturn rand4( v ).x;\r\n\r\n\t}\r\n\r\n\tvoid rng_initialize( vec2 screenCoord, int frame ) {\r\n\r\n\t\t// tile the small noise texture across the entire screen\r\n\t\tivec2 noiseSize = ivec2( textureSize( stratifiedOffsetTexture, 0 ) );\r\n\t\tivec2 pixel = ivec2( screenCoord.xy ) % noiseSize;\r\n\t\tvec2 pixelWidth = 1.0 / vec2( noiseSize );\r\n\t\tvec2 uv = vec2( pixel ) * pixelWidth + pixelWidth * 0.5;\r\n\r\n\t\t// note that using \"texelFetch\" here seems to break Android for some reason\r\n\t\tpixelSeed = texture( stratifiedOffsetTexture, uv );\r\n\r\n\t}\r\n\r\n`;\r\n"],"names":[],"version":3,"file":"aoRender.c33e7249.js.map","sourceRoot":"/__parcel_source_root/"}