{"mappings":"ISiBI,EAAY,EACZ,EAAQ,EAAO,EAAa,EAC5B,E,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,oB,I,G,I,E,E,QRjBG,OAAM,UAA0B,EAAA,oBAAmB,CAEzD,YAAa,CAAM,CAAG,CAErB,KAAK,CAAE,GAEP,IAAI,CAAC,mBAAmB,CAAG,CAAA,EAE3B,IAAI,CAAC,OAAO,CAAG,KACf,IAAI,CAAC,QAAQ,CAAG,IAAI,EAAA,KAAI,CACxB,IAAI,CAAC,iBAAiB,CAAG,EACzB,IAAI,CAAC,OAAO,CAAG,IACf,IAAI,CAAC,WAAW,CAAG,CAAA,EACnB,IAAI,CAAC,SAAS,CAAG,EACjB,IAAI,CAAC,SAAS,CAAG,EAEjB,IAAI,CAAC,SAAS,CAAE,EAEjB,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,G,I,E,E,QCpBO,OAAM,UAA0B,EAAA,SAAQ,CAE9C,YAAa,GAAG,CAAI,CAAG,CAEtB,KAAK,IAAK,GAEV,IAAI,CAAC,MAAM,CAAG,KACd,IAAI,CAAC,MAAM,CAAG,CAEf,CAEA,KAAM,CAAM,CAAE,CAAS,CAAG,CAOzB,OALA,KAAK,CAAC,KAAM,EAAQ,GAEpB,IAAI,CAAC,MAAM,CAAG,EAAO,MAAM,CAC3B,IAAI,CAAC,MAAM,CAAG,EAAO,MAAM,CAEpB,IAAI,AAEZ,CAED,C,G,E,Q,S,C,C,C,E,E,E,O,C,oB,I,GCxBO,SAAS,IAEf,IAAI,EAAQ,EACR,EAAc,KAAK,GAAG,CAAE,EAAI,OAAO,gBAAgB,CAAE,IAWzD,OARoB,OAAO,UAAU,CAAG,OAAO,WAAW,CACvC,MAElB,EAAQ,EACR,EAAc,GAAM,OAAO,gBAAgB,EAI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","sources":["<anon>","src/materials/surface/FogVolumeMaterial.js","src/objects/PhysicalSpotLight.js","example/utils/getScaledSettings.js","example/utils/LoaderElement.js","src/materials/MaterialBase.js","src/shader/common/math_functions.glsl.js","src/shader/common/util_functions.glsl.js","src/shader/bsdf/ggx_functions.glsl.js","example/fog.js"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire5b70\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire5b70\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"11ZPe\", function(module, exports) {\n\n$parcel$export(module.exports, \"FogVolumeMaterial\", () => $0c05d7af92b89513$export$cb2b7ad109612144);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $0c05d7af92b89513$export$cb2b7ad109612144 extends (0, $ilwiq.MeshStandardMaterial) {\n    constructor(params){\n        super(params);\n        this.isFogVolumeMaterial = true;\n        this.density = 0.015;\n        this.emissive = new (0, $ilwiq.Color)();\n        this.emissiveIntensity = 0.0;\n        this.opacity = 0.15;\n        this.transparent = true;\n        this.roughness = 1.0;\n        this.metalness = 0.0;\n        this.setValues(params);\n    }\n}\n\n});\n\nparcelRegister(\"d4kES\", function(module, exports) {\n\n$parcel$export(module.exports, \"PhysicalSpotLight\", () => $983bac6297e5cd71$export$920191b129a29c0);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $983bac6297e5cd71$export$920191b129a29c0 extends (0, $ilwiq.SpotLight) {\n    constructor(...args){\n        super(...args);\n        this.iesMap = null;\n        this.radius = 0;\n    }\n    copy(source, recursive) {\n        super.copy(source, recursive);\n        this.iesMap = source.iesMap;\n        this.radius = source.radius;\n        return this;\n    }\n}\n\n});\n\nparcelRegister(\"cE5k3\", function(module, exports) {\n\n$parcel$export(module.exports, \"getScaledSettings\", () => $934d596524c3e5a8$export$5bc756cb1c628b75);\nfunction $934d596524c3e5a8$export$5bc756cb1c628b75() {\n    let tiles = 3;\n    let renderScale = Math.max(1 / window.devicePixelRatio, 0.5);\n    // adjust performance parameters for mobile\n    const aspectRatio = window.innerWidth / window.innerHeight;\n    if (aspectRatio < 0.65) {\n        tiles = 4;\n        renderScale = 0.5 / window.devicePixelRatio;\n    }\n    return {\n        tiles: tiles,\n        renderScale: renderScale\n    };\n}\n\n});\n\nparcelRegister(\"e2Pv4\", function(module, exports) {\n\n$parcel$export(module.exports, \"LoaderElement\", () => $a399336cf50451da$export$c2252eb3bc5ad0b7);\nlet $a399336cf50451da$var$_styleElement;\nfunction $a399336cf50451da$var$initializeStyles() {\n    if ($a399336cf50451da$var$_styleElement) return;\n    $a399336cf50451da$var$_styleElement = document.createElement(\"style\");\n    $a399336cf50451da$var$_styleElement.textContent = /* css */ `\r\n\r\n\t\t.loader-container, .description {\r\n\t\t\tposition: absolute;\r\n\t\t\twidth: 100%;\r\n\t\t\tfont-family: 'Courier New', Courier, monospace;\r\n\t\t\tcolor: white;\r\n\t\t\tfont-weight: light;\r\n\t\t\talign-items: flex-start;\r\n\t\t\tfont-size: 14px;\r\n\t\t\tpointer-events: none;\r\n\t\t\tuser-select: none;\r\n\t\t}\r\n\r\n\t\t.loader-container {\r\n\t\t\tdisplay: flex;\r\n\t\t\tflex-direction: column;\r\n\t\t\tbottom: 0;\r\n\t\t}\r\n\r\n\t\t.description {\r\n\t\t\ttop: 0;\r\n\t\t\twidth: 100%;\r\n\t\t\ttext-align: center;\r\n\t\t\tpadding: 5px 0;\r\n\t\t}\r\n\r\n\t\t.loader-container .bar {\r\n\t\t\theight: 2px;\r\n\t\t\tbackground: white;\r\n\t\t\twidth: 100%;\r\n\t\t}\r\n\r\n\t\t.loader-container .credits,\r\n\t\t.loader-container .samples,\r\n\t\t.loader-container .percentage {\r\n\t\t\tpadding: 5px;\r\n\t\t\tmargin: 0 0 1px 1px;\r\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\r\n\t\t\tborder-radius: 2px;\r\n\t\t\tdisplay: inline-block;\r\n\t\t}\r\n\r\n\t\t.loader-container:not(.loading) .bar,\r\n\t\t.loader-container:not(.loading) .percentage,\r\n\t\t.loader-container.loading .credits,\r\n\t\t.loader-container.loading .samples,\r\n\t\t.loader-container .credits:empty {\r\n\t\t\tdisplay: none;\r\n\t\t}\r\n\r\n\t\t.loader-container .credits a,\r\n\t\t.loader-container .credits,\r\n\t\t.loader-container .samples {\r\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\r\n\t\t}\r\n\t`;\n    document.head.appendChild($a399336cf50451da$var$_styleElement);\n}\nclass $a399336cf50451da$export$c2252eb3bc5ad0b7 {\n    constructor(){\n        $a399336cf50451da$var$initializeStyles();\n        const container = document.createElement(\"div\");\n        container.classList.add(\"loader-container\");\n        const percentageEl = document.createElement(\"div\");\n        percentageEl.classList.add(\"percentage\");\n        container.appendChild(percentageEl);\n        const samplesEl = document.createElement(\"div\");\n        samplesEl.classList.add(\"samples\");\n        container.appendChild(samplesEl);\n        const creditsEl = document.createElement(\"div\");\n        creditsEl.classList.add(\"credits\");\n        container.appendChild(creditsEl);\n        const loaderBarEl = document.createElement(\"div\");\n        loaderBarEl.classList.add(\"bar\");\n        container.appendChild(loaderBarEl);\n        const descriptionEl = document.createElement(\"div\");\n        descriptionEl.classList.add(\"description\");\n        container.appendChild(descriptionEl);\n        this._description = descriptionEl;\n        this._loaderBar = loaderBarEl;\n        this._percentage = percentageEl;\n        this._credits = creditsEl;\n        this._samples = samplesEl;\n        this._container = container;\n        this.setPercentage(0);\n    }\n    attach(container) {\n        container.appendChild(this._container);\n        container.appendChild(this._description);\n    }\n    setPercentage(perc) {\n        this._loaderBar.style.width = `${perc * 100}%`;\n        if (perc === 0) this._percentage.innerText = \"Loading...\";\n        else this._percentage.innerText = `${(perc * 100).toFixed(0)}%`;\n        if (perc >= 1) this._container.classList.remove(\"loading\");\n        else this._container.classList.add(\"loading\");\n    }\n    setSamples(count, compiling = false) {\n        if (compiling) this._samples.innerText = \"compiling shader...\";\n        else this._samples.innerText = `${Math.floor(count)} samples`;\n    }\n    setCredits(credits) {\n        this._credits.innerHTML = credits;\n    }\n    setDescription(description) {\n        this._description.innerHTML = description;\n    }\n}\n\n});\n\nparcelRegister(\"9fZ6X\", function(module, exports) {\n\n$parcel$export(module.exports, \"MaterialBase\", () => $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d);\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\nclass $6bd4eb2914ee2835$export$f1ac3a587b6cbb5d extends (0, $ilwiq.ShaderMaterial) {\n    set needsUpdate(v) {\n        super.needsUpdate = true;\n        this.dispatchEvent({\n            type: \"recompilation\"\n        });\n    }\n    constructor(shader){\n        super(shader);\n        for(const key in this.uniforms)Object.defineProperty(this, key, {\n            get () {\n                return this.uniforms[key].value;\n            },\n            set (v) {\n                this.uniforms[key].value = v;\n            }\n        });\n    }\n    // sets the given named define value and sets \"needsUpdate\" to true if it's different\n    setDefine(name, value) {\n        if (value === undefined || value === null) {\n            if (name in this.defines) {\n                delete this.defines[name];\n                this.needsUpdate = true;\n                return true;\n            }\n        } else if (this.defines[name] !== value) {\n            this.defines[name] = value;\n            this.needsUpdate = true;\n            return true;\n        }\n        return false;\n    }\n}\n\n});\n\nparcelRegister(\"fYvb1\", function(module, exports) {\n\n$parcel$export(module.exports, \"math_functions\", () => $ba14a4aaa0cde19b$export$98323a006d35be35);\nconst $ba14a4aaa0cde19b$export$98323a006d35be35 = /* glsl */ `\r\n\r\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\r\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\r\n\t// For more information see: https://github.com/disini/three-gpu-pathtracer/pull/171#issuecomment-1152275248\r\n\tfloat acosApprox( float x ) {\r\n\r\n\t\tx = clamp( x, -1.0, 1.0 );\r\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\r\n\r\n\t}\r\n\r\n\t// An acos with input values bound to the range [-1, 1].\r\n\tfloat acosSafe( float x ) {\r\n\r\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\r\n\r\n\t}\r\n\r\n\tfloat saturateCos( float val ) {\r\n\r\n\t\treturn clamp( val, 0.001, 1.0 );\r\n\r\n\t}\r\n\r\n\tfloat square( float t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 square( vec2 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec3 square( vec3 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec4 square( vec4 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 rotateVector( vec2 v, float t ) {\r\n\r\n\t\tfloat ac = cos( t );\r\n\t\tfloat as = sin( t );\r\n\t\treturn vec2(\r\n\t\t\tv.x * ac - v.y * as,\r\n\t\t\tv.x * as + v.y * ac\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t// forms a basis with the normal vector as Z\r\n\tmat3 getBasisFromNormal( vec3 normal ) {\r\n\r\n\t\tvec3 other;\r\n\t\tif ( abs( normal.x ) > 0.5 ) {\r\n\r\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 ortho = normalize( cross( normal, other ) );\r\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\r\n\t\treturn mat3( ortho2, ortho, normal );\r\n\r\n\t}\r\n\r\n`;\n\n});\n\nparcelRegister(\"dUUQZ\", function(module, exports) {\n\n$parcel$export(module.exports, \"util_functions\", () => $a21c9b4177584031$export$fe1d788deccfbee3);\nconst $a21c9b4177584031$export$fe1d788deccfbee3 = /* glsl */ `\r\n\r\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\r\n\r\n\t#ifndef RAY_OFFSET\r\n\t#define RAY_OFFSET 1e-4\r\n\t#endif\r\n\r\n\t// adjust the hit point by the surface normal by a factor of some offset and the\r\n\t// maximum component-wise value of the current point to accommodate floating point\r\n\t// error as values increase.\r\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\r\n\r\n\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\tvec3 absPoint = abs( point );\r\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\r\n\r\n\t}\r\n\r\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\r\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\r\n\r\n\t\tvec3 ot = - log( attColor ) / attDist;\r\n\t\treturn exp( - ot * dist );\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\r\n\r\n\t\t// get the half vector - assuming if the light incident vector is on the other side\r\n\t\t// of the that it's transmissive.\r\n\t\tvec3 h;\r\n\t\tif ( wi.z > 0.0 ) {\r\n\r\n\t\t\th = normalize( wi + wo );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\r\n\t\t\t// From Section 2.2 on computing the transmission half vector:\r\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\r\n\t\t\th = normalize( wi + wo * eta );\r\n\r\n\t\t}\r\n\r\n\t\th *= sign( h.z );\r\n\t\treturn h;\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\r\n\r\n\t\treturn normalize( a + b );\r\n\r\n\t}\r\n\r\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\r\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\r\n\t// we find a ray like that we ignore it to avoid artifacts.\r\n\t// This function returns if the direction is on the same side of both planes.\r\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\r\n\r\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\r\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\r\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\r\n\r\n\t}\r\n\r\n\t// ray sampling x and z are swapped to align with expected background view\r\n\tvec2 equirectDirectionToUv( vec3 direction ) {\r\n\r\n\t\t// from Spherical.setFromCartesianCoords\r\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\r\n\t\tuv /= vec2( 2.0 * PI, PI );\r\n\r\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\r\n\t\tuv.x += 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tvec3 equirectUvToDirection( vec2 uv ) {\r\n\r\n\t\t// undo above adjustments\r\n\t\tuv.x -= 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\r\n\t\t// from Vector3.setFromSphericalCoords\r\n\t\tfloat theta = uv.x * 2.0 * PI;\r\n\t\tfloat phi = uv.y * PI;\r\n\r\n\t\tfloat sinPhi = sin( phi );\r\n\r\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\r\n\r\n\t}\r\n\r\n\t// power heuristic for multiple importance sampling\r\n\tfloat misHeuristic( float a, float b ) {\r\n\r\n\t\tfloat aa = a * a;\r\n\t\tfloat bb = b * b;\r\n\t\treturn aa / ( aa + bb );\r\n\r\n\t}\r\n\r\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\r\n\t// erichlof/THREE.js-PathTracing-Renderer/\r\n\tfloat tentFilter( float x ) {\r\n\r\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\r\n\r\n\t}\r\n`;\n\n});\n\nparcelRegister(\"8keuf\", function(module, exports) {\n\n$parcel$export(module.exports, \"ggx_functions\", () => $60fb6dc3c6495c33$export$4c711108e2e8ef5e);\nconst $60fb6dc3c6495c33$export$4c711108e2e8ef5e = /* glsl */ `\r\n\r\n\t// The GGX functions provide sampling and distribution information for normals as output so\r\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\r\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\r\n\t// [2] http://jcgt.org/published/0007/04/01/\r\n\t// [4] http://jcgt.org/published/0003/02/03/\r\n\r\n\t// trowbridge-reitz === GGX === GTR\r\n\r\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\r\n\r\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\r\n\t\t// function below, as well\r\n\r\n\t\t// Implementation from reference [1]\r\n\t\t// stretch view\r\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\r\n\r\n\t\t// orthonormal basis\r\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\r\n\t\tvec3 T2 = cross( T1, V );\r\n\r\n\t\t// sample point with polar coordinates (r, phi)\r\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\r\n\t\tfloat P1 = r * cos( phi );\r\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\r\n\r\n\t\t// compute normal\r\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\r\n\r\n\t\t// unstretch\r\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\r\n\r\n\t\treturn N;\r\n\r\n\t}\r\n\r\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\r\n\t// as specified in Appendix B of the following paper\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxLamda( float theta, float roughness ) {\r\n\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\r\n\t\tfloat alpha2 = roughness * roughness;\r\n\r\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\r\n\t\treturn numerator / 2.0;\r\n\r\n\t}\r\n\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\r\n\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (125) from reference [4]\r\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat scatterTheta = acos( wo.z );\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (33) from reference [0]\r\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat a2 = roughness * roughness;\r\n\t\ta2 = max( EPSILON, a2 );\r\n\t\tfloat cosTheta = halfVector.z;\r\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\r\n\r\n\t\tif ( cosTheta == 0.0 ) return 0.0;\r\n\r\n\t\tfloat theta = acosSafe( halfVector.z );\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\r\n\r\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\r\n\t\treturn ( a2 / denom );\r\n\r\n\t}\r\n\r\n\t// See equation (3) from reference [2]\r\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat D = ggxDistribution( halfVector, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\r\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\r\n\r\n\t}\r\n\r\n`;\n\n});\n\n\nvar $ilwiq = parcelRequire(\"ilwiq\");\n\nvar $5Rd1x = parcelRequire(\"5Rd1x\");\n\nvar $11ZPe = parcelRequire(\"11ZPe\");\nvar $kLfIo = parcelRequire(\"kLfIo\");\nvar $d4kES = parcelRequire(\"d4kES\");\nvar $8mHfG = parcelRequire(\"8mHfG\");\n\nvar $jiuw3 = parcelRequire(\"jiuw3\");\n\nvar $cE5k3 = parcelRequire(\"cE5k3\");\n\nvar $e2Pv4 = parcelRequire(\"e2Pv4\");\nlet $afdbfb1b28c84b51$var$pathTracer, $afdbfb1b28c84b51$var$renderer, $afdbfb1b28c84b51$var$controls;\nlet $afdbfb1b28c84b51$var$camera, $afdbfb1b28c84b51$var$scene, $afdbfb1b28c84b51$var$fogMaterial, $afdbfb1b28c84b51$var$spotLight;\nlet $afdbfb1b28c84b51$var$loader;\nconst $afdbfb1b28c84b51$var$params = {\n    multipleImportanceSampling: true,\n    tiles: 2,\n    renderScale: 1 / window.devicePixelRatio,\n    color: \"#eeeeee\",\n    fog: true,\n    density: 0.01,\n    lightIntensity: 500,\n    lightColor: \"#ffffff\",\n    bounces: 10,\n    ...(0, $cE5k3.getScaledSettings)()\n};\n$afdbfb1b28c84b51$var$init();\nasync function $afdbfb1b28c84b51$var$init() {\n    $afdbfb1b28c84b51$var$loader = new (0, $e2Pv4.LoaderElement)();\n    $afdbfb1b28c84b51$var$loader.attach(document.body);\n    // renderer\n    $afdbfb1b28c84b51$var$renderer = new (0, $ilwiq.WebGLRenderer)({\n        antialias: true\n    });\n    $afdbfb1b28c84b51$var$renderer.toneMapping = (0, $ilwiq.ACESFilmicToneMapping);\n    document.body.appendChild($afdbfb1b28c84b51$var$renderer.domElement);\n    // path tracer\n    $afdbfb1b28c84b51$var$pathTracer = new (0, $8mHfG.WebGLPathTracer)($afdbfb1b28c84b51$var$renderer);\n    $afdbfb1b28c84b51$var$pathTracer.tiles.set($afdbfb1b28c84b51$var$params.tiles, $afdbfb1b28c84b51$var$params.tiles);\n    // camera\n    const aspect = window.innerWidth / window.innerHeight;\n    $afdbfb1b28c84b51$var$camera = new (0, $kLfIo.PhysicalCamera)(75, aspect, 0.025, 500);\n    $afdbfb1b28c84b51$var$camera.position.set(0, 1, 6);\n    // controls\n    $afdbfb1b28c84b51$var$controls = new (0, $5Rd1x.OrbitControls)($afdbfb1b28c84b51$var$camera, $afdbfb1b28c84b51$var$renderer.domElement);\n    $afdbfb1b28c84b51$var$controls.addEventListener(\"change\", ()=>{\n        $afdbfb1b28c84b51$var$pathTracer.updateCamera();\n    });\n    // scene\n    $afdbfb1b28c84b51$var$scene = new (0, $ilwiq.Scene)();\n    $afdbfb1b28c84b51$var$scene.background = new (0, $ilwiq.Color)(0);\n    $afdbfb1b28c84b51$var$fogMaterial = new (0, $11ZPe.FogVolumeMaterial)();\n    const material = new (0, $ilwiq.MeshStandardMaterial)({\n        color: 0x999999,\n        roughness: 1,\n        metalness: 0\n    });\n    const fogMesh = new (0, $ilwiq.Mesh)(new (0, $ilwiq.BoxGeometry)(8, 4.05, 8), $afdbfb1b28c84b51$var$fogMaterial);\n    const floor = new (0, $ilwiq.Mesh)(new (0, $ilwiq.CylinderGeometry)(5, 5, 0.1, 40), material);\n    floor.position.y = -1.1;\n    // prepare light\n    $afdbfb1b28c84b51$var$spotLight = new (0, $d4kES.PhysicalSpotLight)();\n    $afdbfb1b28c84b51$var$spotLight.position.set(0, 1, 0).multiplyScalar(3);\n    $afdbfb1b28c84b51$var$spotLight.angle = Math.PI / 4.5;\n    $afdbfb1b28c84b51$var$spotLight.decay = 2;\n    $afdbfb1b28c84b51$var$spotLight.penumbra = 0.15;\n    $afdbfb1b28c84b51$var$spotLight.distance = 0.0;\n    $afdbfb1b28c84b51$var$spotLight.intensity = 50.0;\n    $afdbfb1b28c84b51$var$spotLight.radius = 0.05;\n    // prepare slats\n    const group = new (0, $ilwiq.Group)();\n    group.add($afdbfb1b28c84b51$var$spotLight);\n    const TOTAL_SLATS = 10;\n    const WIDTH = 2.0;\n    const slat = new (0, $ilwiq.Mesh)(new (0, $ilwiq.BoxGeometry)(0.1, 0.1, 2), material);\n    for(let i = 0; i < TOTAL_SLATS; i++){\n        const s = slat.clone();\n        s.position.x = -WIDTH * 0.5 + WIDTH * i / (TOTAL_SLATS - 1);\n        s.position.y = 2;\n        group.add(s);\n    }\n    $afdbfb1b28c84b51$var$scene.add(fogMesh, floor, group);\n    $afdbfb1b28c84b51$var$pathTracer.setScene($afdbfb1b28c84b51$var$scene, $afdbfb1b28c84b51$var$camera);\n    $afdbfb1b28c84b51$var$loader.setPercentage(1);\n    $afdbfb1b28c84b51$var$onParamsChange();\n    $afdbfb1b28c84b51$var$onResize();\n    window.addEventListener(\"resize\", $afdbfb1b28c84b51$var$onResize);\n    // gui\n    const gui = new (0, $jiuw3.GUI)();\n    const ptFolder = gui.addFolder(\"Path Tracer\");\n    ptFolder.add($afdbfb1b28c84b51$var$params, \"bounces\", 1, 20, 1).onChange($afdbfb1b28c84b51$var$onParamsChange);\n    ptFolder.add($afdbfb1b28c84b51$var$params, \"multipleImportanceSampling\").onChange($afdbfb1b28c84b51$var$onParamsChange);\n    ptFolder.add($afdbfb1b28c84b51$var$params, \"tiles\", 1, 4, 1).onChange((value)=>{\n        $afdbfb1b28c84b51$var$pathTracer.tiles.set(value, value);\n    });\n    ptFolder.add($afdbfb1b28c84b51$var$params, \"renderScale\", 0.1, 1).onChange($afdbfb1b28c84b51$var$onParamsChange);\n    const fogFolder = gui.addFolder(\"Fog\");\n    fogFolder.addColor($afdbfb1b28c84b51$var$params, \"color\").onChange($afdbfb1b28c84b51$var$onParamsChange);\n    fogFolder.add($afdbfb1b28c84b51$var$params, \"density\", 0, 1).onChange($afdbfb1b28c84b51$var$onParamsChange);\n    const lightFolder = gui.addFolder(\"Spot Light\");\n    lightFolder.add($afdbfb1b28c84b51$var$params, \"lightIntensity\", 0, 1000).onChange($afdbfb1b28c84b51$var$onParamsChange);\n    lightFolder.addColor($afdbfb1b28c84b51$var$params, \"lightColor\").onChange($afdbfb1b28c84b51$var$onParamsChange);\n    $afdbfb1b28c84b51$var$animate();\n}\nfunction $afdbfb1b28c84b51$var$onParamsChange() {\n    $afdbfb1b28c84b51$var$fogMaterial.color.set($afdbfb1b28c84b51$var$params.color).convertSRGBToLinear();\n    $afdbfb1b28c84b51$var$fogMaterial.density = $afdbfb1b28c84b51$var$params.density;\n    $afdbfb1b28c84b51$var$spotLight.intensity = $afdbfb1b28c84b51$var$params.lightIntensity;\n    $afdbfb1b28c84b51$var$spotLight.color.set($afdbfb1b28c84b51$var$params.lightColor);\n    $afdbfb1b28c84b51$var$pathTracer.multipleImportanceSampling = $afdbfb1b28c84b51$var$params.multipleImportanceSampling;\n    $afdbfb1b28c84b51$var$pathTracer.bounces = $afdbfb1b28c84b51$var$params.bounces;\n    $afdbfb1b28c84b51$var$pathTracer.renderScale = $afdbfb1b28c84b51$var$params.renderScale;\n    $afdbfb1b28c84b51$var$pathTracer.updateLights();\n    $afdbfb1b28c84b51$var$pathTracer.updateMaterials();\n}\nfunction $afdbfb1b28c84b51$var$onResize() {\n    $afdbfb1b28c84b51$var$renderer.setSize(window.innerWidth, window.innerHeight);\n    $afdbfb1b28c84b51$var$renderer.setPixelRatio(window.devicePixelRatio);\n    $afdbfb1b28c84b51$var$camera.aspect = window.innerWidth / window.innerHeight;\n    $afdbfb1b28c84b51$var$camera.updateProjectionMatrix();\n    $afdbfb1b28c84b51$var$pathTracer.updateCamera();\n}\nfunction $afdbfb1b28c84b51$var$animate() {\n    requestAnimationFrame($afdbfb1b28c84b51$var$animate);\n    $afdbfb1b28c84b51$var$pathTracer.renderSample();\n    $afdbfb1b28c84b51$var$loader.setSamples($afdbfb1b28c84b51$var$pathTracer.samples, $afdbfb1b28c84b51$var$pathTracer.isCompiling);\n}\n\n\n//# sourceMappingURL=fog.f4a51521.js.map\n","import { Color, MeshStandardMaterial } from 'three';\r\n\r\nexport class FogVolumeMaterial extends MeshStandardMaterial {\r\n\r\n\tconstructor( params ) {\r\n\r\n\t\tsuper( params );\r\n\r\n\t\tthis.isFogVolumeMaterial = true;\r\n\r\n\t\tthis.density = 0.015;\r\n\t\tthis.emissive = new Color();\r\n\t\tthis.emissiveIntensity = 0.0;\r\n\t\tthis.opacity = 0.15;\r\n\t\tthis.transparent = true;\r\n\t\tthis.roughness = 1.0;\r\n\t\tthis.metalness = 0.0;\r\n\r\n\t\tthis.setValues( params );\r\n\r\n\t}\r\n\r\n}\r\n","import { SpotLight } from 'three';\r\n\r\nexport class PhysicalSpotLight extends SpotLight {\r\n\r\n\tconstructor( ...args ) {\r\n\r\n\t\tsuper( ...args );\r\n\r\n\t\tthis.iesMap = null;\r\n\t\tthis.radius = 0;\r\n\r\n\t}\r\n\r\n\tcopy( source, recursive ) {\r\n\r\n\t\tsuper.copy( source, recursive );\r\n\r\n\t\tthis.iesMap = source.iesMap;\r\n\t\tthis.radius = source.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n","export function getScaledSettings() {\r\n\r\n\tlet tiles = 3;\r\n\tlet renderScale = Math.max( 1 / window.devicePixelRatio, 0.5 );\r\n\r\n\t// adjust performance parameters for mobile\r\n\tconst aspectRatio = window.innerWidth / window.innerHeight;\r\n\tif ( aspectRatio < 0.65 ) {\r\n\r\n\t\ttiles = 4;\r\n\t\trenderScale = 0.5 / window.devicePixelRatio;\r\n\r\n\t}\r\n\r\n\treturn { tiles, renderScale };\r\n\r\n}\r\n","let _styleElement;\r\nfunction initializeStyles() {\r\n\r\n\tif ( _styleElement ) {\r\n\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\t_styleElement = document.createElement( 'style' );\r\n\t_styleElement.textContent = /* css */`\r\n\r\n\t\t.loader-container, .description {\r\n\t\t\tposition: absolute;\r\n\t\t\twidth: 100%;\r\n\t\t\tfont-family: 'Courier New', Courier, monospace;\r\n\t\t\tcolor: white;\r\n\t\t\tfont-weight: light;\r\n\t\t\talign-items: flex-start;\r\n\t\t\tfont-size: 14px;\r\n\t\t\tpointer-events: none;\r\n\t\t\tuser-select: none;\r\n\t\t}\r\n\r\n\t\t.loader-container {\r\n\t\t\tdisplay: flex;\r\n\t\t\tflex-direction: column;\r\n\t\t\tbottom: 0;\r\n\t\t}\r\n\r\n\t\t.description {\r\n\t\t\ttop: 0;\r\n\t\t\twidth: 100%;\r\n\t\t\ttext-align: center;\r\n\t\t\tpadding: 5px 0;\r\n\t\t}\r\n\r\n\t\t.loader-container .bar {\r\n\t\t\theight: 2px;\r\n\t\t\tbackground: white;\r\n\t\t\twidth: 100%;\r\n\t\t}\r\n\r\n\t\t.loader-container .credits,\r\n\t\t.loader-container .samples,\r\n\t\t.loader-container .percentage {\r\n\t\t\tpadding: 5px;\r\n\t\t\tmargin: 0 0 1px 1px;\r\n\t\t\tbackground: rgba( 0, 0, 0, 0.2 );\r\n\t\t\tborder-radius: 2px;\r\n\t\t\tdisplay: inline-block;\r\n\t\t}\r\n\r\n\t\t.loader-container:not(.loading) .bar,\r\n\t\t.loader-container:not(.loading) .percentage,\r\n\t\t.loader-container.loading .credits,\r\n\t\t.loader-container.loading .samples,\r\n\t\t.loader-container .credits:empty {\r\n\t\t\tdisplay: none;\r\n\t\t}\r\n\r\n\t\t.loader-container .credits a,\r\n\t\t.loader-container .credits,\r\n\t\t.loader-container .samples {\r\n\t\t\tcolor: rgba( 255, 255, 255, 0.75 );\r\n\t\t}\r\n\t`;\r\n\tdocument.head.appendChild( _styleElement );\r\n\r\n}\r\n\r\nexport class LoaderElement {\r\n\r\n\tconstructor() {\r\n\r\n\t\tinitializeStyles();\r\n\r\n\t\tconst container = document.createElement( 'div' );\r\n\t\tcontainer.classList.add( 'loader-container' );\r\n\r\n\t\tconst percentageEl = document.createElement( 'div' );\r\n\t\tpercentageEl.classList.add( 'percentage' );\r\n\t\tcontainer.appendChild( percentageEl );\r\n\r\n\t\tconst samplesEl = document.createElement( 'div' );\r\n\t\tsamplesEl.classList.add( 'samples' );\r\n\t\tcontainer.appendChild( samplesEl );\r\n\r\n\t\tconst creditsEl = document.createElement( 'div' );\r\n\t\tcreditsEl.classList.add( 'credits' );\r\n\t\tcontainer.appendChild( creditsEl );\r\n\r\n\t\tconst loaderBarEl = document.createElement( 'div' );\r\n\t\tloaderBarEl.classList.add( 'bar' );\r\n\t\tcontainer.appendChild( loaderBarEl );\r\n\r\n\t\tconst descriptionEl = document.createElement( 'div' );\r\n\t\tdescriptionEl.classList.add( 'description' );\r\n\t\tcontainer.appendChild( descriptionEl );\r\n\r\n\t\tthis._description = descriptionEl;\r\n\t\tthis._loaderBar = loaderBarEl;\r\n\t\tthis._percentage = percentageEl;\r\n\t\tthis._credits = creditsEl;\r\n\t\tthis._samples = samplesEl;\r\n\t\tthis._container = container;\r\n\r\n\t\tthis.setPercentage( 0 );\r\n\r\n\t}\r\n\r\n\tattach( container ) {\r\n\r\n\t\tcontainer.appendChild( this._container );\r\n\t\tcontainer.appendChild( this._description );\r\n\r\n\t}\r\n\r\n\tsetPercentage( perc ) {\r\n\r\n\t\tthis._loaderBar.style.width = `${ perc * 100 }%`;\r\n\r\n\t\tif ( perc === 0 ) {\r\n\r\n\t\t\tthis._percentage.innerText = 'Loading...';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._percentage.innerText = `${ ( perc * 100 ).toFixed( 0 ) }%`;\r\n\r\n\t\t}\r\n\r\n\t\tif ( perc >= 1 ) {\r\n\r\n\t\t\tthis._container.classList.remove( 'loading' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._container.classList.add( 'loading' );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetSamples( count, compiling = false ) {\r\n\r\n\t\tif ( compiling ) {\r\n\r\n\t\t\tthis._samples.innerText = 'compiling shader...';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis._samples.innerText = `${ Math.floor( count ) } samples`;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tsetCredits( credits ) {\r\n\r\n\t\tthis._credits.innerHTML = credits;\r\n\r\n\t}\r\n\r\n\tsetDescription( description ) {\r\n\r\n\t\tthis._description.innerHTML = description;\r\n\r\n\t}\r\n\r\n}\r\n","import { ShaderMaterial } from 'three';\r\n\r\nexport class MaterialBase extends ShaderMaterial {\r\n\r\n\tset needsUpdate( v ) {\r\n\r\n\t\tsuper.needsUpdate = true;\r\n\t\tthis.dispatchEvent( {\r\n\r\n\t\t\ttype: 'recompilation',\r\n\r\n\t\t} );\r\n\r\n\t}\r\n\r\n\tconstructor( shader ) {\r\n\r\n\t\tsuper( shader );\r\n\r\n\t\tfor ( const key in this.uniforms ) {\r\n\r\n\t\t\tObject.defineProperty( this, key, {\r\n\r\n\t\t\t\tget() {\r\n\r\n\t\t\t\t\treturn this.uniforms[ key ].value;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tset( v ) {\r\n\r\n\t\t\t\t\tthis.uniforms[ key ].value = v;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// sets the given named define value and sets \"needsUpdate\" to true if it's different\r\n\tsetDefine( name, value = undefined ) {\r\n\r\n\t\tif ( value === undefined || value === null ) {\r\n\r\n\t\t\tif ( name in this.defines ) {\r\n\r\n\t\t\t\tdelete this.defines[ name ];\r\n\t\t\t\tthis.needsUpdate = true;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( this.defines[ name ] !== value ) {\r\n\r\n\t\t\t\tthis.defines[ name ] = value;\r\n\t\t\t\tthis.needsUpdate = true;\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n}\r\n","export const math_functions = /* glsl */`\r\n\r\n\t// Fast arccos approximation used to remove banding artifacts caused by numerical errors in acos.\r\n\t// This is a cubic Lagrange interpolating polynomial for x = [-1, -1/2, 0, 1/2, 1].\r\n\t// For more information see: https://github.com/disini/three-gpu-pathtracer/pull/171#issuecomment-1152275248\r\n\tfloat acosApprox( float x ) {\r\n\r\n\t\tx = clamp( x, -1.0, 1.0 );\r\n\t\treturn ( - 0.69813170079773212 * x * x - 0.87266462599716477 ) * x + 1.5707963267948966;\r\n\r\n\t}\r\n\r\n\t// An acos with input values bound to the range [-1, 1].\r\n\tfloat acosSafe( float x ) {\r\n\r\n\t\treturn acos( clamp( x, -1.0, 1.0 ) );\r\n\r\n\t}\r\n\r\n\tfloat saturateCos( float val ) {\r\n\r\n\t\treturn clamp( val, 0.001, 1.0 );\r\n\r\n\t}\r\n\r\n\tfloat square( float t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 square( vec2 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec3 square( vec3 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec4 square( vec4 t ) {\r\n\r\n\t\treturn t * t;\r\n\r\n\t}\r\n\r\n\tvec2 rotateVector( vec2 v, float t ) {\r\n\r\n\t\tfloat ac = cos( t );\r\n\t\tfloat as = sin( t );\r\n\t\treturn vec2(\r\n\t\t\tv.x * ac - v.y * as,\r\n\t\t\tv.x * as + v.y * ac\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t// forms a basis with the normal vector as Z\r\n\tmat3 getBasisFromNormal( vec3 normal ) {\r\n\r\n\t\tvec3 other;\r\n\t\tif ( abs( normal.x ) > 0.5 ) {\r\n\r\n\t\t\tother = vec3( 0.0, 1.0, 0.0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tother = vec3( 1.0, 0.0, 0.0 );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 ortho = normalize( cross( normal, other ) );\r\n\t\tvec3 ortho2 = normalize( cross( normal, ortho ) );\r\n\t\treturn mat3( ortho2, ortho, normal );\r\n\r\n\t}\r\n\r\n`;\r\n","export const util_functions = /* glsl */`\r\n\r\n\t// TODO: possibly this should be renamed something related to material or path tracing logic\r\n\r\n\t#ifndef RAY_OFFSET\r\n\t#define RAY_OFFSET 1e-4\r\n\t#endif\r\n\r\n\t// adjust the hit point by the surface normal by a factor of some offset and the\r\n\t// maximum component-wise value of the current point to accommodate floating point\r\n\t// error as values increase.\r\n\tvec3 stepRayOrigin( vec3 rayOrigin, vec3 rayDirection, vec3 offset, float dist ) {\r\n\r\n\t\tvec3 point = rayOrigin + rayDirection * dist;\r\n\t\tvec3 absPoint = abs( point );\r\n\t\tfloat maxPoint = max( absPoint.x, max( absPoint.y, absPoint.z ) );\r\n\t\treturn point + offset * ( maxPoint + 1.0 ) * RAY_OFFSET;\r\n\r\n\t}\r\n\r\n\t// https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md#attenuation\r\n\tvec3 transmissionAttenuation( float dist, vec3 attColor, float attDist ) {\r\n\r\n\t\tvec3 ot = - log( attColor ) / attDist;\r\n\t\treturn exp( - ot * dist );\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 wi, vec3 wo, float eta ) {\r\n\r\n\t\t// get the half vector - assuming if the light incident vector is on the other side\r\n\t\t// of the that it's transmissive.\r\n\t\tvec3 h;\r\n\t\tif ( wi.z > 0.0 ) {\r\n\r\n\t\t\th = normalize( wi + wo );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Scale by the ior ratio to retrieve the appropriate half vector\r\n\t\t\t// From Section 2.2 on computing the transmission half vector:\r\n\t\t\t// https://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf\r\n\t\t\th = normalize( wi + wo * eta );\r\n\r\n\t\t}\r\n\r\n\t\th *= sign( h.z );\r\n\t\treturn h;\r\n\r\n\t}\r\n\r\n\tvec3 getHalfVector( vec3 a, vec3 b ) {\r\n\r\n\t\treturn normalize( a + b );\r\n\r\n\t}\r\n\r\n\t// The discrepancy between interpolated surface normal and geometry normal can cause issues when a ray\r\n\t// is cast that is on the top side of the geometry normal plane but below the surface normal plane. If\r\n\t// we find a ray like that we ignore it to avoid artifacts.\r\n\t// This function returns if the direction is on the same side of both planes.\r\n\tbool isDirectionValid( vec3 direction, vec3 surfaceNormal, vec3 geometryNormal ) {\r\n\r\n\t\tbool aboveSurfaceNormal = dot( direction, surfaceNormal ) > 0.0;\r\n\t\tbool aboveGeometryNormal = dot( direction, geometryNormal ) > 0.0;\r\n\t\treturn aboveSurfaceNormal == aboveGeometryNormal;\r\n\r\n\t}\r\n\r\n\t// ray sampling x and z are swapped to align with expected background view\r\n\tvec2 equirectDirectionToUv( vec3 direction ) {\r\n\r\n\t\t// from Spherical.setFromCartesianCoords\r\n\t\tvec2 uv = vec2( atan( direction.z, direction.x ), acos( direction.y ) );\r\n\t\tuv /= vec2( 2.0 * PI, PI );\r\n\r\n\t\t// apply adjustments to get values in range [0, 1] and y right side up\r\n\t\tuv.x += 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\t\treturn uv;\r\n\r\n\t}\r\n\r\n\tvec3 equirectUvToDirection( vec2 uv ) {\r\n\r\n\t\t// undo above adjustments\r\n\t\tuv.x -= 0.5;\r\n\t\tuv.y = 1.0 - uv.y;\r\n\r\n\t\t// from Vector3.setFromSphericalCoords\r\n\t\tfloat theta = uv.x * 2.0 * PI;\r\n\t\tfloat phi = uv.y * PI;\r\n\r\n\t\tfloat sinPhi = sin( phi );\r\n\r\n\t\treturn vec3( sinPhi * cos( theta ), cos( phi ), sinPhi * sin( theta ) );\r\n\r\n\t}\r\n\r\n\t// power heuristic for multiple importance sampling\r\n\tfloat misHeuristic( float a, float b ) {\r\n\r\n\t\tfloat aa = a * a;\r\n\t\tfloat bb = b * b;\r\n\t\treturn aa / ( aa + bb );\r\n\r\n\t}\r\n\r\n\t// tentFilter from Peter Shirley's 'Realistic Ray Tracing (2nd Edition)' book, pg. 60\r\n\t// erichlof/THREE.js-PathTracing-Renderer/\r\n\tfloat tentFilter( float x ) {\r\n\r\n\t\treturn x < 0.5 ? sqrt( 2.0 * x ) - 1.0 : 1.0 - sqrt( 2.0 - ( 2.0 * x ) );\r\n\r\n\t}\r\n`;\r\n","export const ggx_functions = /* glsl */`\r\n\r\n\t// The GGX functions provide sampling and distribution information for normals as output so\r\n\t// in order to get probability of scatter direction the half vector must be computed and provided.\r\n\t// [0] https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf\r\n\t// [1] https://hal.archives-ouvertes.fr/hal-01509746/document\r\n\t// [2] http://jcgt.org/published/0007/04/01/\r\n\t// [4] http://jcgt.org/published/0003/02/03/\r\n\r\n\t// trowbridge-reitz === GGX === GTR\r\n\r\n\tvec3 ggxDirection( vec3 incidentDir, vec2 roughness, vec2 uv ) {\r\n\r\n\t\t// TODO: try GGXVNDF implementation from reference [2], here. Needs to update ggxDistribution\r\n\t\t// function below, as well\r\n\r\n\t\t// Implementation from reference [1]\r\n\t\t// stretch view\r\n\t\tvec3 V = normalize( vec3( roughness * incidentDir.xy, incidentDir.z ) );\r\n\r\n\t\t// orthonormal basis\r\n\t\tvec3 T1 = ( V.z < 0.9999 ) ? normalize( cross( V, vec3( 0.0, 0.0, 1.0 ) ) ) : vec3( 1.0, 0.0, 0.0 );\r\n\t\tvec3 T2 = cross( T1, V );\r\n\r\n\t\t// sample point with polar coordinates (r, phi)\r\n\t\tfloat a = 1.0 / ( 1.0 + V.z );\r\n\t\tfloat r = sqrt( uv.x );\r\n\t\tfloat phi = ( uv.y < a ) ? uv.y / a * PI : PI + ( uv.y - a ) / ( 1.0 - a ) * PI;\r\n\t\tfloat P1 = r * cos( phi );\r\n\t\tfloat P2 = r * sin( phi ) * ( ( uv.y < a ) ? 1.0 : V.z );\r\n\r\n\t\t// compute normal\r\n\t\tvec3 N = P1 * T1 + P2 * T2 + V * sqrt( max( 0.0, 1.0 - P1 * P1 - P2 * P2 ) );\r\n\r\n\t\t// unstretch\r\n\t\tN = normalize( vec3( roughness * N.xy, max( 0.0, N.z ) ) );\r\n\r\n\t\treturn N;\r\n\r\n\t}\r\n\r\n\t// Below are PDF and related functions for use in a Monte Carlo path tracer\r\n\t// as specified in Appendix B of the following paper\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxLamda( float theta, float roughness ) {\r\n\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = tanTheta * tanTheta;\r\n\t\tfloat alpha2 = roughness * roughness;\r\n\r\n\t\tfloat numerator = - 1.0 + sqrt( 1.0 + alpha2 * tanTheta2 );\r\n\t\treturn numerator / 2.0;\r\n\r\n\t}\r\n\r\n\t// See equation (34) from reference [0]\r\n\tfloat ggxShadowMaskG1( float theta, float roughness ) {\r\n\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( theta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (125) from reference [4]\r\n\tfloat ggxShadowMaskG2( vec3 wi, vec3 wo, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat scatterTheta = acos( wo.z );\r\n\t\treturn 1.0 / ( 1.0 + ggxLamda( incidentTheta, roughness ) + ggxLamda( scatterTheta, roughness ) );\r\n\r\n\t}\r\n\r\n\t// See equation (33) from reference [0]\r\n\tfloat ggxDistribution( vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat a2 = roughness * roughness;\r\n\t\ta2 = max( EPSILON, a2 );\r\n\t\tfloat cosTheta = halfVector.z;\r\n\t\tfloat cosTheta4 = pow( cosTheta, 4.0 );\r\n\r\n\t\tif ( cosTheta == 0.0 ) return 0.0;\r\n\r\n\t\tfloat theta = acosSafe( halfVector.z );\r\n\t\tfloat tanTheta = tan( theta );\r\n\t\tfloat tanTheta2 = pow( tanTheta, 2.0 );\r\n\r\n\t\tfloat denom = PI * cosTheta4 * pow( a2 + tanTheta2, 2.0 );\r\n\t\treturn ( a2 / denom );\r\n\r\n\t}\r\n\r\n\t// See equation (3) from reference [2]\r\n\tfloat ggxPDF( vec3 wi, vec3 halfVector, float roughness ) {\r\n\r\n\t\tfloat incidentTheta = acos( wi.z );\r\n\t\tfloat D = ggxDistribution( halfVector, roughness );\r\n\t\tfloat G1 = ggxShadowMaskG1( incidentTheta, roughness );\r\n\r\n\t\treturn D * G1 * max( 0.0, dot( wi, halfVector ) ) / wi.z;\r\n\r\n\t}\r\n\r\n`;\r\n","import {\r\n\tACESFilmicToneMapping,\r\n\tScene,\r\n\tBoxGeometry,\r\n\tCylinderGeometry,\r\n\tGroup,\r\n\tMesh,\r\n\tMeshStandardMaterial,\r\n\tWebGLRenderer,\r\n\tColor,\r\n} from 'three';\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\r\nimport { PhysicalCamera, PhysicalSpotLight, FogVolumeMaterial, WebGLPathTracer } from '../src/index.js';\r\nimport { GUI } from 'three/examples/jsm/libs/lil-gui.module.min.js';\r\nimport { getScaledSettings } from './utils/getScaledSettings.js';\r\nimport { LoaderElement } from './utils/LoaderElement.js';\r\n\r\nlet pathTracer, renderer, controls;\r\nlet camera, scene, fogMaterial, spotLight;\r\nlet loader;\r\n\r\nconst params = {\r\n\r\n\tmultipleImportanceSampling: true,\r\n\ttiles: 2,\r\n\trenderScale: 1 / window.devicePixelRatio,\r\n\r\n\tcolor: '#eeeeee',\r\n\tfog: true,\r\n\tdensity: 0.01,\r\n\tlightIntensity: 500,\r\n\tlightColor: '#ffffff',\r\n\r\n\tbounces: 10,\r\n\r\n\t...getScaledSettings(),\r\n\r\n};\r\n\r\ninit();\r\n\r\nasync function init() {\r\n\r\n\tloader = new LoaderElement();\r\n\tloader.attach( document.body );\r\n\r\n\t// renderer\r\n\trenderer = new WebGLRenderer( { antialias: true } );\r\n\trenderer.toneMapping = ACESFilmicToneMapping;\r\n\tdocument.body.appendChild( renderer.domElement );\r\n\r\n\t// path tracer\r\n\tpathTracer = new WebGLPathTracer( renderer );\r\n\tpathTracer.tiles.set( params.tiles, params.tiles );\r\n\r\n\t// camera\r\n\tconst aspect = window.innerWidth / window.innerHeight;\r\n\tcamera = new PhysicalCamera( 75, aspect, 0.025, 500 );\r\n\tcamera.position.set( 0, 1, 6 );\r\n\r\n\t// controls\r\n\tcontrols = new OrbitControls( camera, renderer.domElement );\r\n\tcontrols.addEventListener( 'change', () => {\r\n\r\n\t\tpathTracer.updateCamera();\r\n\r\n\t} );\r\n\r\n\t// scene\r\n\tscene = new Scene();\r\n\tscene.background = new Color( 0 );\r\n\r\n\tfogMaterial = new FogVolumeMaterial();\r\n\r\n\tconst material = new MeshStandardMaterial( { color: 0x999999, roughness: 1, metalness: 0 } );\r\n\tconst fogMesh = new Mesh( new BoxGeometry( 8, 4.05, 8 ), fogMaterial );\r\n\tconst floor = new Mesh( new CylinderGeometry( 5, 5, 0.1, 40 ), material );\r\n\tfloor.position.y = - 1.1;\r\n\r\n\t// prepare light\r\n\tspotLight = new PhysicalSpotLight();\r\n\tspotLight.position.set( 0, 1, 0 ).multiplyScalar( 3 );\r\n\tspotLight.angle = Math.PI / 4.5;\r\n\tspotLight.decay = 2;\r\n\tspotLight.penumbra = 0.15;\r\n\tspotLight.distance = 0.0;\r\n\tspotLight.intensity = 50.0;\r\n\tspotLight.radius = 0.05;\r\n\r\n\t// prepare slats\r\n\tconst group = new Group();\r\n\tgroup.add( spotLight );\r\n\r\n\tconst TOTAL_SLATS = 10;\r\n\tconst WIDTH = 2.0;\r\n\tconst slat = new Mesh( new BoxGeometry( 0.1, 0.1, 2 ), material );\r\n\tfor ( let i = 0; i < TOTAL_SLATS; i ++ ) {\r\n\r\n\t\tconst s = slat.clone();\r\n\t\ts.position.x = - WIDTH * 0.5 + WIDTH * i / ( TOTAL_SLATS - 1 );\r\n\t\ts.position.y = 2;\r\n\t\tgroup.add( s );\r\n\r\n\t}\r\n\r\n\tscene.add( fogMesh, floor, group );\r\n\tpathTracer.setScene( scene, camera );\r\n\r\n\tloader.setPercentage( 1 );\r\n\tonParamsChange();\r\n\tonResize();\r\n\r\n\twindow.addEventListener( 'resize', onResize );\r\n\r\n\t// gui\r\n\tconst gui = new GUI();\r\n\tconst ptFolder = gui.addFolder( 'Path Tracer' );\r\n\tptFolder.add( params, 'bounces', 1, 20, 1 ).onChange( onParamsChange );\r\n\tptFolder.add( params, 'multipleImportanceSampling' ).onChange( onParamsChange );\r\n\tptFolder.add( params, 'tiles', 1, 4, 1 ).onChange( value => {\r\n\r\n\t\tpathTracer.tiles.set( value, value );\r\n\r\n\t} );\r\n\tptFolder.add( params, 'renderScale', 0.1, 1 ).onChange( onParamsChange );\r\n\r\n\tconst fogFolder = gui.addFolder( 'Fog' );\r\n\tfogFolder.addColor( params, 'color' ).onChange( onParamsChange );\r\n\tfogFolder.add( params, 'density', 0, 1 ).onChange( onParamsChange );\r\n\r\n\tconst lightFolder = gui.addFolder( 'Spot Light' );\r\n\tlightFolder.add( params, 'lightIntensity', 0, 1000 ).onChange( onParamsChange );\r\n\tlightFolder.addColor( params, 'lightColor' ).onChange( onParamsChange );\r\n\r\n\tanimate();\r\n\r\n}\r\n\r\nfunction onParamsChange() {\r\n\r\n\tfogMaterial.color.set( params.color ).convertSRGBToLinear();\r\n\tfogMaterial.density = params.density;\r\n\r\n\tspotLight.intensity = params.lightIntensity;\r\n\tspotLight.color.set( params.lightColor );\r\n\r\n\tpathTracer.multipleImportanceSampling = params.multipleImportanceSampling;\r\n\tpathTracer.bounces = params.bounces;\r\n\tpathTracer.renderScale = params.renderScale;\r\n\r\n\tpathTracer.updateLights();\r\n\tpathTracer.updateMaterials();\r\n\r\n}\r\n\r\nfunction onResize() {\r\n\r\n\trenderer.setSize( window.innerWidth, window.innerHeight );\r\n\trenderer.setPixelRatio( window.devicePixelRatio );\r\n\r\n\tcamera.aspect = window.innerWidth / window.innerHeight;\r\n\tcamera.updateProjectionMatrix();\r\n\r\n\tpathTracer.updateCamera();\r\n\r\n}\r\n\r\nfunction animate() {\r\n\r\n\trequestAnimationFrame( animate );\r\n\r\n\tpathTracer.renderSample();\r\n\r\n\tloader.setSamples( pathTracer.samples, pathTracer.isCompiling );\r\n\r\n}\r\n\r\n\r\n\r\n"],"names":["$afdbfb1b28c84b51$var$pathTracer","$afdbfb1b28c84b51$var$renderer","$afdbfb1b28c84b51$var$camera","$afdbfb1b28c84b51$var$scene","$afdbfb1b28c84b51$var$fogMaterial","$afdbfb1b28c84b51$var$spotLight","$afdbfb1b28c84b51$var$loader","$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$0c05d7af92b89513$export$cb2b7ad109612144","$ilwiq","MeshStandardMaterial","constructor","params","isFogVolumeMaterial","density","emissive","Color","emissiveIntensity","opacity","transparent","roughness","metalness","setValues","$983bac6297e5cd71$export$920191b129a29c0","SpotLight","args","iesMap","radius","copy","source","recursive","$934d596524c3e5a8$export$5bc756cb1c628b75","tiles","renderScale","Math","max","window","devicePixelRatio","innerWidth","innerHeight","$a399336cf50451da$var$_styleElement","$a399336cf50451da$export$c2252eb3bc5ad0b7","document","createElement","textContent","head","appendChild","container","classList","add","percentageEl","samplesEl","creditsEl","loaderBarEl","descriptionEl","_description","_loaderBar","_percentage","_credits","_samples","_container","setPercentage","attach","perc","style","width","innerText","toFixed","remove","setSamples","count","compiling","floor","setCredits","credits","innerHTML","setDescription","description","$6bd4eb2914ee2835$export$f1ac3a587b6cbb5d","ShaderMaterial","needsUpdate","dispatchEvent","type","shader","key","uniforms","value","setDefine","name","defines","$ba14a4aaa0cde19b$export$98323a006d35be35","$a21c9b4177584031$export$fe1d788deccfbee3","$60fb6dc3c6495c33$export$4c711108e2e8ef5e","$5Rd1x","$11ZPe","$kLfIo","$d4kES","$8mHfG","$jiuw3","$cE5k3","$e2Pv4","$afdbfb1b28c84b51$var$params","multipleImportanceSampling","color","fog","lightIntensity","lightColor","bounces","getScaledSettings","$afdbfb1b28c84b51$var$onParamsChange","convertSRGBToLinear","intensity","updateLights","updateMaterials","$afdbfb1b28c84b51$var$onResize","setSize","setPixelRatio","aspect","updateProjectionMatrix","updateCamera","$afdbfb1b28c84b51$var$init","LoaderElement","body","WebGLRenderer","antialias","toneMapping","ACESFilmicToneMapping","domElement","WebGLPathTracer","PhysicalCamera","position","$afdbfb1b28c84b51$var$controls","OrbitControls","addEventListener","Scene","background","FogVolumeMaterial","material","fogMesh","Mesh","BoxGeometry","CylinderGeometry","y","PhysicalSpotLight","multiplyScalar","angle","PI","decay","penumbra","distance","group","Group","slat","i","clone","x","WIDTH","TOTAL_SLATS","setScene","gui","GUI","ptFolder","addFolder","onChange","fogFolder","addColor","lightFolder","$afdbfb1b28c84b51$var$animate","requestAnimationFrame","renderSample","samples","isCompiling"],"version":3,"file":"fog.f4a51521.js.map"}